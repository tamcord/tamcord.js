/*! For license information please see fosscord.js.LICENSE.txt */
!function webpackUniversalModuleDefinition(e,n){"object"==typeof exports&&"object"==typeof module?module.exports=n():"function"==typeof define&&define.amd?define([],n):"object"==typeof exports?exports.Fosscord=n():e.Fosscord=n()}(window,(function(){return function(e){var n={};function __webpack_require__(t){if(n[t])return n[t].exports;var s=n[t]={i:t,l:!1,exports:{}};return e[t].call(s.exports,s,s.exports,__webpack_require__),s.l=!0,s.exports}return __webpack_require__.m=e,__webpack_require__.c=n,__webpack_require__.d=function(e,n,t){__webpack_require__.o(e,n)||Object.defineProperty(e,n,{enumerable:!0,get:t})},__webpack_require__.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},__webpack_require__.t=function(e,n){if(1&n&&(e=__webpack_require__(e)),8&n)return e;if(4&n&&"object"==typeof e&&e&&e.__esModule)return e;var t=Object.create(null);if(__webpack_require__.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:e}),2&n&&"string"!=typeof e)for(var s in e)__webpack_require__.d(t,s,function(n){return e[n]}.bind(null,s));return t},__webpack_require__.n=function(e){var n=e&&e.__esModule?function getDefault(){return e.default}:function getModuleExports(){return e};return __webpack_require__.d(n,"a",n),n},__webpack_require__.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},__webpack_require__.p="",__webpack_require__(__webpack_require__.s="./src/index.js")}({"./node_modules/@discordjs/form-data/lib/browser.js":function(module,exports){eval("/* eslint-env browser */\nmodule.exports = typeof self == 'object' ? self.FormData : window.FormData;\n\n\n//# sourceURL=webpack://Fosscord/./node_modules/@discordjs/form-data/lib/browser.js?")},"./node_modules/@sapphire/async-queue/dist/index.umd.js":function(module,exports,__webpack_require__){eval("(function (global, factory) {\n\t true ? factory(exports) :\n\tundefined;\n}(this, (function (exports) { 'use strict';\n\n\t/**\n\t * The AsyncQueue class used to sequentialize burst requests\n\t */\n\tclass AsyncQueue {\n\t    constructor() {\n\t        /**\n\t         * The promises array\n\t         */\n\t        Object.defineProperty(this, \"promises\", {\n\t            enumerable: true,\n\t            configurable: true,\n\t            writable: true,\n\t            value: []\n\t        });\n\t    }\n\t    /**\n\t     * The remaining amount of queued promises\n\t     */\n\t    get remaining() {\n\t        return this.promises.length;\n\t    }\n\t    /**\n\t     * Waits for last promise and queues a new one\n\t     * @example\n\t     * ```\n\t     * const queue = new AsyncQueue();\n\t     * async function request(url, options) {\n\t     *     await queue.wait();\n\t     *     try {\n\t     *         const result = await fetch(url, options);\n\t     *         // Do some operations with 'result'\n\t     *     } finally {\n\t     *         // Remove first entry from the queue and resolve for the next entry\n\t     *         queue.shift();\n\t     *     }\n\t     * }\n\t     *\n\t     * request(someUrl1, someOptions1); // Will call fetch() immediately\n\t     * request(someUrl2, someOptions2); // Will call fetch() after the first finished\n\t     * request(someUrl3, someOptions3); // Will call fetch() after the second finished\n\t     * ```\n\t     */\n\t    wait() {\n\t        const next = this.promises.length ? this.promises[this.promises.length - 1].promise : Promise.resolve();\n\t        let resolve;\n\t        const promise = new Promise((res) => {\n\t            resolve = res;\n\t        });\n\t        this.promises.push({\n\t            resolve: resolve,\n\t            promise\n\t        });\n\t        return next;\n\t    }\n\t    /**\n\t     * Frees the queue's lock for the next item to process\n\t     */\n\t    shift() {\n\t        const deferred = this.promises.shift();\n\t        if (typeof deferred !== 'undefined')\n\t            deferred.resolve();\n\t    }\n\t}\n\n\texports.AsyncQueue = AsyncQueue;\n\n\tObject.defineProperty(exports, '__esModule', { value: true });\n\n})));\n//# sourceMappingURL=index.umd.js.map\n\n\n//# sourceURL=webpack://Fosscord/./node_modules/@sapphire/async-queue/dist/index.umd.js?")},"./node_modules/abort-controller/browser.js":function(module,exports,__webpack_require__){"use strict";eval('/*globals self, window */\n\n\n/*eslint-disable @mysticatea/prettier */\nconst { AbortController, AbortSignal } =\n    typeof self !== "undefined" ? self :\n    typeof window !== "undefined" ? window :\n    /* otherwise */ undefined\n/*eslint-enable @mysticatea/prettier */\n\nmodule.exports = AbortController\nmodule.exports.AbortSignal = AbortSignal\nmodule.exports.default = AbortController\n\n\n//# sourceURL=webpack://Fosscord/./node_modules/abort-controller/browser.js?')},"./node_modules/base64-js/index.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n\n\n//# sourceURL=webpack://Fosscord/./node_modules/base64-js/index.js?")},"./node_modules/events/events.js":function(module,exports,__webpack_require__){"use strict";eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function errorListener(err) {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    }\n\n    function resolver() {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    };\n\n    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });\n    if (name !== 'error') {\n      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });\n    }\n  });\n}\n\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === 'function') {\n    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters, we do not listen for `error` events here.\n    emitter.addEventListener(name, function wrapListener(arg) {\n      // IE does not have builtin `{ once: true }` support so we\n      // have to do it manually.\n      if (flags.once) {\n        emitter.removeEventListener(name, wrapListener);\n      }\n      listener(arg);\n    });\n  } else {\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n  }\n}\n\n\n//# sourceURL=webpack://Fosscord/./node_modules/events/events.js?")},"./node_modules/ieee754/index.js":function(module,exports){eval("/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n\n\n//# sourceURL=webpack://Fosscord/./node_modules/ieee754/index.js?")},"./node_modules/isarray/index.js":function(module,exports){eval("var toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n\n\n//# sourceURL=webpack://Fosscord/./node_modules/isarray/index.js?")},"./node_modules/node-fetch/browser.js":function(module,exports,__webpack_require__){"use strict";eval("\n\n// ref: https://github.com/tc39/proposal-global\nvar getGlobal = function () {\n\t// the only reliable means to get the global object is\n\t// `Function('return this')()`\n\t// However, this causes CSP violations in Chrome apps.\n\tif (typeof self !== 'undefined') { return self; }\n\tif (typeof window !== 'undefined') { return window; }\n\tif (typeof global !== 'undefined') { return global; }\n\tthrow new Error('unable to locate global object');\n}\n\nvar global = getGlobal();\n\nmodule.exports = exports = global.fetch;\n\n// Needed for TypeScript and Webpack.\nif (global.fetch) {\n\texports.default = global.fetch.bind(global);\n}\n\nexports.Headers = global.Headers;\nexports.Request = global.Request;\nexports.Response = global.Response;\n\n//# sourceURL=webpack://Fosscord/./node_modules/node-fetch/browser.js?")},"./node_modules/node-libs-browser/mock/empty.js":function(module,exports){eval("\n\n//# sourceURL=webpack://Fosscord/./node_modules/node-libs-browser/mock/empty.js?")},"./node_modules/node-libs-browser/node_modules/buffer/index.js":function(module,exports,__webpack_require__){"use strict";eval("/* WEBPACK VAR INJECTION */(function(global) {/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n\n\nvar base64 = __webpack_require__(/*! base64-js */ \"./node_modules/base64-js/index.js\")\nvar ieee754 = __webpack_require__(/*! ieee754 */ \"./node_modules/ieee754/index.js\")\nvar isArray = __webpack_require__(/*! isarray */ \"./node_modules/isarray/index.js\")\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\n/*\n * Export kMaxLength after typed array support is determined.\n */\nexports.kMaxLength = kMaxLength()\n\nfunction typedArraySupport () {\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\n    return arr.foo() === 42 && // typed array instances can be augmented\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\nfunction createBuffer (that, length) {\n  if (kMaxLength() < length) {\n    throw new RangeError('Invalid typed array length')\n  }\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(length)\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    if (that === null) {\n      that = new Buffer(length)\n    }\n    that.length = length\n  }\n\n  return that\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n    return new Buffer(arg, encodingOrOffset, length)\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n        'If encoding is specified then the first argument must be a string'\n      )\n    }\n    return allocUnsafe(this, arg)\n  }\n  return from(this, arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype\n  return arr\n}\n\nfunction from (that, value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    return fromArrayBuffer(that, value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(that, value, encodingOrOffset)\n  }\n\n  return fromObject(that, value)\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(null, value, encodingOrOffset, length)\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n  if (typeof Symbol !== 'undefined' && Symbol.species &&\n      Buffer[Symbol.species] === Buffer) {\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n    Object.defineProperty(Buffer, Symbol.species, {\n      value: null,\n      configurable: true\n    })\n  }\n}\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number')\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative')\n  }\n}\n\nfunction alloc (that, size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(that, size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(that, size).fill(fill, encoding)\n      : createBuffer(that, size).fill(fill)\n  }\n  return createBuffer(that, size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(null, size, fill, encoding)\n}\n\nfunction allocUnsafe (that, size) {\n  assertSize(size)\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < size; ++i) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(null, size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(null, size)\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  var length = byteLength(string, encoding) | 0\n  that = createBuffer(that, length)\n\n  var actual = that.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    that = that.slice(0, actual)\n  }\n\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  that = createBuffer(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array, byteOffset, length) {\n  array.byteLength // this throws if `array` is not a valid ArrayBuffer\n\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds')\n  }\n\n  if (byteOffset === undefined && length === undefined) {\n    array = new Uint8Array(array)\n  } else if (length === undefined) {\n    array = new Uint8Array(array, byteOffset)\n  } else {\n    array = new Uint8Array(array, byteOffset, length)\n  }\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = array\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromArrayLike(that, array)\n  }\n  return that\n}\n\nfunction fromObject (that, obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    that = createBuffer(that, len)\n\n    if (that.length === 0) {\n      return that\n    }\n\n    obj.copy(that, 0, 0, len)\n    return that\n  }\n\n  if (obj) {\n    if ((typeof ArrayBuffer !== 'undefined' &&\n        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n        return createBuffer(that, 0)\n      }\n      return fromArrayLike(that, obj)\n    }\n\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\n      return fromArrayLike(that, obj.data)\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength()` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    string = '' + string\n  }\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer')\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset  // Coerce to Number.\n  if (isNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (Buffer.TYPED_ARRAY_SUPPORT &&\n        typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end)\n    newBuf.__proto__ = Buffer.prototype\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; ++i) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if (code < 256) {\n        val = code\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : utf8ToBytes(new Buffer(val, encoding).toString())\n    var len = bytes.length\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\nfunction isnan (val) {\n  return val !== val // eslint-disable-line no-self-compare\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack://Fosscord/./node_modules/node-libs-browser/node_modules/buffer/index.js?")},"./node_modules/node-libs-browser/node_modules/inherits/inherits_browser.js":function(module,exports){eval("if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n\n\n//# sourceURL=webpack://Fosscord/./node_modules/node-libs-browser/node_modules/inherits/inherits_browser.js?")},"./node_modules/node-libs-browser/node_modules/util/support/isBufferBrowser.js":function(module,exports){eval("module.exports = function isBuffer(arg) {\n  return arg && typeof arg === 'object'\n    && typeof arg.copy === 'function'\n    && typeof arg.fill === 'function'\n    && typeof arg.readUInt8 === 'function';\n}\n\n//# sourceURL=webpack://Fosscord/./node_modules/node-libs-browser/node_modules/util/support/isBufferBrowser.js?")},"./node_modules/node-libs-browser/node_modules/util/util.js":function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors ||\n  function getOwnPropertyDescriptors(obj) {\n    var keys = Object.keys(obj);\n    var descriptors = {};\n    for (var i = 0; i < keys.length; i++) {\n      descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);\n    }\n    return descriptors;\n  };\n\nvar formatRegExp = /%[sdj%]/g;\nexports.format = function(f) {\n  if (!isString(f)) {\n    var objects = [];\n    for (var i = 0; i < arguments.length; i++) {\n      objects.push(inspect(arguments[i]));\n    }\n    return objects.join(' ');\n  }\n\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  var str = String(f).replace(formatRegExp, function(x) {\n    if (x === '%%') return '%';\n    if (i >= len) return x;\n    switch (x) {\n      case '%s': return String(args[i++]);\n      case '%d': return Number(args[i++]);\n      case '%j':\n        try {\n          return JSON.stringify(args[i++]);\n        } catch (_) {\n          return '[Circular]';\n        }\n      default:\n        return x;\n    }\n  });\n  for (var x = args[i]; i < len; x = args[++i]) {\n    if (isNull(x) || !isObject(x)) {\n      str += ' ' + x;\n    } else {\n      str += ' ' + inspect(x);\n    }\n  }\n  return str;\n};\n\n\n// Mark that a method should not be used.\n// Returns a modified function which warns once by default.\n// If --no-deprecation is set, then it is a no-op.\nexports.deprecate = function(fn, msg) {\n  if (typeof process !== 'undefined' && process.noDeprecation === true) {\n    return fn;\n  }\n\n  // Allow for deprecating things in the process of starting up.\n  if (typeof process === 'undefined') {\n    return function() {\n      return exports.deprecate(fn, msg).apply(this, arguments);\n    };\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (process.throwDeprecation) {\n        throw new Error(msg);\n      } else if (process.traceDeprecation) {\n        console.trace(msg);\n      } else {\n        console.error(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n};\n\n\nvar debugs = {};\nvar debugEnviron;\nexports.debuglog = function(set) {\n  if (isUndefined(debugEnviron))\n    debugEnviron = process.env.NODE_DEBUG || '';\n  set = set.toUpperCase();\n  if (!debugs[set]) {\n    if (new RegExp('\\\\b' + set + '\\\\b', 'i').test(debugEnviron)) {\n      var pid = process.pid;\n      debugs[set] = function() {\n        var msg = exports.format.apply(exports, arguments);\n        console.error('%s %d: %s', set, pid, msg);\n      };\n    } else {\n      debugs[set] = function() {};\n    }\n  }\n  return debugs[set];\n};\n\n\n/**\n * Echos the value of a value. Trys to print the value out\n * in the best way possible given the different types.\n *\n * @param {Object} obj The object to print out.\n * @param {Object} opts Optional options object that alters the output.\n */\n/* legacy: obj, showHidden, depth, colors*/\nfunction inspect(obj, opts) {\n  // default options\n  var ctx = {\n    seen: [],\n    stylize: stylizeNoColor\n  };\n  // legacy...\n  if (arguments.length >= 3) ctx.depth = arguments[2];\n  if (arguments.length >= 4) ctx.colors = arguments[3];\n  if (isBoolean(opts)) {\n    // legacy...\n    ctx.showHidden = opts;\n  } else if (opts) {\n    // got an \"options\" object\n    exports._extend(ctx, opts);\n  }\n  // set default options\n  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\n  if (isUndefined(ctx.depth)) ctx.depth = 2;\n  if (isUndefined(ctx.colors)) ctx.colors = false;\n  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\n  if (ctx.colors) ctx.stylize = stylizeWithColor;\n  return formatValue(ctx, obj, ctx.depth);\n}\nexports.inspect = inspect;\n\n\n// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\ninspect.colors = {\n  'bold' : [1, 22],\n  'italic' : [3, 23],\n  'underline' : [4, 24],\n  'inverse' : [7, 27],\n  'white' : [37, 39],\n  'grey' : [90, 39],\n  'black' : [30, 39],\n  'blue' : [34, 39],\n  'cyan' : [36, 39],\n  'green' : [32, 39],\n  'magenta' : [35, 39],\n  'red' : [31, 39],\n  'yellow' : [33, 39]\n};\n\n// Don't use 'blue' not visible on cmd.exe\ninspect.styles = {\n  'special': 'cyan',\n  'number': 'yellow',\n  'boolean': 'yellow',\n  'undefined': 'grey',\n  'null': 'bold',\n  'string': 'green',\n  'date': 'magenta',\n  // \"name\": intentionally not styling\n  'regexp': 'red'\n};\n\n\nfunction stylizeWithColor(str, styleType) {\n  var style = inspect.styles[styleType];\n\n  if (style) {\n    return '\\u001b[' + inspect.colors[style][0] + 'm' + str +\n           '\\u001b[' + inspect.colors[style][1] + 'm';\n  } else {\n    return str;\n  }\n}\n\n\nfunction stylizeNoColor(str, styleType) {\n  return str;\n}\n\n\nfunction arrayToHash(array) {\n  var hash = {};\n\n  array.forEach(function(val, idx) {\n    hash[val] = true;\n  });\n\n  return hash;\n}\n\n\nfunction formatValue(ctx, value, recurseTimes) {\n  // Provide a hook for user-specified inspect functions.\n  // Check that value is an object with an inspect function on it\n  if (ctx.customInspect &&\n      value &&\n      isFunction(value.inspect) &&\n      // Filter out the util module, it's inspect function is special\n      value.inspect !== exports.inspect &&\n      // Also filter out any prototype objects using the circular check.\n      !(value.constructor && value.constructor.prototype === value)) {\n    var ret = value.inspect(recurseTimes, ctx);\n    if (!isString(ret)) {\n      ret = formatValue(ctx, ret, recurseTimes);\n    }\n    return ret;\n  }\n\n  // Primitive types cannot have properties\n  var primitive = formatPrimitive(ctx, value);\n  if (primitive) {\n    return primitive;\n  }\n\n  // Look up the keys of the object.\n  var keys = Object.keys(value);\n  var visibleKeys = arrayToHash(keys);\n\n  if (ctx.showHidden) {\n    keys = Object.getOwnPropertyNames(value);\n  }\n\n  // IE doesn't make error fields non-enumerable\n  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx\n  if (isError(value)\n      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {\n    return formatError(value);\n  }\n\n  // Some type of object without properties can be shortcutted.\n  if (keys.length === 0) {\n    if (isFunction(value)) {\n      var name = value.name ? ': ' + value.name : '';\n      return ctx.stylize('[Function' + name + ']', 'special');\n    }\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    }\n    if (isDate(value)) {\n      return ctx.stylize(Date.prototype.toString.call(value), 'date');\n    }\n    if (isError(value)) {\n      return formatError(value);\n    }\n  }\n\n  var base = '', array = false, braces = ['{', '}'];\n\n  // Make Array say that they are Array\n  if (isArray(value)) {\n    array = true;\n    braces = ['[', ']'];\n  }\n\n  // Make functions say that they are functions\n  if (isFunction(value)) {\n    var n = value.name ? ': ' + value.name : '';\n    base = ' [Function' + n + ']';\n  }\n\n  // Make RegExps say that they are RegExps\n  if (isRegExp(value)) {\n    base = ' ' + RegExp.prototype.toString.call(value);\n  }\n\n  // Make dates with properties first say the date\n  if (isDate(value)) {\n    base = ' ' + Date.prototype.toUTCString.call(value);\n  }\n\n  // Make error with message first say the error\n  if (isError(value)) {\n    base = ' ' + formatError(value);\n  }\n\n  if (keys.length === 0 && (!array || value.length == 0)) {\n    return braces[0] + base + braces[1];\n  }\n\n  if (recurseTimes < 0) {\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    } else {\n      return ctx.stylize('[Object]', 'special');\n    }\n  }\n\n  ctx.seen.push(value);\n\n  var output;\n  if (array) {\n    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n  } else {\n    output = keys.map(function(key) {\n      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n    });\n  }\n\n  ctx.seen.pop();\n\n  return reduceToSingleString(output, base, braces);\n}\n\n\nfunction formatPrimitive(ctx, value) {\n  if (isUndefined(value))\n    return ctx.stylize('undefined', 'undefined');\n  if (isString(value)) {\n    var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n                                             .replace(/'/g, \"\\\\'\")\n                                             .replace(/\\\\\"/g, '\"') + '\\'';\n    return ctx.stylize(simple, 'string');\n  }\n  if (isNumber(value))\n    return ctx.stylize('' + value, 'number');\n  if (isBoolean(value))\n    return ctx.stylize('' + value, 'boolean');\n  // For some reason typeof null is \"object\", so special case here.\n  if (isNull(value))\n    return ctx.stylize('null', 'null');\n}\n\n\nfunction formatError(value) {\n  return '[' + Error.prototype.toString.call(value) + ']';\n}\n\n\nfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n  var output = [];\n  for (var i = 0, l = value.length; i < l; ++i) {\n    if (hasOwnProperty(value, String(i))) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          String(i), true));\n    } else {\n      output.push('');\n    }\n  }\n  keys.forEach(function(key) {\n    if (!key.match(/^\\d+$/)) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          key, true));\n    }\n  });\n  return output;\n}\n\n\nfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n  var name, str, desc;\n  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };\n  if (desc.get) {\n    if (desc.set) {\n      str = ctx.stylize('[Getter/Setter]', 'special');\n    } else {\n      str = ctx.stylize('[Getter]', 'special');\n    }\n  } else {\n    if (desc.set) {\n      str = ctx.stylize('[Setter]', 'special');\n    }\n  }\n  if (!hasOwnProperty(visibleKeys, key)) {\n    name = '[' + key + ']';\n  }\n  if (!str) {\n    if (ctx.seen.indexOf(desc.value) < 0) {\n      if (isNull(recurseTimes)) {\n        str = formatValue(ctx, desc.value, null);\n      } else {\n        str = formatValue(ctx, desc.value, recurseTimes - 1);\n      }\n      if (str.indexOf('\\n') > -1) {\n        if (array) {\n          str = str.split('\\n').map(function(line) {\n            return '  ' + line;\n          }).join('\\n').substr(2);\n        } else {\n          str = '\\n' + str.split('\\n').map(function(line) {\n            return '   ' + line;\n          }).join('\\n');\n        }\n      }\n    } else {\n      str = ctx.stylize('[Circular]', 'special');\n    }\n  }\n  if (isUndefined(name)) {\n    if (array && key.match(/^\\d+$/)) {\n      return str;\n    }\n    name = JSON.stringify('' + key);\n    if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n      name = name.substr(1, name.length - 2);\n      name = ctx.stylize(name, 'name');\n    } else {\n      name = name.replace(/'/g, \"\\\\'\")\n                 .replace(/\\\\\"/g, '\"')\n                 .replace(/(^\"|\"$)/g, \"'\");\n      name = ctx.stylize(name, 'string');\n    }\n  }\n\n  return name + ': ' + str;\n}\n\n\nfunction reduceToSingleString(output, base, braces) {\n  var numLinesEst = 0;\n  var length = output.reduce(function(prev, cur) {\n    numLinesEst++;\n    if (cur.indexOf('\\n') >= 0) numLinesEst++;\n    return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, '').length + 1;\n  }, 0);\n\n  if (length > 60) {\n    return braces[0] +\n           (base === '' ? '' : base + '\\n ') +\n           ' ' +\n           output.join(',\\n  ') +\n           ' ' +\n           braces[1];\n  }\n\n  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n}\n\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\nfunction isArray(ar) {\n  return Array.isArray(ar);\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return isObject(re) && objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return isObject(d) && objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return isObject(e) &&\n      (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = __webpack_require__(/*! ./support/isBuffer */ \"./node_modules/node-libs-browser/node_modules/util/support/isBufferBrowser.js\");\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n\nfunction pad(n) {\n  return n < 10 ? '0' + n.toString(10) : n.toString(10);\n}\n\n\nvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\n              'Oct', 'Nov', 'Dec'];\n\n// 26 Feb 16:19:34\nfunction timestamp() {\n  var d = new Date();\n  var time = [pad(d.getHours()),\n              pad(d.getMinutes()),\n              pad(d.getSeconds())].join(':');\n  return [d.getDate(), months[d.getMonth()], time].join(' ');\n}\n\n\n// log is just a thin wrapper to console.log that prepends a timestamp\nexports.log = function() {\n  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));\n};\n\n\n/**\n * Inherit the prototype methods from one constructor into another.\n *\n * The Function.prototype.inherits from lang.js rewritten as a standalone\n * function (not on Function.prototype). NOTE: If this file is to be loaded\n * during bootstrapping this function needs to be rewritten using some native\n * functions as prototype setup using normal JavaScript does not work as\n * expected during bootstrapping (see mirror.js in r114903).\n *\n * @param {function} ctor Constructor function which needs to inherit the\n *     prototype.\n * @param {function} superCtor Constructor function to inherit prototype from.\n */\nexports.inherits = __webpack_require__(/*! inherits */ \"./node_modules/node-libs-browser/node_modules/inherits/inherits_browser.js\");\n\nexports._extend = function(origin, add) {\n  // Don't do anything if add isn't an object\n  if (!add || !isObject(add)) return origin;\n\n  var keys = Object.keys(add);\n  var i = keys.length;\n  while (i--) {\n    origin[keys[i]] = add[keys[i]];\n  }\n  return origin;\n};\n\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nvar kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;\n\nexports.promisify = function promisify(original) {\n  if (typeof original !== 'function')\n    throw new TypeError('The \"original\" argument must be of type Function');\n\n  if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {\n    var fn = original[kCustomPromisifiedSymbol];\n    if (typeof fn !== 'function') {\n      throw new TypeError('The \"util.promisify.custom\" argument must be of type Function');\n    }\n    Object.defineProperty(fn, kCustomPromisifiedSymbol, {\n      value: fn, enumerable: false, writable: false, configurable: true\n    });\n    return fn;\n  }\n\n  function fn() {\n    var promiseResolve, promiseReject;\n    var promise = new Promise(function (resolve, reject) {\n      promiseResolve = resolve;\n      promiseReject = reject;\n    });\n\n    var args = [];\n    for (var i = 0; i < arguments.length; i++) {\n      args.push(arguments[i]);\n    }\n    args.push(function (err, value) {\n      if (err) {\n        promiseReject(err);\n      } else {\n        promiseResolve(value);\n      }\n    });\n\n    try {\n      original.apply(this, args);\n    } catch (err) {\n      promiseReject(err);\n    }\n\n    return promise;\n  }\n\n  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));\n\n  if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {\n    value: fn, enumerable: false, writable: false, configurable: true\n  });\n  return Object.defineProperties(\n    fn,\n    getOwnPropertyDescriptors(original)\n  );\n}\n\nexports.promisify.custom = kCustomPromisifiedSymbol\n\nfunction callbackifyOnRejected(reason, cb) {\n  // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).\n  // Because `null` is a special error value in callbacks which means \"no error\n  // occurred\", we error-wrap so the callback consumer can distinguish between\n  // \"the promise rejected with null\" or \"the promise fulfilled with undefined\".\n  if (!reason) {\n    var newReason = new Error('Promise was rejected with a falsy value');\n    newReason.reason = reason;\n    reason = newReason;\n  }\n  return cb(reason);\n}\n\nfunction callbackify(original) {\n  if (typeof original !== 'function') {\n    throw new TypeError('The \"original\" argument must be of type Function');\n  }\n\n  // We DO NOT return the promise as it gives the user a false sense that\n  // the promise is actually somehow related to the callback's execution\n  // and that the callback throwing will reject the promise.\n  function callbackified() {\n    var args = [];\n    for (var i = 0; i < arguments.length; i++) {\n      args.push(arguments[i]);\n    }\n\n    var maybeCb = args.pop();\n    if (typeof maybeCb !== 'function') {\n      throw new TypeError('The last argument must be of type Function');\n    }\n    var self = this;\n    var cb = function() {\n      return maybeCb.apply(self, arguments);\n    };\n    // In true node style we process the callback on `nextTick` with all the\n    // implications (stack, `uncaughtException`, `async_hooks`)\n    original.apply(this, args)\n      .then(function(ret) { process.nextTick(cb, null, ret) },\n            function(rej) { process.nextTick(callbackifyOnRejected, rej, cb) });\n  }\n\n  Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));\n  Object.defineProperties(callbackified,\n                          getOwnPropertyDescriptors(original));\n  return callbackified;\n}\nexports.callbackify = callbackify;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack://Fosscord/./node_modules/node-libs-browser/node_modules/util/util.js?")},"./node_modules/process/browser.js":function(module,exports){eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n//# sourceURL=webpack://Fosscord/./node_modules/process/browser.js?")},"./node_modules/setimmediate/setImmediate.js":function(module,exports,__webpack_require__){eval('/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {\n    "use strict";\n\n    if (global.setImmediate) {\n        return;\n    }\n\n    var nextHandle = 1; // Spec says greater than zero\n    var tasksByHandle = {};\n    var currentlyRunningATask = false;\n    var doc = global.document;\n    var registerImmediate;\n\n    function setImmediate(callback) {\n      // Callback can either be a function or a string\n      if (typeof callback !== "function") {\n        callback = new Function("" + callback);\n      }\n      // Copy function arguments\n      var args = new Array(arguments.length - 1);\n      for (var i = 0; i < args.length; i++) {\n          args[i] = arguments[i + 1];\n      }\n      // Store and register the task\n      var task = { callback: callback, args: args };\n      tasksByHandle[nextHandle] = task;\n      registerImmediate(nextHandle);\n      return nextHandle++;\n    }\n\n    function clearImmediate(handle) {\n        delete tasksByHandle[handle];\n    }\n\n    function run(task) {\n        var callback = task.callback;\n        var args = task.args;\n        switch (args.length) {\n        case 0:\n            callback();\n            break;\n        case 1:\n            callback(args[0]);\n            break;\n        case 2:\n            callback(args[0], args[1]);\n            break;\n        case 3:\n            callback(args[0], args[1], args[2]);\n            break;\n        default:\n            callback.apply(undefined, args);\n            break;\n        }\n    }\n\n    function runIfPresent(handle) {\n        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."\n        // So if we\'re currently running a task, we\'ll need to delay this invocation.\n        if (currentlyRunningATask) {\n            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n            // "too much recursion" error.\n            setTimeout(runIfPresent, 0, handle);\n        } else {\n            var task = tasksByHandle[handle];\n            if (task) {\n                currentlyRunningATask = true;\n                try {\n                    run(task);\n                } finally {\n                    clearImmediate(handle);\n                    currentlyRunningATask = false;\n                }\n            }\n        }\n    }\n\n    function installNextTickImplementation() {\n        registerImmediate = function(handle) {\n            process.nextTick(function () { runIfPresent(handle); });\n        };\n    }\n\n    function canUsePostMessage() {\n        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n        // where `global.postMessage` means something completely different and can\'t be used for this purpose.\n        if (global.postMessage && !global.importScripts) {\n            var postMessageIsAsynchronous = true;\n            var oldOnMessage = global.onmessage;\n            global.onmessage = function() {\n                postMessageIsAsynchronous = false;\n            };\n            global.postMessage("", "*");\n            global.onmessage = oldOnMessage;\n            return postMessageIsAsynchronous;\n        }\n    }\n\n    function installPostMessageImplementation() {\n        // Installs an event handler on `global` for the `message` event: see\n        // * https://developer.mozilla.org/en/DOM/window.postMessage\n        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n\n        var messagePrefix = "setImmediate$" + Math.random() + "$";\n        var onGlobalMessage = function(event) {\n            if (event.source === global &&\n                typeof event.data === "string" &&\n                event.data.indexOf(messagePrefix) === 0) {\n                runIfPresent(+event.data.slice(messagePrefix.length));\n            }\n        };\n\n        if (global.addEventListener) {\n            global.addEventListener("message", onGlobalMessage, false);\n        } else {\n            global.attachEvent("onmessage", onGlobalMessage);\n        }\n\n        registerImmediate = function(handle) {\n            global.postMessage(messagePrefix + handle, "*");\n        };\n    }\n\n    function installMessageChannelImplementation() {\n        var channel = new MessageChannel();\n        channel.port1.onmessage = function(event) {\n            var handle = event.data;\n            runIfPresent(handle);\n        };\n\n        registerImmediate = function(handle) {\n            channel.port2.postMessage(handle);\n        };\n    }\n\n    function installReadyStateChangeImplementation() {\n        var html = doc.documentElement;\n        registerImmediate = function(handle) {\n            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n            // into the document. Do so, thus queuing up the task. Remember to clean up once it\'s been called.\n            var script = doc.createElement("script");\n            script.onreadystatechange = function () {\n                runIfPresent(handle);\n                script.onreadystatechange = null;\n                html.removeChild(script);\n                script = null;\n            };\n            html.appendChild(script);\n        };\n    }\n\n    function installSetTimeoutImplementation() {\n        registerImmediate = function(handle) {\n            setTimeout(runIfPresent, 0, handle);\n        };\n    }\n\n    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\n\n    // Don\'t get fooled by e.g. browserify environments.\n    if ({}.toString.call(global.process) === "[object process]") {\n        // For Node.js before 0.9\n        installNextTickImplementation();\n\n    } else if (canUsePostMessage()) {\n        // For non-IE10 modern browsers\n        installPostMessageImplementation();\n\n    } else if (global.MessageChannel) {\n        // For web workers, where supported\n        installMessageChannelImplementation();\n\n    } else if (doc && "onreadystatechange" in doc.createElement("script")) {\n        // For IE 68\n        installReadyStateChangeImplementation();\n\n    } else {\n        // For older browsers\n        installSetTimeoutImplementation();\n    }\n\n    attachTo.setImmediate = setImmediate;\n    attachTo.clearImmediate = clearImmediate;\n}(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self));\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../process/browser.js */ "./node_modules/process/browser.js")))\n\n//# sourceURL=webpack://Fosscord/./node_modules/setimmediate/setImmediate.js?')},"./node_modules/timers-browserify/main.js":function(module,exports,__webpack_require__){eval('/* WEBPACK VAR INJECTION */(function(global) {var scope = (typeof global !== "undefined" && global) ||\n            (typeof self !== "undefined" && self) ||\n            window;\nvar apply = Function.prototype.apply;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) {\n  if (timeout) {\n    timeout.close();\n  }\n};\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(scope, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// setimmediate attaches itself to the global object\n__webpack_require__(/*! setimmediate */ "./node_modules/setimmediate/setImmediate.js");\n// On some exotic environments, it\'s not clear which object `setimmediate` was\n// able to install onto.  Search each possibility in the same order as the\n// `setimmediate` library.\nexports.setImmediate = (typeof self !== "undefined" && self.setImmediate) ||\n                       (typeof global !== "undefined" && global.setImmediate) ||\n                       (this && this.setImmediate);\nexports.clearImmediate = (typeof self !== "undefined" && self.clearImmediate) ||\n                         (typeof global !== "undefined" && global.clearImmediate) ||\n                         (this && this.clearImmediate);\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))\n\n//# sourceURL=webpack://Fosscord/./node_modules/timers-browserify/main.js?')},"./node_modules/webpack/buildin/global.js":function(module,exports){eval('var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function("return this")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === "object") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it\'s\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n\n//# sourceURL=webpack://Fosscord/(webpack)/buildin/global.js?')},"./package.json":function(module,exports){eval('module.exports = ({"version":"13.0.0-dev","homepage":"https://github.com/fosscord/fosscord.js#readme"})\n\n//# sourceURL=webpack://Fosscord/./package.json?')},"./src/WebSocket.js":function(module,exports,__webpack_require__){"use strict";eval("/* WEBPACK VAR INJECTION */(function(Buffer) {\n\nconst {\n  browser\n} = __webpack_require__(/*! ./util/Constants */ \"./src/util/Constants.js\");\n\nlet erlpack;\n\ntry {\n  erlpack = __webpack_require__(/*! erlpack */ 2);\n  if (!erlpack.pack) erlpack = null;\n} catch {} // eslint-disable-line no-empty\n\n\nlet TextDecoder;\n\nif (browser) {\n  TextDecoder = window.TextDecoder; // eslint-disable-line no-undef\n\n  exports.WebSocket = window.WebSocket; // eslint-disable-line no-undef\n} else {\n  TextDecoder = __webpack_require__(/*! util */ \"./node_modules/node-libs-browser/node_modules/util/util.js\").TextDecoder;\n  exports.WebSocket = __webpack_require__(/*! ws */ 3);\n}\n\nconst ab = new TextDecoder();\nexports.encoding = erlpack ? 'etf' : 'json';\nexports.pack = erlpack ? erlpack.pack : JSON.stringify;\n\nexports.unpack = (data, type) => {\n  if (exports.encoding === 'json' || type === 'json') {\n    if (typeof data !== 'string') {\n      data = ab.decode(data);\n    }\n\n    return JSON.parse(data);\n  }\n\n  if (!Buffer.isBuffer(data)) data = Buffer.from(new Uint8Array(data));\n  return erlpack.unpack(data);\n};\n\nexports.create = (gateway, query = {}, ...args) => {\n  const [g, q] = gateway.split('?');\n  query.encoding = exports.encoding;\n  query = new URLSearchParams(query);\n  if (q) new URLSearchParams(q).forEach((v, k) => query.set(k, v));\n  const ws = new exports.WebSocket(`${g}?${query}`, ...args);\n  if (browser) ws.binaryType = 'arraybuffer';\n  return ws;\n};\n\nfor (const state of ['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED']) exports[state] = exports.WebSocket[state];\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/node-libs-browser/node_modules/buffer/index.js */ \"./node_modules/node-libs-browser/node_modules/buffer/index.js\").Buffer))\n\n//# sourceURL=webpack://Fosscord/./src/WebSocket.js?")},"./src/client/BaseClient.js":function(module,exports,__webpack_require__){"use strict";eval('/* WEBPACK VAR INJECTION */(function(setImmediate, clearImmediate) {\n\nconst EventEmitter = __webpack_require__(/*! events */ "./node_modules/events/events.js");\n\nconst RESTManager = __webpack_require__(/*! ../rest/RESTManager */ "./src/rest/RESTManager.js");\n\nconst {\n  DefaultOptions\n} = __webpack_require__(/*! ../util/Constants */ "./src/util/Constants.js");\n\nconst Util = __webpack_require__(/*! ../util/Util */ "./src/util/Util.js");\n/**\n * The base class for all clients.\n * @extends {EventEmitter}\n */\n\n\nclass BaseClient extends EventEmitter {\n  constructor(options = {}) {\n    super();\n    /**\n     * Timeouts set by {@link BaseClient#setTimeout} that are still active\n     * @type {Set<Timeout>}\n     * @private\n     */\n\n    this._timeouts = new Set();\n    /**\n     * Intervals set by {@link BaseClient#setInterval} that are still active\n     * @type {Set<Timeout>}\n     * @private\n     */\n\n    this._intervals = new Set();\n    /**\n     * Intervals set by {@link BaseClient#setImmediate} that are still active\n     * @type {Set<Immediate>}\n     * @private\n     */\n\n    this._immediates = new Set();\n    /**\n     * The options the client was instantiated with\n     * @type {ClientOptions}\n     */\n\n    this.options = Util.mergeDefault(DefaultOptions, options);\n    /**\n     * The REST manager of the client\n     * @type {RESTManager}\n     * @private\n     */\n\n    this.rest = new RESTManager(this);\n  }\n  /**\n   * API shortcut\n   * @type {Object}\n   * @readonly\n   * @private\n   */\n\n\n  get api() {\n    return this.rest.api;\n  }\n  /**\n   * Destroys all assets used by the base client.\n   */\n\n\n  destroy() {\n    for (const t of this._timeouts) this.clearTimeout(t);\n\n    for (const i of this._intervals) this.clearInterval(i);\n\n    for (const i of this._immediates) this.clearImmediate(i);\n\n    this._timeouts.clear();\n\n    this._intervals.clear();\n\n    this._immediates.clear();\n  }\n  /**\n   * Sets a timeout that will be automatically cancelled if the client is destroyed.\n   * @param {Function} fn Function to execute\n   * @param {number} delay Time to wait before executing (in milliseconds)\n   * @param {...*} args Arguments for the function\n   * @returns {Timeout}\n   */\n\n\n  setTimeout(fn, delay, ...args) {\n    const timeout = setTimeout(() => {\n      fn(...args);\n\n      this._timeouts.delete(timeout);\n    }, delay);\n\n    this._timeouts.add(timeout);\n\n    return timeout;\n  }\n  /**\n   * Clears a timeout.\n   * @param {Timeout} timeout Timeout to cancel\n   */\n\n\n  clearTimeout(timeout) {\n    clearTimeout(timeout);\n\n    this._timeouts.delete(timeout);\n  }\n  /**\n   * Sets an interval that will be automatically cancelled if the client is destroyed.\n   * @param {Function} fn Function to execute\n   * @param {number} delay Time to wait between executions (in milliseconds)\n   * @param {...*} args Arguments for the function\n   * @returns {Timeout}\n   */\n\n\n  setInterval(fn, delay, ...args) {\n    const interval = setInterval(fn, delay, ...args);\n\n    this._intervals.add(interval);\n\n    return interval;\n  }\n  /**\n   * Clears an interval.\n   * @param {Timeout} interval Interval to cancel\n   */\n\n\n  clearInterval(interval) {\n    clearInterval(interval);\n\n    this._intervals.delete(interval);\n  }\n  /**\n   * Sets an immediate that will be automatically cancelled if the client is destroyed.\n   * @param {Function} fn Function to execute\n   * @param {...*} args Arguments for the function\n   * @returns {Immediate}\n   */\n\n\n  setImmediate(fn, ...args) {\n    const immediate = setImmediate(fn, ...args);\n\n    this._immediates.add(immediate);\n\n    return immediate;\n  }\n  /**\n   * Clears an immediate.\n   * @param {Immediate} immediate Immediate to cancel\n   */\n\n\n  clearImmediate(immediate) {\n    clearImmediate(immediate);\n\n    this._immediates.delete(immediate);\n  }\n  /**\n   * Increments max listeners by one, if they are not zero.\n   * @private\n   */\n\n\n  incrementMaxListeners() {\n    const maxListeners = this.getMaxListeners();\n\n    if (maxListeners !== 0) {\n      this.setMaxListeners(maxListeners + 1);\n    }\n  }\n  /**\n   * Decrements max listeners by one, if they are not zero.\n   * @private\n   */\n\n\n  decrementMaxListeners() {\n    const maxListeners = this.getMaxListeners();\n\n    if (maxListeners !== 0) {\n      this.setMaxListeners(maxListeners - 1);\n    }\n  }\n\n  toJSON(...props) {\n    return Util.flatten(this, {\n      domain: false\n    }, ...props);\n  }\n\n}\n\nmodule.exports = BaseClient;\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/timers-browserify/main.js */ "./node_modules/timers-browserify/main.js").setImmediate, __webpack_require__(/*! ./../../node_modules/timers-browserify/main.js */ "./node_modules/timers-browserify/main.js").clearImmediate))\n\n//# sourceURL=webpack://Fosscord/./src/client/BaseClient.js?')},"./src/client/Client.js":function(module,exports,__webpack_require__){"use strict";eval("/* WEBPACK VAR INJECTION */(function(process) {\n\nconst BaseClient = __webpack_require__(/*! ./BaseClient */ \"./src/client/BaseClient.js\");\n\nconst ActionsManager = __webpack_require__(/*! ./actions/ActionsManager */ \"./src/client/actions/ActionsManager.js\");\n\nconst ClientVoiceManager = __webpack_require__(/*! ./voice/ClientVoiceManager */ 1);\n\nconst WebSocketManager = __webpack_require__(/*! ./websocket/WebSocketManager */ \"./src/client/websocket/WebSocketManager.js\");\n\nconst {\n  Error,\n  TypeError,\n  RangeError\n} = __webpack_require__(/*! ../errors */ \"./src/errors/index.js\");\n\nconst BaseGuildEmojiManager = __webpack_require__(/*! ../managers/BaseGuildEmojiManager */ \"./src/managers/BaseGuildEmojiManager.js\");\n\nconst ChannelManager = __webpack_require__(/*! ../managers/ChannelManager */ \"./src/managers/ChannelManager.js\");\n\nconst GuildManager = __webpack_require__(/*! ../managers/GuildManager */ \"./src/managers/GuildManager.js\");\n\nconst UserManager = __webpack_require__(/*! ../managers/UserManager */ \"./src/managers/UserManager.js\");\n\nconst ShardClientUtil = __webpack_require__(/*! ../sharding/ShardClientUtil */ 5);\n\nconst GuildPreview = __webpack_require__(/*! ../structures/GuildPreview */ \"./src/structures/GuildPreview.js\");\n\nconst GuildTemplate = __webpack_require__(/*! ../structures/GuildTemplate */ \"./src/structures/GuildTemplate.js\");\n\nconst Invite = __webpack_require__(/*! ../structures/Invite */ \"./src/structures/Invite.js\");\n\nconst VoiceRegion = __webpack_require__(/*! ../structures/VoiceRegion */ \"./src/structures/VoiceRegion.js\");\n\nconst Webhook = __webpack_require__(/*! ../structures/Webhook */ \"./src/structures/Webhook.js\");\n\nconst Widget = __webpack_require__(/*! ../structures/Widget */ \"./src/structures/Widget.js\");\n\nconst Collection = __webpack_require__(/*! ../util/Collection */ \"./src/util/Collection.js\");\n\nconst {\n  Events,\n  DefaultOptions,\n  InviteScopes,\n  browser\n} = __webpack_require__(/*! ../util/Constants */ \"./src/util/Constants.js\");\n\nconst DataResolver = __webpack_require__(/*! ../util/DataResolver */ \"./src/util/DataResolver.js\");\n\nconst Intents = __webpack_require__(/*! ../util/Intents */ \"./src/util/Intents.js\");\n\nconst Permissions = __webpack_require__(/*! ../util/Permissions */ \"./src/util/Permissions.js\");\n\nconst Structures = __webpack_require__(/*! ../util/Structures */ \"./src/util/Structures.js\");\n/**\n * The main hub for interacting with the Discord API, and the starting point for any bot.\n * @extends {BaseClient}\n */\n\n\nclass Client extends BaseClient {\n  /**\n   * @param {ClientOptions} options Options for the client\n   */\n  constructor(options) {\n    super(options); // Obtain shard details from environment or if present, worker threads\n\n    let data = process.env;\n\n    try {\n      // Test if worker threads module is present and used\n      data = __webpack_require__(/*! worker_threads */ 6).workerData || data;\n    } catch {// Do nothing\n    }\n\n    if (this.options.shards === DefaultOptions.shards) {\n      if ('SHARDS' in data) {\n        this.options.shards = JSON.parse(data.SHARDS);\n      }\n    }\n\n    if (this.options.shardCount === DefaultOptions.shardCount) {\n      if ('SHARD_COUNT' in data) {\n        this.options.shardCount = Number(data.SHARD_COUNT);\n      } else if (Array.isArray(this.options.shards)) {\n        this.options.shardCount = this.options.shards.length;\n      }\n    }\n\n    const typeofShards = typeof this.options.shards;\n\n    if (typeofShards === 'undefined' && typeof this.options.shardCount === 'number') {\n      this.options.shards = Array.from({\n        length: this.options.shardCount\n      }, (_, i) => i);\n    }\n\n    if (typeofShards === 'number') this.options.shards = [this.options.shards];\n\n    if (Array.isArray(this.options.shards)) {\n      this.options.shards = [...new Set(this.options.shards.filter(item => !isNaN(item) && item >= 0 && item < Infinity && item === (item | 0)))];\n    }\n\n    this._validateOptions();\n    /**\n     * The WebSocket manager of the client\n     * @type {WebSocketManager}\n     */\n\n\n    this.ws = new WebSocketManager(this);\n    /**\n     * The action manager of the client\n     * @type {ActionsManager}\n     * @private\n     */\n\n    this.actions = new ActionsManager(this);\n    /**\n     * The voice manager of the client\n     * @type {ClientVoiceManager}\n     */\n\n    this.voice = new ClientVoiceManager(this);\n    /**\n     * Shard helpers for the client (only if the process was spawned from a {@link ShardingManager})\n     * @type {?ShardClientUtil}\n     */\n\n    this.shard = !browser && process.env.SHARDING_MANAGER ? ShardClientUtil.singleton(this, process.env.SHARDING_MANAGER_MODE) : null;\n    /**\n     * All of the {@link User} objects that have been cached at any point, mapped by their IDs\n     * @type {UserManager}\n     */\n\n    this.users = new UserManager(this);\n    /**\n     * All of the guilds the client is currently handling, mapped by their IDs -\n     * as long as sharding isn't being used, this will be *every* guild the bot is a member of\n     * @type {GuildManager}\n     */\n\n    this.guilds = new GuildManager(this);\n    /**\n     * All of the {@link Channel}s that the client is currently handling, mapped by their IDs -\n     * as long as sharding isn't being used, this will be *every* channel in *every* guild the bot\n     * is a member of. Note that DM channels will not be initially cached, and thus not be present\n     * in the Manager without their explicit fetching or use.\n     * @type {ChannelManager}\n     */\n\n    this.channels = new ChannelManager(this);\n    const ClientPresence = Structures.get('ClientPresence');\n    /**\n     * The presence of the Client\n     * @private\n     * @type {ClientPresence}\n     */\n\n    this.presence = new ClientPresence(this, this.options.presence);\n    Object.defineProperty(this, 'token', {\n      writable: true\n    });\n\n    if (!this.token && 'DISCORD_TOKEN' in process.env) {\n      /**\n       * Authorization token for the logged in bot.\n       * If present, this defaults to `process.env.DISCORD_TOKEN` when instantiating the client\n       * <warn>This should be kept private at all times.</warn>\n       * @type {?string}\n       */\n      this.token = process.env.DISCORD_TOKEN;\n    } else {\n      this.token = null;\n    }\n    /**\n     * User that the client is logged in as\n     * @type {?ClientUser}\n     */\n\n\n    this.user = null;\n    /**\n     * The application of this bot\n     * @type {?ClientApplication}\n     */\n\n    this.application = null;\n    /**\n     * Time at which the client was last regarded as being in the `READY` state\n     * (each time the client disconnects and successfully reconnects, this will be overwritten)\n     * @type {?Date}\n     */\n\n    this.readyAt = null;\n\n    if (this.options.messageSweepInterval > 0) {\n      this.setInterval(this.sweepMessages.bind(this), this.options.messageSweepInterval * 1000);\n    }\n  }\n  /**\n   * All custom emojis that the client has access to, mapped by their IDs\n   * @type {BaseGuildEmojiManager}\n   * @readonly\n   */\n\n\n  get emojis() {\n    const emojis = new BaseGuildEmojiManager(this);\n\n    for (const guild of this.guilds.cache.values()) {\n      if (guild.available) for (const emoji of guild.emojis.cache.values()) emojis.cache.set(emoji.id, emoji);\n    }\n\n    return emojis;\n  }\n  /**\n   * Timestamp of the time the client was last `READY` at\n   * @type {?number}\n   * @readonly\n   */\n\n\n  get readyTimestamp() {\n    return this.readyAt ? this.readyAt.getTime() : null;\n  }\n  /**\n   * How long it has been since the client last entered the `READY` state in milliseconds\n   * @type {?number}\n   * @readonly\n   */\n\n\n  get uptime() {\n    return this.readyAt ? Date.now() - this.readyAt : null;\n  }\n  /**\n   * Logs the client in, establishing a websocket connection to Discord.\n   * @param {string} [token=this.token] Token of the account to log in with\n   * @returns {Promise<string>} Token of the account used\n   * @example\n   * client.login('my token');\n   */\n\n\n  async login(token = this.token) {\n    if (!token || typeof token !== 'string') throw new Error('TOKEN_INVALID');\n    this.token = token;\n    this.emit(Events.DEBUG, `Provided token: ${token.split('.').map((val, i) => i > 1 ? val.replace(/./g, '*') : val).join('.')}`);\n\n    if (this.options.presence) {\n      this.options.ws.presence = await this.presence._parse(this.options.presence);\n    }\n\n    this.emit(Events.DEBUG, 'Preparing to connect to the gateway...');\n\n    try {\n      await this.ws.connect();\n      return this.token;\n    } catch (error) {\n      this.destroy();\n      throw error;\n    }\n  }\n  /**\n   * Logs out, terminates the connection to Discord, and destroys the client.\n   * @returns {void}\n   */\n\n\n  destroy() {\n    super.destroy();\n    this.ws.destroy();\n    this.token = null;\n  }\n  /**\n   * Obtains an invite from Discord.\n   * @param {InviteResolvable} invite Invite code or URL\n   * @returns {Promise<Invite>}\n   * @example\n   * client.fetchInvite('https://discord.gg/djs')\n   *   .then(invite => console.log(`Obtained invite with code: ${invite.code}`))\n   *   .catch(console.error);\n   */\n\n\n  fetchInvite(invite) {\n    const code = DataResolver.resolveInviteCode(invite);\n    return this.api.invites(code).get({\n      query: {\n        with_counts: true,\n        with_expiration: true\n      }\n    }).then(data => new Invite(this, data));\n  }\n  /**\n   * Obtains a template from Discord.\n   * @param {GuildTemplateResolvable} template Template code or URL\n   * @returns {Promise<GuildTemplate>}\n   * @example\n   * client.fetchGuildTemplate('https://discord.new/FKvmczH2HyUf')\n   *   .then(template => console.log(`Obtained template with code: ${template.code}`))\n   *   .catch(console.error);\n   */\n\n\n  fetchGuildTemplate(template) {\n    const code = DataResolver.resolveGuildTemplateCode(template);\n    return this.api.guilds.templates(code).get().then(data => new GuildTemplate(this, data));\n  }\n  /**\n   * Obtains a webhook from Discord.\n   * @param {Snowflake} id ID of the webhook\n   * @param {string} [token] Token for the webhook\n   * @returns {Promise<Webhook>}\n   * @example\n   * client.fetchWebhook('id', 'token')\n   *   .then(webhook => console.log(`Obtained webhook with name: ${webhook.name}`))\n   *   .catch(console.error);\n   */\n\n\n  fetchWebhook(id, token) {\n    return this.api.webhooks(id, token).get().then(data => new Webhook(this, {\n      token,\n      ...data\n    }));\n  }\n  /**\n   * Obtains the available voice regions from Discord.\n   * @returns {Promise<Collection<string, VoiceRegion>>}\n   * @example\n   * client.fetchVoiceRegions()\n   *   .then(regions => console.log(`Available regions are: ${regions.map(region => region.name).join(', ')}`))\n   *   .catch(console.error);\n   */\n\n\n  fetchVoiceRegions() {\n    return this.api.voice.regions.get().then(res => {\n      const regions = new Collection();\n\n      for (const region of res) regions.set(region.id, new VoiceRegion(region));\n\n      return regions;\n    });\n  }\n  /**\n   * Sweeps all text-based channels' messages and removes the ones older than the max message lifetime.\n   * If the message has been edited, the time of the edit is used rather than the time of the original message.\n   * @param {number} [lifetime=this.options.messageCacheLifetime] Messages that are older than this (in seconds)\n   * will be removed from the caches. The default is based on {@link ClientOptions#messageCacheLifetime}\n   * @returns {number} Amount of messages that were removed from the caches,\n   * or -1 if the message cache lifetime is unlimited\n   * @example\n   * // Remove all messages older than 1800 seconds from the messages cache\n   * const amount = client.sweepMessages(1800);\n   * console.log(`Successfully removed ${amount} messages from the cache.`);\n   */\n\n\n  sweepMessages(lifetime = this.options.messageCacheLifetime) {\n    if (typeof lifetime !== 'number' || isNaN(lifetime)) {\n      throw new TypeError('INVALID_TYPE', 'lifetime', 'number');\n    }\n\n    if (lifetime <= 0) {\n      this.emit(Events.DEBUG, \"Didn't sweep messages - lifetime is unlimited\");\n      return -1;\n    }\n\n    const lifetimeMs = lifetime * 1000;\n    const now = Date.now();\n    let channels = 0;\n    let messages = 0;\n\n    for (const channel of this.channels.cache.values()) {\n      if (!channel.messages) continue;\n      channels++;\n      messages += channel.messages.cache.sweep(message => now - (message.editedTimestamp || message.createdTimestamp) > lifetimeMs);\n    }\n\n    this.emit(Events.DEBUG, `Swept ${messages} messages older than ${lifetime} seconds in ${channels} text-based channels`);\n    return messages;\n  }\n  /**\n   * Obtains a guild preview from Discord, available for all guilds the bot is in and all Discoverable guilds.\n   * @param {GuildResolvable} guild The guild to fetch the preview for\n   * @returns {Promise<GuildPreview>}\n   */\n\n\n  fetchGuildPreview(guild) {\n    const id = this.guilds.resolveID(guild);\n    if (!id) throw new TypeError('INVALID_TYPE', 'guild', 'GuildResolvable');\n    return this.api.guilds(id).preview.get().then(data => new GuildPreview(this, data));\n  }\n  /**\n   * Obtains the widget of a guild from Discord, available for guilds with the widget enabled.\n   * @param {GuildResolvable} guild The guild to fetch the widget for\n   * @returns {Promise<Widget>}\n   */\n\n\n  async fetchWidget(guild) {\n    const id = this.guilds.resolveID(guild);\n    if (!id) throw new TypeError('INVALID_TYPE', 'guild', 'GuildResolvable');\n    const data = await this.api.guilds(id, 'widget.json').get();\n    return new Widget(this, data);\n  }\n  /**\n   * Options for {@link Client#generateInvite}.\n   * @typedef {Object} InviteGenerationOptions\n   * @property {PermissionResolvable} [permissions] Permissions to request\n   * @property {GuildResolvable} [guild] Guild to preselect\n   * @property {boolean} [disableGuildSelect] Whether to disable the guild selection\n   * @property {InviteScope[]} [additionalScopes] Whether any additional scopes should be requested\n   */\n\n  /**\n   * Generates a link that can be used to invite the bot to a guild.\n   * @param {InviteGenerationOptions} [options={}] Options for the invite\n   * @returns {string}\n   * @example\n   * const link = client.generateInvite({\n   *   permissions: [\n   *     Permissions.FLAGS.SEND_MESSAGES,\n   *     Permissions.FLAGS.MANAGE_GUILD,\n   *     Permissions.FLAGS.MENTION_EVERYONE,\n   *   ],\n   * });\n   * console.log(`Generated bot invite link: ${link}`);\n   */\n\n\n  generateInvite(options = {}) {\n    if (typeof options !== 'object') throw new TypeError('INVALID_TYPE', 'options', 'object', true);\n    if (!this.application) throw new Error('CLIENT_NOT_READY', 'generate an invite link');\n    const query = new URLSearchParams({\n      client_id: this.application.id,\n      scope: 'bot'\n    });\n\n    if (options.permissions) {\n      const permissions = Permissions.resolve(options.permissions);\n      if (permissions) query.set('permissions', permissions);\n    }\n\n    if (options.disableGuildSelect) {\n      query.set('disable_guild_select', true);\n    }\n\n    if (options.guild) {\n      const guildID = this.guilds.resolveID(options.guild);\n      if (!guildID) throw new TypeError('INVALID_TYPE', 'options.guild', 'GuildResolvable');\n      query.set('guild_id', guildID);\n    }\n\n    if (options.additionalScopes) {\n      const scopes = options.additionalScopes;\n\n      if (!Array.isArray(scopes)) {\n        throw new TypeError('INVALID_TYPE', 'additionalScopes', 'Array of Invite Scopes', true);\n      }\n\n      const invalidScope = scopes.find(scope => !InviteScopes.includes(scope));\n\n      if (invalidScope) {\n        throw new TypeError('INVALID_ELEMENT', 'Array', 'additionalScopes', invalidScope);\n      }\n\n      query.set('scope', ['bot', ...scopes].join(' '));\n    }\n\n    return `${this.options.http.api}${this.api.oauth2.authorize}?${query}`;\n  }\n\n  toJSON() {\n    return super.toJSON({\n      readyAt: false\n    });\n  }\n  /**\n   * Calls {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval} on a script\n   * with the client as `this`.\n   * @param {string} script Script to eval\n   * @returns {*}\n   * @private\n   */\n\n\n  _eval(script) {\n    return eval(script);\n  }\n  /**\n   * Validates the client options.\n   * @param {ClientOptions} [options=this.options] Options to validate\n   * @private\n   */\n\n\n  _validateOptions(options = this.options) {\n    if (typeof options.intents === 'undefined') {\n      throw new TypeError('CLIENT_MISSING_INTENTS');\n    } else {\n      options.intents = Intents.resolve(options.intents);\n    }\n\n    if (typeof options.shardCount !== 'number' || isNaN(options.shardCount) || options.shardCount < 1) {\n      throw new TypeError('CLIENT_INVALID_OPTION', 'shardCount', 'a number greater than or equal to 1');\n    }\n\n    if (options.shards && !(options.shards === 'auto' || Array.isArray(options.shards))) {\n      throw new TypeError('CLIENT_INVALID_OPTION', 'shards', \"'auto', a number or array of numbers\");\n    }\n\n    if (options.shards && !options.shards.length) throw new RangeError('CLIENT_INVALID_PROVIDED_SHARDS');\n\n    if (typeof options.messageCacheMaxSize !== 'number' || isNaN(options.messageCacheMaxSize)) {\n      throw new TypeError('CLIENT_INVALID_OPTION', 'messageCacheMaxSize', 'a number');\n    }\n\n    if (typeof options.messageCacheLifetime !== 'number' || isNaN(options.messageCacheLifetime)) {\n      throw new TypeError('CLIENT_INVALID_OPTION', 'The messageCacheLifetime', 'a number');\n    }\n\n    if (typeof options.messageSweepInterval !== 'number' || isNaN(options.messageSweepInterval)) {\n      throw new TypeError('CLIENT_INVALID_OPTION', 'messageSweepInterval', 'a number');\n    }\n\n    if (typeof options.invalidRequestWarningInterval !== 'number' || isNaN(options.invalidRequestWarningInterval)) {\n      throw new TypeError('CLIENT_INVALID_OPTION', 'invalidRequestWarningInterval', 'a number');\n    }\n\n    if (!Array.isArray(options.partials)) {\n      throw new TypeError('CLIENT_INVALID_OPTION', 'partials', 'an Array');\n    }\n\n    if (typeof options.restWsBridgeTimeout !== 'number' || isNaN(options.restWsBridgeTimeout)) {\n      throw new TypeError('CLIENT_INVALID_OPTION', 'restWsBridgeTimeout', 'a number');\n    }\n\n    if (typeof options.restRequestTimeout !== 'number' || isNaN(options.restRequestTimeout)) {\n      throw new TypeError('CLIENT_INVALID_OPTION', 'restRequestTimeout', 'a number');\n    }\n\n    if (typeof options.restGlobalRateLimit !== 'number' || isNaN(options.restGlobalRateLimit)) {\n      throw new TypeError('CLIENT_INVALID_OPTION', 'restGlobalRateLimit', 'a number');\n    }\n\n    if (typeof options.restSweepInterval !== 'number' || isNaN(options.restSweepInterval)) {\n      throw new TypeError('CLIENT_INVALID_OPTION', 'restSweepInterval', 'a number');\n    }\n\n    if (typeof options.retryLimit !== 'number' || isNaN(options.retryLimit)) {\n      throw new TypeError('CLIENT_INVALID_OPTION', 'retryLimit', 'a number');\n    }\n\n    if (typeof options.rejectOnRateLimit !== 'undefined' && !(typeof options.rejectOnRateLimit === 'function' || Array.isArray(options.rejectOnRateLimit))) {\n      throw new TypeError('CLIENT_INVALID_OPTION', 'rejectOnRateLimit', 'an array or a function');\n    }\n  }\n\n}\n\nmodule.exports = Client;\n/**\n * Emitted for general warnings.\n * @event Client#warn\n * @param {string} info The warning\n */\n\n/**\n * Emitted for general debugging information.\n * @event Client#debug\n * @param {string} info The debug information\n */\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack://Fosscord/./src/client/Client.js?")},"./src/client/WebhookClient.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nconst BaseClient = __webpack_require__(/*! ./BaseClient */ \"./src/client/BaseClient.js\");\n\nconst Webhook = __webpack_require__(/*! ../structures/Webhook */ \"./src/structures/Webhook.js\");\n/**\n * The webhook client.\n * @implements {Webhook}\n * @extends {BaseClient}\n */\n\n\nclass WebhookClient extends BaseClient {\n  /**\n   * @param {Snowflake} id ID of the webhook\n   * @param {string} token Token of the webhook\n   * @param {ClientOptions} [options] Options for the client\n   * @example\n   * // Create a new webhook and send a message\n   * const hook = new Discord.WebhookClient('1234', 'abcdef');\n   * hook.send('This will send a message').catch(console.error);\n   */\n  constructor(id, token, options) {\n    super(options);\n    Object.defineProperty(this, 'client', {\n      value: this\n    });\n    this.id = id;\n    Object.defineProperty(this, 'token', {\n      value: token,\n      writable: true,\n      configurable: true\n    });\n  } // These are here only for documentation purposes - they are implemented by Webhook\n\n  /* eslint-disable no-empty-function */\n\n\n  send() {}\n\n  sendSlackMessage() {}\n\n  fetchMessage() {}\n\n  edit() {}\n\n  editMessage() {}\n\n  delete() {}\n\n  deleteMessage() {}\n\n  get createdTimestamp() {}\n\n  get createdAt() {}\n\n  get url() {}\n\n}\n\nWebhook.applyToClass(WebhookClient);\nmodule.exports = WebhookClient;\n\n//# sourceURL=webpack://Fosscord/./src/client/WebhookClient.js?")},"./src/client/actions/Action.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nconst {\n  PartialTypes\n} = __webpack_require__(/*! ../../util/Constants */ "./src/util/Constants.js");\n/*\n\nABOUT ACTIONS\n\nActions are similar to WebSocket Packet Handlers, but since introducing\nthe REST API methods, in order to prevent rewriting code to handle data,\n"actions" have been introduced. They\'re basically what Packet Handlers\nused to be but they\'re strictly for manipulating data and making sure\nthat WebSocket events don\'t clash with REST methods.\n\n*/\n\n\nclass GenericAction {\n  constructor(client) {\n    this.client = client;\n  }\n\n  handle(data) {\n    return data;\n  }\n\n  getPayload(data, manager, id, partialType, cache) {\n    const existing = manager.cache.get(id);\n\n    if (!existing && this.client.options.partials.includes(partialType)) {\n      return manager.add(data, cache);\n    }\n\n    return existing;\n  }\n\n  getChannel(data) {\n    const id = data.channel_id || data.id;\n    return data.channel || this.getPayload({\n      id,\n      guild_id: data.guild_id,\n      recipients: [data.author || {\n        id: data.user_id\n      }]\n    }, this.client.channels, id, PartialTypes.CHANNEL);\n  }\n\n  getMessage(data, channel, cache) {\n    const id = data.message_id || data.id;\n    return data.message || this.getPayload({\n      id,\n      channel_id: channel.id,\n      guild_id: data.guild_id || (channel.guild ? channel.guild.id : null)\n    }, channel.messages, id, PartialTypes.MESSAGE, cache);\n  }\n\n  getReaction(data, message, user) {\n    const id = data.emoji.id || decodeURIComponent(data.emoji.name);\n    return this.getPayload({\n      emoji: data.emoji,\n      count: message.partial ? null : 0,\n      me: user ? user.id === this.client.user.id : false\n    }, message.reactions, id, PartialTypes.REACTION);\n  }\n\n  getMember(data, guild) {\n    return this.getPayload(data, guild.members, data.user.id, PartialTypes.GUILD_MEMBER);\n  }\n\n  getUser(data) {\n    const id = data.user_id;\n    return data.user || this.getPayload({\n      id\n    }, this.client.users, id, PartialTypes.USER);\n  }\n\n  getUserFromMember(data) {\n    if (data.guild_id && data.member && data.member.user) {\n      const guild = this.client.guilds.cache.get(data.guild_id);\n\n      if (guild) {\n        return guild.members.add(data.member).user;\n      } else {\n        return this.client.users.add(data.member.user);\n      }\n    }\n\n    return this.getUser(data);\n  }\n\n}\n\nmodule.exports = GenericAction;\n\n//# sourceURL=webpack://Fosscord/./src/client/actions/Action.js?')},"./src/client/actions/ActionsManager.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nclass ActionsManager {\n  constructor(client) {\n    this.client = client;\n    this.register(__webpack_require__(/*! ./MessageCreate */ "./src/client/actions/MessageCreate.js"));\n    this.register(__webpack_require__(/*! ./MessageDelete */ "./src/client/actions/MessageDelete.js"));\n    this.register(__webpack_require__(/*! ./MessageDeleteBulk */ "./src/client/actions/MessageDeleteBulk.js"));\n    this.register(__webpack_require__(/*! ./MessageUpdate */ "./src/client/actions/MessageUpdate.js"));\n    this.register(__webpack_require__(/*! ./MessageReactionAdd */ "./src/client/actions/MessageReactionAdd.js"));\n    this.register(__webpack_require__(/*! ./MessageReactionRemove */ "./src/client/actions/MessageReactionRemove.js"));\n    this.register(__webpack_require__(/*! ./MessageReactionRemoveAll */ "./src/client/actions/MessageReactionRemoveAll.js"));\n    this.register(__webpack_require__(/*! ./MessageReactionRemoveEmoji */ "./src/client/actions/MessageReactionRemoveEmoji.js"));\n    this.register(__webpack_require__(/*! ./ChannelCreate */ "./src/client/actions/ChannelCreate.js"));\n    this.register(__webpack_require__(/*! ./ChannelDelete */ "./src/client/actions/ChannelDelete.js"));\n    this.register(__webpack_require__(/*! ./ChannelUpdate */ "./src/client/actions/ChannelUpdate.js"));\n    this.register(__webpack_require__(/*! ./GuildDelete */ "./src/client/actions/GuildDelete.js"));\n    this.register(__webpack_require__(/*! ./GuildUpdate */ "./src/client/actions/GuildUpdate.js"));\n    this.register(__webpack_require__(/*! ./InteractionCreate */ "./src/client/actions/InteractionCreate.js"));\n    this.register(__webpack_require__(/*! ./InviteCreate */ "./src/client/actions/InviteCreate.js"));\n    this.register(__webpack_require__(/*! ./InviteDelete */ "./src/client/actions/InviteDelete.js"));\n    this.register(__webpack_require__(/*! ./GuildMemberRemove */ "./src/client/actions/GuildMemberRemove.js"));\n    this.register(__webpack_require__(/*! ./GuildMemberUpdate */ "./src/client/actions/GuildMemberUpdate.js"));\n    this.register(__webpack_require__(/*! ./GuildBanAdd */ "./src/client/actions/GuildBanAdd.js"));\n    this.register(__webpack_require__(/*! ./GuildBanRemove */ "./src/client/actions/GuildBanRemove.js"));\n    this.register(__webpack_require__(/*! ./GuildRoleCreate */ "./src/client/actions/GuildRoleCreate.js"));\n    this.register(__webpack_require__(/*! ./GuildRoleDelete */ "./src/client/actions/GuildRoleDelete.js"));\n    this.register(__webpack_require__(/*! ./GuildRoleUpdate */ "./src/client/actions/GuildRoleUpdate.js"));\n    this.register(__webpack_require__(/*! ./PresenceUpdate */ "./src/client/actions/PresenceUpdate.js"));\n    this.register(__webpack_require__(/*! ./UserUpdate */ "./src/client/actions/UserUpdate.js"));\n    this.register(__webpack_require__(/*! ./VoiceStateUpdate */ "./src/client/actions/VoiceStateUpdate.js"));\n    this.register(__webpack_require__(/*! ./GuildEmojiCreate */ "./src/client/actions/GuildEmojiCreate.js"));\n    this.register(__webpack_require__(/*! ./GuildEmojiDelete */ "./src/client/actions/GuildEmojiDelete.js"));\n    this.register(__webpack_require__(/*! ./GuildEmojiUpdate */ "./src/client/actions/GuildEmojiUpdate.js"));\n    this.register(__webpack_require__(/*! ./GuildEmojisUpdate */ "./src/client/actions/GuildEmojisUpdate.js"));\n    this.register(__webpack_require__(/*! ./ThreadCreate */ "./src/client/actions/ThreadCreate.js"));\n    this.register(__webpack_require__(/*! ./ThreadDelete */ "./src/client/actions/ThreadDelete.js"));\n    this.register(__webpack_require__(/*! ./ThreadListSync */ "./src/client/actions/ThreadListSync.js"));\n    this.register(__webpack_require__(/*! ./ThreadMemberUpdate */ "./src/client/actions/ThreadMemberUpdate.js"));\n    this.register(__webpack_require__(/*! ./ThreadMembersUpdate */ "./src/client/actions/ThreadMembersUpdate.js"));\n    this.register(__webpack_require__(/*! ./GuildRolesPositionUpdate */ "./src/client/actions/GuildRolesPositionUpdate.js"));\n    this.register(__webpack_require__(/*! ./GuildChannelsPositionUpdate */ "./src/client/actions/GuildChannelsPositionUpdate.js"));\n    this.register(__webpack_require__(/*! ./GuildIntegrationsUpdate */ "./src/client/actions/GuildIntegrationsUpdate.js"));\n    this.register(__webpack_require__(/*! ./WebhooksUpdate */ "./src/client/actions/WebhooksUpdate.js"));\n    this.register(__webpack_require__(/*! ./TypingStart */ "./src/client/actions/TypingStart.js"));\n    this.register(__webpack_require__(/*! ./StageInstanceCreate */ "./src/client/actions/StageInstanceCreate.js"));\n    this.register(__webpack_require__(/*! ./StageInstanceUpdate */ "./src/client/actions/StageInstanceUpdate.js"));\n    this.register(__webpack_require__(/*! ./StageInstanceDelete */ "./src/client/actions/StageInstanceDelete.js"));\n  }\n\n  register(Action) {\n    this[Action.name.replace(/Action$/, \'\')] = new Action(this.client);\n  }\n\n}\n\nmodule.exports = ActionsManager;\n\n//# sourceURL=webpack://Fosscord/./src/client/actions/ActionsManager.js?')},"./src/client/actions/ChannelCreate.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nconst Action = __webpack_require__(/*! ./Action */ "./src/client/actions/Action.js");\n\nconst {\n  Events\n} = __webpack_require__(/*! ../../util/Constants */ "./src/util/Constants.js");\n\nclass ChannelCreateAction extends Action {\n  handle(data) {\n    const client = this.client;\n    const existing = client.channels.cache.has(data.id);\n    const channel = client.channels.add(data);\n\n    if (!existing && channel) {\n      /**\n       * Emitted whenever a guild channel is created.\n       * @event Client#channelCreate\n       * @param {GuildChannel} channel The channel that was created\n       */\n      client.emit(Events.CHANNEL_CREATE, channel);\n    }\n\n    return {\n      channel\n    };\n  }\n\n}\n\nmodule.exports = ChannelCreateAction;\n\n//# sourceURL=webpack://Fosscord/./src/client/actions/ChannelCreate.js?')},"./src/client/actions/ChannelDelete.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nconst Action = __webpack_require__(/*! ./Action */ "./src/client/actions/Action.js");\n\nconst DMChannel = __webpack_require__(/*! ../../structures/DMChannel */ "./src/structures/DMChannel.js");\n\nconst {\n  Events\n} = __webpack_require__(/*! ../../util/Constants */ "./src/util/Constants.js");\n\nclass ChannelDeleteAction extends Action {\n  constructor(client) {\n    super(client);\n    this.deleted = new Map();\n  }\n\n  handle(data) {\n    const client = this.client;\n    let channel = client.channels.cache.get(data.id);\n\n    if (channel) {\n      client.channels.remove(channel.id);\n      channel.deleted = true;\n\n      if (channel.messages && !(channel instanceof DMChannel)) {\n        for (const message of channel.messages.cache.values()) {\n          message.deleted = true;\n        }\n      }\n      /**\n       * Emitted whenever a channel is deleted.\n       * @event Client#channelDelete\n       * @param {DMChannel|GuildChannel} channel The channel that was deleted\n       */\n\n\n      client.emit(Events.CHANNEL_DELETE, channel);\n    }\n\n    return {\n      channel\n    };\n  }\n\n}\n\nmodule.exports = ChannelDeleteAction;\n\n//# sourceURL=webpack://Fosscord/./src/client/actions/ChannelDelete.js?')},"./src/client/actions/ChannelUpdate.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nconst Action = __webpack_require__(/*! ./Action */ "./src/client/actions/Action.js");\n\nconst Channel = __webpack_require__(/*! ../../structures/Channel */ "./src/structures/Channel.js");\n\nconst {\n  ChannelTypes\n} = __webpack_require__(/*! ../../util/Constants */ "./src/util/Constants.js");\n\nclass ChannelUpdateAction extends Action {\n  handle(data) {\n    const client = this.client;\n    let channel = client.channels.cache.get(data.id);\n\n    if (channel) {\n      const old = channel._update(data);\n\n      if (ChannelTypes[channel.type.toUpperCase()] !== data.type) {\n        const newChannel = Channel.create(this.client, data, channel.guild);\n\n        for (const [id, message] of channel.messages.cache) newChannel.messages.cache.set(id, message);\n\n        newChannel._typing = new Map(channel._typing);\n        channel = newChannel;\n        this.client.channels.cache.set(channel.id, channel);\n      }\n\n      return {\n        old,\n        updated: channel\n      };\n    }\n\n    return {};\n  }\n\n}\n\nmodule.exports = ChannelUpdateAction;\n\n//# sourceURL=webpack://Fosscord/./src/client/actions/ChannelUpdate.js?')},"./src/client/actions/GuildBanAdd.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nconst Action = __webpack_require__(/*! ./Action */ "./src/client/actions/Action.js");\n\nconst {\n  Events\n} = __webpack_require__(/*! ../../util/Constants */ "./src/util/Constants.js");\n\nclass GuildBanAdd extends Action {\n  handle(data) {\n    const client = this.client;\n    const guild = client.guilds.cache.get(data.guild_id);\n    /**\n     * Emitted whenever a member is banned from a guild.\n     * @event Client#guildBanAdd\n     * @param {GuildBan} ban The ban that occurred\n     */\n\n    if (guild) client.emit(Events.GUILD_BAN_ADD, guild.bans.add(data));\n  }\n\n}\n\nmodule.exports = GuildBanAdd;\n\n//# sourceURL=webpack://Fosscord/./src/client/actions/GuildBanAdd.js?')},"./src/client/actions/GuildBanRemove.js":function(module,exports){eval('throw new Error("Module parse failed: Unexpected token (22:54)\\nFile was processed with these loaders:\\n * ./node_modules/babel-loader/lib/index.js\\nYou may need an additional loader to handle the result of these loaders.\\n| \\n|     if (guild) {\\n>       const ban = guild.bans.cache.get(data.user.id) ?? new GuildBan(client, data, guild);\\n|       guild.bans.cache.delete(ban.user.id);\\n|       client.emit(Events.GUILD_BAN_REMOVE, ban);");\n\n//# sourceURL=webpack://Fosscord/./src/client/actions/GuildBanRemove.js?')},"./src/client/actions/GuildChannelsPositionUpdate.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nconst Action = __webpack_require__(/*! ./Action */ "./src/client/actions/Action.js");\n\nclass GuildChannelsPositionUpdate extends Action {\n  handle(data) {\n    const client = this.client;\n    const guild = client.guilds.cache.get(data.guild_id);\n\n    if (guild) {\n      for (const partialChannel of data.channels) {\n        const channel = guild.channels.cache.get(partialChannel.id);\n        if (channel) channel.rawPosition = partialChannel.position;\n      }\n    }\n\n    return {\n      guild\n    };\n  }\n\n}\n\nmodule.exports = GuildChannelsPositionUpdate;\n\n//# sourceURL=webpack://Fosscord/./src/client/actions/GuildChannelsPositionUpdate.js?')},"./src/client/actions/GuildDelete.js":function(module,exports){eval('throw new Error("Module parse failed: Unexpected token (43:41)\\nFile was processed with these loaders:\\n * ./node_modules/babel-loader/lib/index.js\\nYou may need an additional loader to handle the result of these loaders.\\n|       for (const channel of guild.channels.cache.values()) this.client.channels.remove(channel.id);\\n| \\n>       client.voice.adapters.get(data.id)?.destroy(); // Delete guild\\n| \\n|       client.guilds.cache.delete(guild.id);");\n\n//# sourceURL=webpack://Fosscord/./src/client/actions/GuildDelete.js?')},"./src/client/actions/GuildEmojiCreate.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nconst Action = __webpack_require__(/*! ./Action */ "./src/client/actions/Action.js");\n\nconst {\n  Events\n} = __webpack_require__(/*! ../../util/Constants */ "./src/util/Constants.js");\n\nclass GuildEmojiCreateAction extends Action {\n  handle(guild, createdEmoji) {\n    const already = guild.emojis.cache.has(createdEmoji.id);\n    const emoji = guild.emojis.add(createdEmoji);\n    /**\n     * Emitted whenever a custom emoji is created in a guild.\n     * @event Client#emojiCreate\n     * @param {GuildEmoji} emoji The emoji that was created\n     */\n\n    if (!already) this.client.emit(Events.GUILD_EMOJI_CREATE, emoji);\n    return {\n      emoji\n    };\n  }\n\n}\n\nmodule.exports = GuildEmojiCreateAction;\n\n//# sourceURL=webpack://Fosscord/./src/client/actions/GuildEmojiCreate.js?')},"./src/client/actions/GuildEmojiDelete.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nconst Action = __webpack_require__(/*! ./Action */ "./src/client/actions/Action.js");\n\nconst {\n  Events\n} = __webpack_require__(/*! ../../util/Constants */ "./src/util/Constants.js");\n\nclass GuildEmojiDeleteAction extends Action {\n  handle(emoji) {\n    emoji.guild.emojis.cache.delete(emoji.id);\n    emoji.deleted = true;\n    /**\n     * Emitted whenever a custom emoji is deleted in a guild.\n     * @event Client#emojiDelete\n     * @param {GuildEmoji} emoji The emoji that was deleted\n     */\n\n    this.client.emit(Events.GUILD_EMOJI_DELETE, emoji);\n    return {\n      emoji\n    };\n  }\n\n}\n\nmodule.exports = GuildEmojiDeleteAction;\n\n//# sourceURL=webpack://Fosscord/./src/client/actions/GuildEmojiDelete.js?')},"./src/client/actions/GuildEmojiUpdate.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nconst Action = __webpack_require__(/*! ./Action */ "./src/client/actions/Action.js");\n\nconst {\n  Events\n} = __webpack_require__(/*! ../../util/Constants */ "./src/util/Constants.js");\n\nclass GuildEmojiUpdateAction extends Action {\n  handle(current, data) {\n    const old = current._update(data);\n    /**\n     * Emitted whenever a custom emoji is updated in a guild.\n     * @event Client#emojiUpdate\n     * @param {GuildEmoji} oldEmoji The old emoji\n     * @param {GuildEmoji} newEmoji The new emoji\n     */\n\n\n    this.client.emit(Events.GUILD_EMOJI_UPDATE, old, current);\n    return {\n      emoji: current\n    };\n  }\n\n}\n\nmodule.exports = GuildEmojiUpdateAction;\n\n//# sourceURL=webpack://Fosscord/./src/client/actions/GuildEmojiUpdate.js?')},"./src/client/actions/GuildEmojisUpdate.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nconst Action = __webpack_require__(/*! ./Action */ "./src/client/actions/Action.js");\n\nclass GuildEmojisUpdateAction extends Action {\n  handle(data) {\n    const guild = this.client.guilds.cache.get(data.guild_id);\n    if (!guild || !guild.emojis) return;\n    const deletions = new Map(guild.emojis.cache);\n\n    for (const emoji of data.emojis) {\n      // Determine type of emoji event\n      const cachedEmoji = guild.emojis.cache.get(emoji.id);\n\n      if (cachedEmoji) {\n        deletions.delete(emoji.id);\n\n        if (!cachedEmoji.equals(emoji)) {\n          // Emoji updated\n          this.client.actions.GuildEmojiUpdate.handle(cachedEmoji, emoji);\n        }\n      } else {\n        // Emoji added\n        this.client.actions.GuildEmojiCreate.handle(guild, emoji);\n      }\n    }\n\n    for (const emoji of deletions.values()) {\n      // Emoji deleted\n      this.client.actions.GuildEmojiDelete.handle(emoji);\n    }\n  }\n\n}\n\nmodule.exports = GuildEmojisUpdateAction;\n\n//# sourceURL=webpack://Fosscord/./src/client/actions/GuildEmojisUpdate.js?')},"./src/client/actions/GuildIntegrationsUpdate.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nconst Action = __webpack_require__(/*! ./Action */ "./src/client/actions/Action.js");\n\nconst {\n  Events\n} = __webpack_require__(/*! ../../util/Constants */ "./src/util/Constants.js");\n\nclass GuildIntegrationsUpdate extends Action {\n  handle(data) {\n    const client = this.client;\n    const guild = client.guilds.cache.get(data.guild_id);\n    /**\n     * Emitted whenever a guild integration is updated\n     * @event Client#guildIntegrationsUpdate\n     * @param {Guild} guild The guild whose integrations were updated\n     */\n\n    if (guild) client.emit(Events.GUILD_INTEGRATIONS_UPDATE, guild);\n  }\n\n}\n\nmodule.exports = GuildIntegrationsUpdate;\n\n//# sourceURL=webpack://Fosscord/./src/client/actions/GuildIntegrationsUpdate.js?')},"./src/client/actions/GuildMemberRemove.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nconst Action = __webpack_require__(/*! ./Action */ "./src/client/actions/Action.js");\n\nconst {\n  Events,\n  Status\n} = __webpack_require__(/*! ../../util/Constants */ "./src/util/Constants.js");\n\nclass GuildMemberRemoveAction extends Action {\n  handle(data, shard) {\n    const client = this.client;\n    const guild = client.guilds.cache.get(data.guild_id);\n    let member = null;\n\n    if (guild) {\n      member = this.getMember({\n        user: data.user\n      }, guild);\n      guild.memberCount--;\n\n      if (member) {\n        member.deleted = true;\n        guild.members.cache.delete(member.id);\n        /**\n         * Emitted whenever a member leaves a guild, or is kicked.\n         * @event Client#guildMemberRemove\n         * @param {GuildMember} member The member that has left/been kicked from the guild\n         */\n\n        if (shard.status === Status.READY) client.emit(Events.GUILD_MEMBER_REMOVE, member);\n      }\n\n      guild.voiceStates.cache.delete(data.user.id);\n    }\n\n    return {\n      guild,\n      member\n    };\n  }\n\n}\n\nmodule.exports = GuildMemberRemoveAction;\n\n//# sourceURL=webpack://Fosscord/./src/client/actions/GuildMemberRemove.js?')},"./src/client/actions/GuildMemberUpdate.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nconst Action = __webpack_require__(/*! ./Action */ "./src/client/actions/Action.js");\n\nconst {\n  Status,\n  Events\n} = __webpack_require__(/*! ../../util/Constants */ "./src/util/Constants.js");\n\nclass GuildMemberUpdateAction extends Action {\n  handle(data, shard) {\n    const {\n      client\n    } = this;\n\n    if (data.user.username) {\n      const user = client.users.cache.get(data.user.id);\n\n      if (!user) {\n        client.users.add(data.user);\n      } else if (!user.equals(data.user)) {\n        client.actions.UserUpdate.handle(data.user);\n      }\n    }\n\n    const guild = client.guilds.cache.get(data.guild_id);\n\n    if (guild) {\n      const member = this.getMember({\n        user: data.user\n      }, guild);\n\n      if (member) {\n        const old = member._update(data);\n        /**\n         * Emitted whenever a guild member changes - i.e. new role, removed role, nickname.\n         * Also emitted when the user\'s details (e.g. username) change.\n         * @event Client#guildMemberUpdate\n         * @param {GuildMember} oldMember The member before the update\n         * @param {GuildMember} newMember The member after the update\n         */\n\n\n        if (shard.status === Status.READY && !member.equals(old)) client.emit(Events.GUILD_MEMBER_UPDATE, old, member);\n      } else {\n        const newMember = guild.members.add(data);\n        /**\n         * Emitted whenever a member becomes available in a large guild.\n         * @event Client#guildMemberAvailable\n         * @param {GuildMember} member The member that became available\n         */\n\n        this.client.emit(Events.GUILD_MEMBER_AVAILABLE, newMember);\n      }\n    }\n  }\n\n}\n\nmodule.exports = GuildMemberUpdateAction;\n\n//# sourceURL=webpack://Fosscord/./src/client/actions/GuildMemberUpdate.js?')},"./src/client/actions/GuildRoleCreate.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nconst Action = __webpack_require__(/*! ./Action */ "./src/client/actions/Action.js");\n\nconst {\n  Events\n} = __webpack_require__(/*! ../../util/Constants */ "./src/util/Constants.js");\n\nclass GuildRoleCreate extends Action {\n  handle(data) {\n    const client = this.client;\n    const guild = client.guilds.cache.get(data.guild_id);\n    let role;\n\n    if (guild) {\n      const already = guild.roles.cache.has(data.role.id);\n      role = guild.roles.add(data.role);\n      /**\n       * Emitted whenever a role is created.\n       * @event Client#roleCreate\n       * @param {Role} role The role that was created\n       */\n\n      if (!already) client.emit(Events.GUILD_ROLE_CREATE, role);\n    }\n\n    return {\n      role\n    };\n  }\n\n}\n\nmodule.exports = GuildRoleCreate;\n\n//# sourceURL=webpack://Fosscord/./src/client/actions/GuildRoleCreate.js?')},"./src/client/actions/GuildRoleDelete.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nconst Action = __webpack_require__(/*! ./Action */ "./src/client/actions/Action.js");\n\nconst {\n  Events\n} = __webpack_require__(/*! ../../util/Constants */ "./src/util/Constants.js");\n\nclass GuildRoleDeleteAction extends Action {\n  handle(data) {\n    const client = this.client;\n    const guild = client.guilds.cache.get(data.guild_id);\n    let role;\n\n    if (guild) {\n      role = guild.roles.cache.get(data.role_id);\n\n      if (role) {\n        guild.roles.cache.delete(data.role_id);\n        role.deleted = true;\n        /**\n         * Emitted whenever a guild role is deleted.\n         * @event Client#roleDelete\n         * @param {Role} role The role that was deleted\n         */\n\n        client.emit(Events.GUILD_ROLE_DELETE, role);\n      }\n    }\n\n    return {\n      role\n    };\n  }\n\n}\n\nmodule.exports = GuildRoleDeleteAction;\n\n//# sourceURL=webpack://Fosscord/./src/client/actions/GuildRoleDelete.js?')},"./src/client/actions/GuildRoleUpdate.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nconst Action = __webpack_require__(/*! ./Action */ "./src/client/actions/Action.js");\n\nconst {\n  Events\n} = __webpack_require__(/*! ../../util/Constants */ "./src/util/Constants.js");\n\nclass GuildRoleUpdateAction extends Action {\n  handle(data) {\n    const client = this.client;\n    const guild = client.guilds.cache.get(data.guild_id);\n\n    if (guild) {\n      let old = null;\n      const role = guild.roles.cache.get(data.role.id);\n\n      if (role) {\n        old = role._update(data.role);\n        /**\n         * Emitted whenever a guild role is updated.\n         * @event Client#roleUpdate\n         * @param {Role} oldRole The role before the update\n         * @param {Role} newRole The role after the update\n         */\n\n        client.emit(Events.GUILD_ROLE_UPDATE, old, role);\n      }\n\n      return {\n        old,\n        updated: role\n      };\n    }\n\n    return {\n      old: null,\n      updated: null\n    };\n  }\n\n}\n\nmodule.exports = GuildRoleUpdateAction;\n\n//# sourceURL=webpack://Fosscord/./src/client/actions/GuildRoleUpdate.js?')},"./src/client/actions/GuildRolesPositionUpdate.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nconst Action = __webpack_require__(/*! ./Action */ "./src/client/actions/Action.js");\n\nclass GuildRolesPositionUpdate extends Action {\n  handle(data) {\n    const client = this.client;\n    const guild = client.guilds.cache.get(data.guild_id);\n\n    if (guild) {\n      for (const partialRole of data.roles) {\n        const role = guild.roles.cache.get(partialRole.id);\n        if (role) role.rawPosition = partialRole.position;\n      }\n    }\n\n    return {\n      guild\n    };\n  }\n\n}\n\nmodule.exports = GuildRolesPositionUpdate;\n\n//# sourceURL=webpack://Fosscord/./src/client/actions/GuildRolesPositionUpdate.js?')},"./src/client/actions/GuildUpdate.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nconst Action = __webpack_require__(/*! ./Action */ "./src/client/actions/Action.js");\n\nconst {\n  Events\n} = __webpack_require__(/*! ../../util/Constants */ "./src/util/Constants.js");\n\nclass GuildUpdateAction extends Action {\n  handle(data) {\n    const client = this.client;\n    const guild = client.guilds.cache.get(data.id);\n\n    if (guild) {\n      const old = guild._update(data);\n      /**\n       * Emitted whenever a guild is updated - e.g. name change.\n       * @event Client#guildUpdate\n       * @param {Guild} oldGuild The guild before the update\n       * @param {Guild} newGuild The guild after the update\n       */\n\n\n      client.emit(Events.GUILD_UPDATE, old, guild);\n      return {\n        old,\n        updated: guild\n      };\n    }\n\n    return {\n      old: null,\n      updated: null\n    };\n  }\n\n}\n\nmodule.exports = GuildUpdateAction;\n\n//# sourceURL=webpack://Fosscord/./src/client/actions/GuildUpdate.js?')},"./src/client/actions/InteractionCreate.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nconst Action = __webpack_require__(/*! ./Action */ \"./src/client/actions/Action.js\");\n\nconst {\n  Events,\n  InteractionTypes,\n  MessageComponentTypes\n} = __webpack_require__(/*! ../../util/Constants */ \"./src/util/Constants.js\");\n\nconst Structures = __webpack_require__(/*! ../../util/Structures */ \"./src/util/Structures.js\");\n\nclass InteractionCreateAction extends Action {\n  handle(data) {\n    const client = this.client; // Resolve and cache partial channels for Interaction#channel getter\n\n    this.getChannel(data);\n    let InteractionType;\n\n    switch (data.type) {\n      case InteractionTypes.APPLICATION_COMMAND:\n        InteractionType = Structures.get('CommandInteraction');\n        break;\n\n      case InteractionTypes.MESSAGE_COMPONENT:\n        switch (data.data.component_type) {\n          case MessageComponentTypes.BUTTON:\n            InteractionType = Structures.get('ButtonInteraction');\n            break;\n\n          case MessageComponentTypes.SELECT_MENU:\n            InteractionType = Structures.get('SelectMenuInteraction');\n            break;\n\n          default:\n            client.emit(Events.DEBUG, `[INTERACTION] Received component interaction with unknown type: ${data.data.component_type}`);\n            return;\n        }\n\n        break;\n\n      default:\n        client.emit(Events.DEBUG, `[INTERACTION] Received interaction with unknown type: ${data.type}`);\n        return;\n    }\n    /**\n     * Emitted when an interaction is created.\n     * @event Client#interaction\n     * @param {Interaction} interaction The interaction which was created\n     */\n\n\n    client.emit(Events.INTERACTION_CREATE, new InteractionType(client, data));\n  }\n\n}\n\nmodule.exports = InteractionCreateAction;\n\n//# sourceURL=webpack://Fosscord/./src/client/actions/InteractionCreate.js?")},"./src/client/actions/InviteCreate.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nconst Action = __webpack_require__(/*! ./Action */ "./src/client/actions/Action.js");\n\nconst Invite = __webpack_require__(/*! ../../structures/Invite */ "./src/structures/Invite.js");\n\nconst {\n  Events\n} = __webpack_require__(/*! ../../util/Constants */ "./src/util/Constants.js");\n\nclass InviteCreateAction extends Action {\n  handle(data) {\n    const client = this.client;\n    const channel = client.channels.cache.get(data.channel_id);\n    const guild = client.guilds.cache.get(data.guild_id);\n    if (!channel) return false;\n    const inviteData = Object.assign(data, {\n      channel,\n      guild\n    });\n    const invite = new Invite(client, inviteData);\n    /**\n     * Emitted when an invite is created.\n     * <info> This event only triggers if the client has `MANAGE_GUILD` permissions for the guild,\n     * or `MANAGE_CHANNEL` permissions for the channel.</info>\n     * @event Client#inviteCreate\n     * @param {Invite} invite The invite that was created\n     */\n\n    client.emit(Events.INVITE_CREATE, invite);\n    return {\n      invite\n    };\n  }\n\n}\n\nmodule.exports = InviteCreateAction;\n\n//# sourceURL=webpack://Fosscord/./src/client/actions/InviteCreate.js?')},"./src/client/actions/InviteDelete.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nconst Action = __webpack_require__(/*! ./Action */ "./src/client/actions/Action.js");\n\nconst Invite = __webpack_require__(/*! ../../structures/Invite */ "./src/structures/Invite.js");\n\nconst {\n  Events\n} = __webpack_require__(/*! ../../util/Constants */ "./src/util/Constants.js");\n\nclass InviteDeleteAction extends Action {\n  handle(data) {\n    const client = this.client;\n    const channel = client.channels.cache.get(data.channel_id);\n    const guild = client.guilds.cache.get(data.guild_id);\n    if (!channel) return false;\n    const inviteData = Object.assign(data, {\n      channel,\n      guild\n    });\n    const invite = new Invite(client, inviteData);\n    /**\n     * Emitted when an invite is deleted.\n     * <info> This event only triggers if the client has `MANAGE_GUILD` permissions for the guild,\n     * or `MANAGE_CHANNEL` permissions for the channel.</info>\n     * @event Client#inviteDelete\n     * @param {Invite} invite The invite that was deleted\n     */\n\n    client.emit(Events.INVITE_DELETE, invite);\n    return {\n      invite\n    };\n  }\n\n}\n\nmodule.exports = InviteDeleteAction;\n\n//# sourceURL=webpack://Fosscord/./src/client/actions/InviteDelete.js?')},"./src/client/actions/MessageCreate.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nconst Action = __webpack_require__(/*! ./Action */ "./src/client/actions/Action.js");\n\nconst {\n  Events\n} = __webpack_require__(/*! ../../util/Constants */ "./src/util/Constants.js");\n\nclass MessageCreateAction extends Action {\n  handle(data) {\n    const client = this.client;\n    const channel = this.getChannel(data);\n\n    if (channel) {\n      const existing = channel.messages.cache.get(data.id);\n      if (existing) return {\n        message: existing\n      };\n      const message = channel.messages.add(data);\n      const user = message.author;\n      let member = message.member;\n      channel.lastMessageID = data.id;\n\n      if (user) {\n        user.lastMessageID = data.id;\n        user.lastMessageChannelID = channel.id;\n      }\n\n      if (member) {\n        member.lastMessageID = data.id;\n        member.lastMessageChannelID = channel.id;\n      }\n      /**\n       * Emitted whenever a message is created.\n       * @event Client#message\n       * @param {Message} message The created message\n       */\n\n\n      client.emit(Events.MESSAGE_CREATE, message);\n      return {\n        message\n      };\n    }\n\n    return {};\n  }\n\n}\n\nmodule.exports = MessageCreateAction;\n\n//# sourceURL=webpack://Fosscord/./src/client/actions/MessageCreate.js?')},"./src/client/actions/MessageDelete.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nconst Action = __webpack_require__(/*! ./Action */ "./src/client/actions/Action.js");\n\nconst {\n  Events\n} = __webpack_require__(/*! ../../util/Constants */ "./src/util/Constants.js");\n\nclass MessageDeleteAction extends Action {\n  handle(data) {\n    const client = this.client;\n    const channel = this.getChannel(data);\n    let message;\n\n    if (channel) {\n      message = this.getMessage(data, channel);\n\n      if (message) {\n        channel.messages.cache.delete(message.id);\n        message.deleted = true;\n        /**\n         * Emitted whenever a message is deleted.\n         * @event Client#messageDelete\n         * @param {Message} message The deleted message\n         */\n\n        client.emit(Events.MESSAGE_DELETE, message);\n      }\n    }\n\n    return {\n      message\n    };\n  }\n\n}\n\nmodule.exports = MessageDeleteAction;\n\n//# sourceURL=webpack://Fosscord/./src/client/actions/MessageDelete.js?')},"./src/client/actions/MessageDeleteBulk.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nconst Action = __webpack_require__(/*! ./Action */ "./src/client/actions/Action.js");\n\nconst Collection = __webpack_require__(/*! ../../util/Collection */ "./src/util/Collection.js");\n\nconst {\n  Events\n} = __webpack_require__(/*! ../../util/Constants */ "./src/util/Constants.js");\n\nclass MessageDeleteBulkAction extends Action {\n  handle(data) {\n    const client = this.client;\n    const channel = client.channels.cache.get(data.channel_id);\n\n    if (channel) {\n      const ids = data.ids;\n      const messages = new Collection();\n\n      for (const id of ids) {\n        const message = this.getMessage({\n          id,\n          guild_id: data.guild_id\n        }, channel, false);\n\n        if (message) {\n          message.deleted = true;\n          messages.set(message.id, message);\n          channel.messages.cache.delete(id);\n        }\n      }\n      /**\n       * Emitted whenever messages are deleted in bulk.\n       * @event Client#messageDeleteBulk\n       * @param {Collection<Snowflake, Message>} messages The deleted messages, mapped by their ID\n       */\n\n\n      if (messages.size > 0) client.emit(Events.MESSAGE_BULK_DELETE, messages);\n      return {\n        messages\n      };\n    }\n\n    return {};\n  }\n\n}\n\nmodule.exports = MessageDeleteBulkAction;\n\n//# sourceURL=webpack://Fosscord/./src/client/actions/MessageDeleteBulk.js?')},"./src/client/actions/MessageReactionAdd.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nconst Action = __webpack_require__(/*! ./Action */ \"./src/client/actions/Action.js\");\n\nconst {\n  Events\n} = __webpack_require__(/*! ../../util/Constants */ \"./src/util/Constants.js\");\n\nconst {\n  PartialTypes\n} = __webpack_require__(/*! ../../util/Constants */ \"./src/util/Constants.js\");\n/*\n{ user_id: 'id',\n     message_id: 'id',\n     emoji: { name: '', id: null },\n     channel_id: 'id',\n     // If originating from a guild\n     guild_id: 'id',\n     member: { ..., user: { ... } } }\n*/\n\n\nclass MessageReactionAdd extends Action {\n  handle(data) {\n    if (!data.emoji) return false;\n    const user = this.getUserFromMember(data);\n    if (!user) return false; // Verify channel\n\n    const channel = this.getChannel(data);\n    if (!channel || channel.type === 'voice') return false; // Verify message\n\n    const message = this.getMessage(data, channel);\n    if (!message) return false; // Verify reaction\n\n    if (message.partial && !this.client.options.partials.includes(PartialTypes.REACTION)) return false;\n    const existing = message.reactions.cache.get(data.emoji.id || data.emoji.name);\n    if (existing && existing.users.cache.has(user.id)) return {\n      message,\n      reaction: existing,\n      user\n    };\n    const reaction = message.reactions.add({\n      emoji: data.emoji,\n      count: message.partial ? null : 0,\n      me: user.id === this.client.user.id\n    });\n    if (!reaction) return false;\n\n    reaction._add(user);\n    /**\n     * Emitted whenever a reaction is added to a cached message.\n     * @event Client#messageReactionAdd\n     * @param {MessageReaction} messageReaction The reaction object\n     * @param {User} user The user that applied the guild or reaction emoji\n     */\n\n\n    this.client.emit(Events.MESSAGE_REACTION_ADD, reaction, user);\n    return {\n      message,\n      reaction,\n      user\n    };\n  }\n\n}\n\nmodule.exports = MessageReactionAdd;\n\n//# sourceURL=webpack://Fosscord/./src/client/actions/MessageReactionAdd.js?")},"./src/client/actions/MessageReactionRemove.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nconst Action = __webpack_require__(/*! ./Action */ \"./src/client/actions/Action.js\");\n\nconst {\n  Events\n} = __webpack_require__(/*! ../../util/Constants */ \"./src/util/Constants.js\");\n/*\n{ user_id: 'id',\n     message_id: 'id',\n     emoji: { name: '', id: null },\n     channel_id: 'id',\n     guild_id: 'id' }\n*/\n\n\nclass MessageReactionRemove extends Action {\n  handle(data) {\n    if (!data.emoji) return false;\n    const user = this.getUser(data);\n    if (!user) return false; // Verify channel\n\n    const channel = this.getChannel(data);\n    if (!channel || channel.type === 'voice') return false; // Verify message\n\n    const message = this.getMessage(data, channel);\n    if (!message) return false; // Verify reaction\n\n    const reaction = this.getReaction(data, message, user);\n    if (!reaction) return false;\n\n    reaction._remove(user);\n    /**\n     * Emitted whenever a reaction is removed from a cached message.\n     * @event Client#messageReactionRemove\n     * @param {MessageReaction} messageReaction The reaction object\n     * @param {User} user The user whose emoji or reaction emoji was removed\n     */\n\n\n    this.client.emit(Events.MESSAGE_REACTION_REMOVE, reaction, user);\n    return {\n      message,\n      reaction,\n      user\n    };\n  }\n\n}\n\nmodule.exports = MessageReactionRemove;\n\n//# sourceURL=webpack://Fosscord/./src/client/actions/MessageReactionRemove.js?")},"./src/client/actions/MessageReactionRemoveAll.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nconst Action = __webpack_require__(/*! ./Action */ "./src/client/actions/Action.js");\n\nconst {\n  Events\n} = __webpack_require__(/*! ../../util/Constants */ "./src/util/Constants.js");\n\nclass MessageReactionRemoveAll extends Action {\n  handle(data) {\n    // Verify channel\n    const channel = this.getChannel(data);\n    if (!channel || channel.type === \'voice\') return false; // Verify message\n\n    const message = this.getMessage(data, channel);\n    if (!message) return false;\n    message.reactions.cache.clear();\n    this.client.emit(Events.MESSAGE_REACTION_REMOVE_ALL, message);\n    return {\n      message\n    };\n  }\n\n}\n/**\n * Emitted whenever all reactions are removed from a cached message.\n * @event Client#messageReactionRemoveAll\n * @param {Message} message The message the reactions were removed from\n */\n\n\nmodule.exports = MessageReactionRemoveAll;\n\n//# sourceURL=webpack://Fosscord/./src/client/actions/MessageReactionRemoveAll.js?')},"./src/client/actions/MessageReactionRemoveEmoji.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nconst Action = __webpack_require__(/*! ./Action */ "./src/client/actions/Action.js");\n\nconst {\n  Events\n} = __webpack_require__(/*! ../../util/Constants */ "./src/util/Constants.js");\n\nclass MessageReactionRemoveEmoji extends Action {\n  handle(data) {\n    const channel = this.getChannel(data);\n    if (!channel || channel.type === \'voice\') return false;\n    const message = this.getMessage(data, channel);\n    if (!message) return false;\n    const reaction = this.getReaction(data, message);\n    if (!reaction) return false;\n    if (!message.partial) message.reactions.cache.delete(reaction.emoji.id || reaction.emoji.name);\n    /**\n     * Emitted when a bot removes an emoji reaction from a cached message.\n     * @event Client#messageReactionRemoveEmoji\n     * @param {MessageReaction} reaction The reaction that was removed\n     */\n\n    this.client.emit(Events.MESSAGE_REACTION_REMOVE_EMOJI, reaction);\n    return {\n      reaction\n    };\n  }\n\n}\n\nmodule.exports = MessageReactionRemoveEmoji;\n\n//# sourceURL=webpack://Fosscord/./src/client/actions/MessageReactionRemoveEmoji.js?')},"./src/client/actions/MessageUpdate.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nconst Action = __webpack_require__(/*! ./Action */ "./src/client/actions/Action.js");\n\nclass MessageUpdateAction extends Action {\n  handle(data) {\n    const channel = this.getChannel(data);\n\n    if (channel) {\n      const {\n        id,\n        channel_id,\n        guild_id,\n        author,\n        timestamp,\n        type\n      } = data;\n      const message = this.getMessage({\n        id,\n        channel_id,\n        guild_id,\n        author,\n        timestamp,\n        type\n      }, channel);\n\n      if (message) {\n        const old = message.patch(data);\n        return {\n          old,\n          updated: message\n        };\n      }\n    }\n\n    return {};\n  }\n\n}\n\nmodule.exports = MessageUpdateAction;\n\n//# sourceURL=webpack://Fosscord/./src/client/actions/MessageUpdate.js?')},"./src/client/actions/PresenceUpdate.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nconst Action = __webpack_require__(/*! ./Action */ "./src/client/actions/Action.js");\n\nconst {\n  Events\n} = __webpack_require__(/*! ../../util/Constants */ "./src/util/Constants.js");\n\nclass PresenceUpdateAction extends Action {\n  handle(data) {\n    let user = this.client.users.cache.get(data.user.id);\n    if (!user && data.user.username) user = this.client.users.add(data.user);\n    if (!user) return;\n\n    if (data.user && data.user.username) {\n      if (!user.equals(data.user)) this.client.actions.UserUpdate.handle(data.user);\n    }\n\n    const guild = this.client.guilds.cache.get(data.guild_id);\n    if (!guild) return;\n    let oldPresence = guild.presences.cache.get(user.id);\n    if (oldPresence) oldPresence = oldPresence._clone();\n    let member = guild.members.cache.get(user.id);\n\n    if (!member && data.status !== \'offline\') {\n      member = guild.members.add({\n        user,\n        deaf: false,\n        mute: false\n      });\n      this.client.emit(Events.GUILD_MEMBER_AVAILABLE, member);\n    }\n\n    guild.presences.add(Object.assign(data, {\n      guild\n    }));\n\n    if (member && this.client.listenerCount(Events.PRESENCE_UPDATE) && !member.presence.equals(oldPresence)) {\n      /**\n       * Emitted whenever a guild member\'s presence (e.g. status, activity) is changed.\n       * @event Client#presenceUpdate\n       * @param {?Presence} oldPresence The presence before the update, if one at all\n       * @param {Presence} newPresence The presence after the update\n       */\n      this.client.emit(Events.PRESENCE_UPDATE, oldPresence, member.presence);\n    }\n  }\n\n}\n\nmodule.exports = PresenceUpdateAction;\n\n//# sourceURL=webpack://Fosscord/./src/client/actions/PresenceUpdate.js?')},"./src/client/actions/StageInstanceCreate.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nconst Action = __webpack_require__(/*! ./Action */ "./src/client/actions/Action.js");\n\nconst {\n  Events\n} = __webpack_require__(/*! ../../util/Constants */ "./src/util/Constants.js");\n\nclass StageInstanceCreateAction extends Action {\n  handle(data) {\n    const client = this.client;\n    const channel = this.getChannel(data);\n\n    if (channel) {\n      const stageInstance = channel.guild.stageInstances.add(data);\n      /**\n       * Emitted whenever a stage instance is created.\n       * @event Client#stageInstanceCreate\n       * @param {StageInstance} stageInstance The created stage instance\n       */\n\n      client.emit(Events.STAGE_INSTANCE_CREATE, stageInstance);\n      return {\n        stageInstance\n      };\n    }\n\n    return {};\n  }\n\n}\n\nmodule.exports = StageInstanceCreateAction;\n\n//# sourceURL=webpack://Fosscord/./src/client/actions/StageInstanceCreate.js?')},"./src/client/actions/StageInstanceDelete.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nconst Action = __webpack_require__(/*! ./Action */ "./src/client/actions/Action.js");\n\nconst {\n  Events\n} = __webpack_require__(/*! ../../util/Constants */ "./src/util/Constants.js");\n\nclass StageInstanceDeleteAction extends Action {\n  handle(data) {\n    const client = this.client;\n    const channel = this.getChannel(data);\n\n    if (channel) {\n      const stageInstance = channel.guild.stageInstances.add(data);\n\n      if (stageInstance) {\n        channel.guild.stageInstances.cache.delete(stageInstance.id);\n        stageInstance.deleted = true;\n        /**\n         * Emitted whenever a stage instance is deleted.\n         * @event Client#stageInstanceDelete\n         * @param {StageInstance} stageInstance The deleted stage instance\n         */\n\n        client.emit(Events.STAGE_INSTANCE_DELETE, stageInstance);\n        return {\n          stageInstance\n        };\n      }\n    }\n\n    return {};\n  }\n\n}\n\nmodule.exports = StageInstanceDeleteAction;\n\n//# sourceURL=webpack://Fosscord/./src/client/actions/StageInstanceDelete.js?')},"./src/client/actions/StageInstanceUpdate.js":function(module,exports){eval('throw new Error("Module parse failed: Unexpected token (15:79)\\nFile was processed with these loaders:\\n * ./node_modules/babel-loader/lib/index.js\\nYou may need an additional loader to handle the result of these loaders.\\n| \\n|     if (channel) {\\n>       const oldStageInstance = channel.guild.stageInstances.cache.get(data.id)?._clone() ?? null;\\n|       const newStageInstance = channel.guild.stageInstances.add(data);\\n|       /**");\n\n//# sourceURL=webpack://Fosscord/./src/client/actions/StageInstanceUpdate.js?')},"./src/client/actions/ThreadCreate.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nconst Action = __webpack_require__(/*! ./Action */ "./src/client/actions/Action.js");\n\nconst {\n  Events\n} = __webpack_require__(/*! ../../util/Constants */ "./src/util/Constants.js");\n\nclass ThreadCreateAction extends Action {\n  handle(data) {\n    const client = this.client;\n    const existing = client.channels.cache.has(data.id);\n    const thread = client.channels.add(data);\n\n    if (!existing && thread) {\n      /**\n       * Emitted whenever a thread is created or when the client user is added to a thread.\n       * @event Client#threadCreate\n       * @param {ThreadChannel} thread The thread that was created\n       */\n      client.emit(Events.THREAD_CREATE, thread);\n    }\n\n    return {\n      thread\n    };\n  }\n\n}\n\nmodule.exports = ThreadCreateAction;\n\n//# sourceURL=webpack://Fosscord/./src/client/actions/ThreadCreate.js?')},"./src/client/actions/ThreadDelete.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nconst Action = __webpack_require__(/*! ./Action */ "./src/client/actions/Action.js");\n\nconst {\n  Events\n} = __webpack_require__(/*! ../../util/Constants */ "./src/util/Constants.js");\n\nclass ThreadDeleteAction extends Action {\n  handle(data) {\n    const client = this.client;\n    const thread = client.channels.cache.get(data.id);\n\n    if (thread) {\n      client.channels.remove(thread.id);\n      thread.deleted = true;\n\n      for (const message of thread.messages.cache.values()) {\n        message.deleted = true;\n      }\n      /**\n       * Emitted whenever a thread is deleted.\n       * @event Client#threadDelete\n       * @param {ThreadChannel} thread The thread that was deleted\n       */\n\n\n      client.emit(Events.THREAD_DELETE, thread);\n    }\n\n    return {\n      thread\n    };\n  }\n\n}\n\nmodule.exports = ThreadDeleteAction;\n\n//# sourceURL=webpack://Fosscord/./src/client/actions/ThreadDelete.js?')},"./src/client/actions/ThreadListSync.js":function(module,exports){eval('throw new Error("Module parse failed: Unexpected token (55:20)\\nFile was processed with these loaders:\\n * ./node_modules/babel-loader/lib/index.js\\nYou may need an additional loader to handle the result of these loaders.\\n| \\n|   removeStale(channel) {\\n>     channel.threads?.cache.forEach(thread => {\\n|       if (!thread.archived) {\\n|         this.client.channels.remove(thread.id);");\n\n//# sourceURL=webpack://Fosscord/./src/client/actions/ThreadListSync.js?')},"./src/client/actions/ThreadMemberUpdate.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nconst Action = __webpack_require__(/*! ./Action */ "./src/client/actions/Action.js");\n\nconst {\n  Events\n} = __webpack_require__(/*! ../../util/Constants */ "./src/util/Constants.js");\n\nclass ThreadMemberUpdateAction extends Action {\n  handle(data) {\n    const client = this.client; // Discord sends the thread id as id in this object\n\n    const thread = client.channels.cache.get(data.id);\n\n    if (thread) {\n      const member = thread.members.cache.get(data.user_id);\n\n      if (!member) {\n        const newMember = thread.members._add(data);\n\n        return {\n          newMember\n        };\n      }\n\n      const old = member._update(data);\n      /**\n       * Emitted whenever the client user\'s thread member is updated.\n       * @event Client#threadMemberUpdate\n       * @param {ThreadMember} oldMember The member before the update\n       * @param {ThreadMember} newMember The member after the update\n       */\n\n\n      client.emit(Events.THREAD_MEMBER_UPDATE, old, member);\n    }\n\n    return {};\n  }\n\n}\n\nmodule.exports = ThreadMemberUpdateAction;\n\n//# sourceURL=webpack://Fosscord/./src/client/actions/ThreadMemberUpdate.js?')},"./src/client/actions/ThreadMembersUpdate.js":function(module,exports){eval('throw new Error("Module parse failed: Unexpected token (17:25)\\nFile was processed with these loaders:\\n * ./node_modules/babel-loader/lib/index.js\\nYou may need an additional loader to handle the result of these loaders.\\n|       const old = thread.members.cache.clone();\\n|       thread.memberCount = data.member_count;\\n>       data.added_members?.forEach(rawMember => {\\n|         thread.members._add(rawMember);\\n|       });");\n\n//# sourceURL=webpack://Fosscord/./src/client/actions/ThreadMembersUpdate.js?')},"./src/client/actions/TypingStart.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nconst Action = __webpack_require__(/*! ./Action */ \"./src/client/actions/Action.js\");\n\nconst {\n  Events\n} = __webpack_require__(/*! ../../util/Constants */ \"./src/util/Constants.js\");\n\nconst textBasedChannelTypes = ['dm', 'text', 'news', 'news_thread', 'public_thread', 'private_thread'];\n\nclass TypingStart extends Action {\n  handle(data) {\n    const channel = this.getChannel(data);\n\n    if (!channel) {\n      return;\n    }\n\n    if (!textBasedChannelTypes.includes(channel.type)) {\n      this.client.emit(Events.WARN, `Discord sent a typing packet to a ${channel.type} channel ${channel.id}`);\n      return;\n    }\n\n    const user = this.getUserFromMember(data);\n    const timestamp = new Date(data.timestamp * 1000);\n\n    if (channel && user) {\n      if (channel._typing.has(user.id)) {\n        const typing = channel._typing.get(user.id);\n\n        typing.lastTimestamp = timestamp;\n        typing.elapsedTime = Date.now() - typing.since;\n        this.client.clearTimeout(typing.timeout);\n        typing.timeout = this.tooLate(channel, user);\n      } else {\n        const since = new Date();\n        const lastTimestamp = new Date();\n\n        channel._typing.set(user.id, {\n          user,\n          since,\n          lastTimestamp,\n          elapsedTime: Date.now() - since,\n          timeout: this.tooLate(channel, user)\n        });\n        /**\n         * Emitted whenever a user starts typing in a channel.\n         * @event Client#typingStart\n         * @param {DMChannel|TextChannel|NewsChannel} channel The channel the user started typing in\n         * @param {User} user The user that started typing\n         */\n\n\n        this.client.emit(Events.TYPING_START, channel, user);\n      }\n    }\n  }\n\n  tooLate(channel, user) {\n    return channel.client.setTimeout(() => {\n      channel._typing.delete(user.id);\n    }, 10000);\n  }\n\n}\n\nmodule.exports = TypingStart;\n\n//# sourceURL=webpack://Fosscord/./src/client/actions/TypingStart.js?")},"./src/client/actions/UserUpdate.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nconst Action = __webpack_require__(/*! ./Action */ "./src/client/actions/Action.js");\n\nconst {\n  Events\n} = __webpack_require__(/*! ../../util/Constants */ "./src/util/Constants.js");\n\nclass UserUpdateAction extends Action {\n  handle(data) {\n    const client = this.client;\n    const newUser = client.users.cache.get(data.id);\n\n    const oldUser = newUser._update(data);\n\n    if (!oldUser.equals(newUser)) {\n      /**\n       * Emitted whenever a user\'s details (e.g. username) are changed.\n       * Triggered by the Discord gateway events USER_UPDATE, GUILD_MEMBER_UPDATE, and PRESENCE_UPDATE.\n       * @event Client#userUpdate\n       * @param {User} oldUser The user before the update\n       * @param {User} newUser The user after the update\n       */\n      client.emit(Events.USER_UPDATE, oldUser, newUser);\n      return {\n        old: oldUser,\n        updated: newUser\n      };\n    }\n\n    return {\n      old: null,\n      updated: null\n    };\n  }\n\n}\n\nmodule.exports = UserUpdateAction;\n\n//# sourceURL=webpack://Fosscord/./src/client/actions/UserUpdate.js?')},"./src/client/actions/VoiceStateUpdate.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nconst Action = __webpack_require__(/*! ./Action */ "./src/client/actions/Action.js");\n\nconst {\n  Events\n} = __webpack_require__(/*! ../../util/Constants */ "./src/util/Constants.js");\n\nconst Structures = __webpack_require__(/*! ../../util/Structures */ "./src/util/Structures.js");\n\nclass VoiceStateUpdate extends Action {\n  handle(data) {\n    const client = this.client;\n    const guild = client.guilds.cache.get(data.guild_id);\n\n    if (guild) {\n      const VoiceState = Structures.get(\'VoiceState\'); // Update the state\n\n      const oldState = guild.voiceStates.cache.has(data.user_id) ? guild.voiceStates.cache.get(data.user_id)._clone() : new VoiceState(guild, {\n        user_id: data.user_id\n      });\n      const newState = guild.voiceStates.add(data); // Get the member\n\n      let member = guild.members.cache.get(data.user_id);\n\n      if (member && data.member) {\n        member._patch(data.member);\n      } else if (data.member && data.member.user && data.member.joined_at) {\n        member = guild.members.add(data.member);\n      } // Emit event\n\n\n      if (member && member.user.id === client.user.id) {\n        client.emit(\'debug\', `[VOICE] received voice state update: ${JSON.stringify(data)}`);\n        client.voice.onVoiceStateUpdate(data);\n      }\n      /**\n       * Emitted whenever a member changes voice state - e.g. joins/leaves a channel, mutes/unmutes.\n       * @event Client#voiceStateUpdate\n       * @param {VoiceState} oldState The voice state before the update\n       * @param {VoiceState} newState The voice state after the update\n       */\n\n\n      client.emit(Events.VOICE_STATE_UPDATE, oldState, newState);\n    }\n  }\n\n}\n\nmodule.exports = VoiceStateUpdate;\n\n//# sourceURL=webpack://Fosscord/./src/client/actions/VoiceStateUpdate.js?')},"./src/client/actions/WebhooksUpdate.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nconst Action = __webpack_require__(/*! ./Action */ "./src/client/actions/Action.js");\n\nconst {\n  Events\n} = __webpack_require__(/*! ../../util/Constants */ "./src/util/Constants.js");\n\nclass WebhooksUpdate extends Action {\n  handle(data) {\n    const client = this.client;\n    const channel = client.channels.cache.get(data.channel_id);\n    /**\n     * Emitted whenever a guild text channel has its webhooks changed.\n     * @event Client#webhookUpdate\n     * @param {TextChannel} channel The channel that had a webhook update\n     */\n\n    if (channel) client.emit(Events.WEBHOOKS_UPDATE, channel);\n  }\n\n}\n\nmodule.exports = WebhooksUpdate;\n\n//# sourceURL=webpack://Fosscord/./src/client/actions/WebhooksUpdate.js?')},"./src/client/websocket/WebSocketManager.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nconst EventEmitter = __webpack_require__(/*! events */ \"./node_modules/events/events.js\");\n\nconst WebSocketShard = __webpack_require__(/*! ./WebSocketShard */ \"./src/client/websocket/WebSocketShard.js\");\n\nconst PacketHandlers = __webpack_require__(/*! ./handlers */ \"./src/client/websocket/handlers/index.js\");\n\nconst {\n  Error\n} = __webpack_require__(/*! ../../errors */ \"./src/errors/index.js\");\n\nconst Collection = __webpack_require__(/*! ../../util/Collection */ \"./src/util/Collection.js\");\n\nconst {\n  Events,\n  ShardEvents,\n  Status,\n  WSCodes,\n  WSEvents\n} = __webpack_require__(/*! ../../util/Constants */ \"./src/util/Constants.js\");\n\nconst Util = __webpack_require__(/*! ../../util/Util */ \"./src/util/Util.js\");\n\nconst BeforeReadyWhitelist = [WSEvents.READY, WSEvents.RESUMED, WSEvents.GUILD_CREATE, WSEvents.GUILD_DELETE, WSEvents.GUILD_MEMBERS_CHUNK, WSEvents.GUILD_MEMBER_ADD, WSEvents.GUILD_MEMBER_REMOVE];\nconst UNRECOVERABLE_CLOSE_CODES = Object.keys(WSCodes).slice(1).map(Number);\nconst UNRESUMABLE_CLOSE_CODES = [1000, 4006, 4007];\n/**\n * The WebSocket manager for this client.\n * <info>This class forwards raw dispatch events,\n * read more about it here {@link https://discord.com/developers/docs/topics/gateway}</info>\n * @extends EventEmitter\n */\n\nclass WebSocketManager extends EventEmitter {\n  constructor(client) {\n    super();\n    /**\n     * The client that instantiated this WebSocketManager\n     * @type {Client}\n     * @readonly\n     * @name WebSocketManager#client\n     */\n\n    Object.defineProperty(this, 'client', {\n      value: client\n    });\n    /**\n     * The gateway this manager uses\n     * @type {?string}\n     */\n\n    this.gateway = null;\n    /**\n     * The amount of shards this manager handles\n     * @private\n     * @type {number}\n     */\n\n    this.totalShards = this.client.options.shards.length;\n    /**\n     * A collection of all shards this manager handles\n     * @type {Collection<number, WebSocketShard>}\n     */\n\n    this.shards = new Collection();\n    /**\n     * An array of shards to be connected or that need to reconnect\n     * @type {Set<WebSocketShard>}\n     * @private\n     * @name WebSocketManager#shardQueue\n     */\n\n    Object.defineProperty(this, 'shardQueue', {\n      value: new Set(),\n      writable: true\n    });\n    /**\n     * An array of queued events before this WebSocketManager became ready\n     * @type {Object[]}\n     * @private\n     * @name WebSocketManager#packetQueue\n     */\n\n    Object.defineProperty(this, 'packetQueue', {\n      value: []\n    });\n    /**\n     * The current status of this WebSocketManager\n     * @type {Status}\n     */\n\n    this.status = Status.IDLE;\n    /**\n     * If this manager was destroyed. It will prevent shards from reconnecting\n     * @type {boolean}\n     * @private\n     */\n\n    this.destroyed = false;\n    /**\n     * If this manager is currently reconnecting one or multiple shards\n     * @type {boolean}\n     * @private\n     */\n\n    this.reconnecting = false;\n  }\n  /**\n   * The average ping of all WebSocketShards\n   * @type {number}\n   * @readonly\n   */\n\n\n  get ping() {\n    const sum = this.shards.reduce((a, b) => a + b.ping, 0);\n    return sum / this.shards.size;\n  }\n  /**\n   * Emits a debug message.\n   * @param {string} message The debug message\n   * @param {?WebSocketShard} [shard] The shard that emitted this message, if any\n   * @private\n   */\n\n\n  debug(message, shard) {\n    this.client.emit(Events.DEBUG, `[WS => ${shard ? `Shard ${shard.id}` : 'Manager'}] ${message}`);\n  }\n  /**\n   * Connects this manager to the gateway.\n   * @private\n   */\n\n\n  async connect() {\n    const invalidToken = new Error(WSCodes[4004]);\n    const {\n      url: gatewayURL,\n      shards: recommendedShards,\n      session_start_limit: sessionStartLimit\n    } = await this.client.api.gateway.bot.get().catch(error => {\n      throw error.httpStatus === 401 ? invalidToken : error;\n    });\n    const {\n      total,\n      remaining\n    } = sessionStartLimit;\n    this.debug(`Fetched Gateway Information\n    URL: ${gatewayURL}\n    Recommended Shards: ${recommendedShards}`);\n    this.debug(`Session Limit Information\n    Total: ${total}\n    Remaining: ${remaining}`);\n    this.gateway = `${gatewayURL}/`;\n    let {\n      shards\n    } = this.client.options;\n\n    if (shards === 'auto') {\n      this.debug(`Using the recommended shard count provided by Discord: ${recommendedShards}`);\n      this.totalShards = this.client.options.shardCount = recommendedShards;\n      shards = this.client.options.shards = Array.from({\n        length: recommendedShards\n      }, (_, i) => i);\n    }\n\n    this.totalShards = shards.length;\n    this.debug(`Spawning shards: ${shards.join(', ')}`);\n    this.shardQueue = new Set(shards.map(id => new WebSocketShard(this, id)));\n    return this.createShards();\n  }\n  /**\n   * Handles the creation of a shard.\n   * @returns {Promise<boolean>}\n   * @private\n   */\n\n\n  async createShards() {\n    // If we don't have any shards to handle, return\n    if (!this.shardQueue.size) return false;\n    const [shard] = this.shardQueue;\n    this.shardQueue.delete(shard);\n\n    if (!shard.eventsAttached) {\n      shard.on(ShardEvents.ALL_READY, unavailableGuilds => {\n        /**\n         * Emitted when a shard turns ready.\n         * @event Client#shardReady\n         * @param {number} id The shard ID that turned ready\n         * @param {?Set<string>} unavailableGuilds Set of unavailable guild IDs, if any\n         */\n        this.client.emit(Events.SHARD_READY, shard.id, unavailableGuilds);\n        if (!this.shardQueue.size) this.reconnecting = false;\n        this.checkShardsReady();\n      });\n      shard.on(ShardEvents.CLOSE, event => {\n        if (event.code === 1000 ? this.destroyed : UNRECOVERABLE_CLOSE_CODES.includes(event.code)) {\n          /**\n           * Emitted when a shard's WebSocket disconnects and will no longer reconnect.\n           * @event Client#shardDisconnect\n           * @param {CloseEvent} event The WebSocket close event\n           * @param {number} id The shard ID that disconnected\n           */\n          this.client.emit(Events.SHARD_DISCONNECT, event, shard.id);\n          this.debug(WSCodes[event.code], shard);\n          return;\n        }\n\n        if (UNRESUMABLE_CLOSE_CODES.includes(event.code)) {\n          // These event codes cannot be resumed\n          shard.sessionID = null;\n        }\n        /**\n         * Emitted when a shard is attempting to reconnect or re-identify.\n         * @event Client#shardReconnecting\n         * @param {number} id The shard ID that is attempting to reconnect\n         */\n\n\n        this.client.emit(Events.SHARD_RECONNECTING, shard.id);\n        this.shardQueue.add(shard);\n\n        if (shard.sessionID) {\n          this.debug(`Session ID is present, attempting an immediate reconnect...`, shard);\n          this.reconnect();\n        } else {\n          shard.destroy({\n            reset: true,\n            emit: false,\n            log: false\n          });\n          this.reconnect();\n        }\n      });\n      shard.on(ShardEvents.INVALID_SESSION, () => {\n        this.client.emit(Events.SHARD_RECONNECTING, shard.id);\n      });\n      shard.on(ShardEvents.DESTROYED, () => {\n        this.debug('Shard was destroyed but no WebSocket connection was present! Reconnecting...', shard);\n        this.client.emit(Events.SHARD_RECONNECTING, shard.id);\n        this.shardQueue.add(shard);\n        this.reconnect();\n      });\n      shard.eventsAttached = true;\n    }\n\n    this.shards.set(shard.id, shard);\n\n    try {\n      await shard.connect();\n    } catch (error) {\n      if (error && error.code && UNRECOVERABLE_CLOSE_CODES.includes(error.code)) {\n        throw new Error(WSCodes[error.code]); // Undefined if session is invalid, error event for regular closes\n      } else if (!error || error.code) {\n        this.debug('Failed to connect to the gateway, requeueing...', shard);\n        this.shardQueue.add(shard);\n      } else {\n        throw error;\n      }\n    } // If we have more shards, add a 5s delay\n\n\n    if (this.shardQueue.size) {\n      this.debug(`Shard Queue Size: ${this.shardQueue.size}; continuing in 5 seconds...`);\n      await Util.delayFor(5000);\n      return this.createShards();\n    }\n\n    return true;\n  }\n  /**\n   * Handles reconnects for this manager.\n   * @private\n   * @returns {Promise<boolean>}\n   */\n\n\n  async reconnect() {\n    if (this.reconnecting || this.status !== Status.READY) return false;\n    this.reconnecting = true;\n\n    try {\n      await this.createShards();\n    } catch (error) {\n      this.debug(`Couldn't reconnect or fetch information about the gateway. ${error}`);\n\n      if (error.httpStatus !== 401) {\n        this.debug(`Possible network error occurred. Retrying in 5s...`);\n        await Util.delayFor(5000);\n        this.reconnecting = false;\n        return this.reconnect();\n      } // If we get an error at this point, it means we cannot reconnect anymore\n\n\n      if (this.client.listenerCount(Events.INVALIDATED)) {\n        /**\n         * Emitted when the client's session becomes invalidated.\n         * You are expected to handle closing the process gracefully and preventing a boot loop\n         * if you are listening to this event.\n         * @event Client#invalidated\n         */\n        this.client.emit(Events.INVALIDATED); // Destroy just the shards. This means you have to handle the cleanup yourself\n\n        this.destroy();\n      } else {\n        this.client.destroy();\n      }\n    } finally {\n      this.reconnecting = false;\n    }\n\n    return true;\n  }\n  /**\n   * Broadcasts a packet to every shard this manager handles.\n   * @param {Object} packet The packet to send\n   * @private\n   */\n\n\n  broadcast(packet) {\n    for (const shard of this.shards.values()) shard.send(packet);\n  }\n  /**\n   * Destroys this manager and all its shards.\n   * @private\n   */\n\n\n  destroy() {\n    if (this.destroyed) return;\n    this.debug(`Manager was destroyed. Called by:\\n${new Error('MANAGER_DESTROYED').stack}`);\n    this.destroyed = true;\n    this.shardQueue.clear();\n\n    for (const shard of this.shards.values()) shard.destroy({\n      closeCode: 1000,\n      reset: true,\n      emit: false,\n      log: false\n    });\n  }\n  /**\n   * Processes a packet and queues it if this WebSocketManager is not ready.\n   * @param {Object} [packet] The packet to be handled\n   * @param {WebSocketShard} [shard] The shard that will handle this packet\n   * @returns {boolean}\n   * @private\n   */\n\n\n  handlePacket(packet, shard) {\n    if (packet && this.status !== Status.READY) {\n      if (!BeforeReadyWhitelist.includes(packet.t)) {\n        this.packetQueue.push({\n          packet,\n          shard\n        });\n        return false;\n      }\n    }\n\n    if (this.packetQueue.length) {\n      const item = this.packetQueue.shift();\n      this.client.setImmediate(() => {\n        this.handlePacket(item.packet, item.shard);\n      });\n    }\n\n    if (packet && PacketHandlers[packet.t]) {\n      PacketHandlers[packet.t](this.client, packet, shard);\n    }\n\n    return true;\n  }\n  /**\n   * Checks whether the client is ready to be marked as ready.\n   * @private\n   */\n\n\n  checkShardsReady() {\n    if (this.status === Status.READY) return;\n\n    if (this.shards.size !== this.totalShards || this.shards.some(s => s.status !== Status.READY)) {\n      return;\n    }\n\n    this.triggerClientReady();\n  }\n  /**\n   * Causes the client to be marked as ready and emits the ready event.\n   * @private\n   */\n\n\n  triggerClientReady() {\n    this.status = Status.READY;\n    this.client.readyAt = new Date();\n    /**\n     * Emitted when the client becomes ready to start working.\n     * @event Client#ready\n     */\n\n    this.client.emit(Events.CLIENT_READY);\n    this.handlePacket();\n  }\n\n}\n\nmodule.exports = WebSocketManager;\n\n//# sourceURL=webpack://Fosscord/./src/client/websocket/WebSocketManager.js?")},"./src/client/websocket/WebSocketShard.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nconst EventEmitter = __webpack_require__(/*! events */ \"./node_modules/events/events.js\");\n\nconst WebSocket = __webpack_require__(/*! ../../WebSocket */ \"./src/WebSocket.js\");\n\nconst {\n  Status,\n  Events,\n  ShardEvents,\n  OPCodes,\n  WSEvents\n} = __webpack_require__(/*! ../../util/Constants */ \"./src/util/Constants.js\");\n\nconst Intents = __webpack_require__(/*! ../../util/Intents */ \"./src/util/Intents.js\");\n\nconst STATUS_KEYS = Object.keys(Status);\nconst CONNECTION_STATE = Object.keys(WebSocket.WebSocket);\nlet zlib;\n\ntry {\n  zlib = __webpack_require__(/*! zlib-sync */ 4);\n} catch {} // eslint-disable-line no-empty\n\n/**\n * Represents a Shard's WebSocket connection\n */\n\n\nclass WebSocketShard extends EventEmitter {\n  constructor(manager, id) {\n    super();\n    /**\n     * The WebSocketManager of the shard\n     * @type {WebSocketManager}\n     */\n\n    this.manager = manager;\n    /**\n     * The ID of the shard\n     * @type {number}\n     */\n\n    this.id = id;\n    /**\n     * The current status of the shard\n     * @type {Status}\n     */\n\n    this.status = Status.IDLE;\n    /**\n     * The current sequence of the shard\n     * @type {number}\n     * @private\n     */\n\n    this.sequence = -1;\n    /**\n     * The sequence of the shard after close\n     * @type {number}\n     * @private\n     */\n\n    this.closeSequence = 0;\n    /**\n     * The current session ID of the shard\n     * @type {?string}\n     * @private\n     */\n\n    this.sessionID = null;\n    /**\n     * The previous heartbeat ping of the shard\n     * @type {number}\n     */\n\n    this.ping = -1;\n    /**\n     * The last time a ping was sent (a timestamp)\n     * @type {number}\n     * @private\n     */\n\n    this.lastPingTimestamp = -1;\n    /**\n     * If we received a heartbeat ack back. Used to identify zombie connections\n     * @type {boolean}\n     * @private\n     */\n\n    this.lastHeartbeatAcked = true;\n    /**\n     * Contains the rate limit queue and metadata\n     * @name WebSocketShard#ratelimit\n     * @type {Object}\n     * @private\n     */\n\n    Object.defineProperty(this, 'ratelimit', {\n      value: {\n        queue: [],\n        total: 120,\n        remaining: 120,\n        time: 60e3,\n        timer: null\n      }\n    });\n    /**\n     * The WebSocket connection for the current shard\n     * @name WebSocketShard#connection\n     * @type {?WebSocket}\n     * @private\n     */\n\n    Object.defineProperty(this, 'connection', {\n      value: null,\n      writable: true\n    });\n    /**\n     * @external Inflate\n     * @see {@link https://www.npmjs.com/package/zlib-sync}\n     */\n\n    /**\n     * The compression to use\n     * @name WebSocketShard#inflate\n     * @type {?Inflate}\n     * @private\n     */\n\n    Object.defineProperty(this, 'inflate', {\n      value: null,\n      writable: true\n    });\n    /**\n     * The HELLO timeout\n     * @name WebSocketShard#helloTimeout\n     * @type {?NodeJS.Timeout}\n     * @private\n     */\n\n    Object.defineProperty(this, 'helloTimeout', {\n      value: null,\n      writable: true\n    });\n    /**\n     * If the manager attached its event handlers on the shard\n     * @name WebSocketShard#eventsAttached\n     * @type {boolean}\n     * @private\n     */\n\n    Object.defineProperty(this, 'eventsAttached', {\n      value: false,\n      writable: true\n    });\n    /**\n     * A set of guild IDs this shard expects to receive\n     * @name WebSocketShard#expectedGuilds\n     * @type {?Set<string>}\n     * @private\n     */\n\n    Object.defineProperty(this, 'expectedGuilds', {\n      value: null,\n      writable: true\n    });\n    /**\n     * The ready timeout\n     * @name WebSocketShard#readyTimeout\n     * @type {?NodeJS.Timeout}\n     * @private\n     */\n\n    Object.defineProperty(this, 'readyTimeout', {\n      value: null,\n      writable: true\n    });\n    /**\n     * Time when the WebSocket connection was opened\n     * @name WebSocketShard#connectedAt\n     * @type {number}\n     * @private\n     */\n\n    Object.defineProperty(this, 'connectedAt', {\n      value: 0,\n      writable: true\n    });\n  }\n  /**\n   * Emits a debug event.\n   * @param {string} message The debug message\n   * @private\n   */\n\n\n  debug(message) {\n    this.manager.debug(message, this);\n  }\n  /**\n   * Connects the shard to the gateway.\n   * @private\n   * @returns {Promise<void>} A promise that will resolve if the shard turns ready successfully,\n   * or reject if we couldn't connect\n   */\n\n\n  connect() {\n    const {\n      gateway,\n      client\n    } = this.manager;\n\n    if (this.connection && this.connection.readyState === WebSocket.OPEN && this.status === Status.READY) {\n      return Promise.resolve();\n    }\n\n    return new Promise((resolve, reject) => {\n      const cleanup = () => {\n        this.removeListener(ShardEvents.CLOSE, onClose);\n        this.removeListener(ShardEvents.READY, onReady);\n        this.removeListener(ShardEvents.RESUMED, onResumed);\n        this.removeListener(ShardEvents.INVALID_SESSION, onInvalidOrDestroyed);\n        this.removeListener(ShardEvents.DESTROYED, onInvalidOrDestroyed);\n      };\n\n      const onReady = () => {\n        cleanup();\n        resolve();\n      };\n\n      const onResumed = () => {\n        cleanup();\n        resolve();\n      };\n\n      const onClose = event => {\n        cleanup();\n        reject(event);\n      };\n\n      const onInvalidOrDestroyed = () => {\n        cleanup(); // eslint-disable-next-line prefer-promise-reject-errors\n\n        reject();\n      };\n\n      this.once(ShardEvents.READY, onReady);\n      this.once(ShardEvents.RESUMED, onResumed);\n      this.once(ShardEvents.CLOSE, onClose);\n      this.once(ShardEvents.INVALID_SESSION, onInvalidOrDestroyed);\n      this.once(ShardEvents.DESTROYED, onInvalidOrDestroyed);\n\n      if (this.connection && this.connection.readyState === WebSocket.OPEN) {\n        this.debug('An open connection was found, attempting an immediate identify.');\n        this.identify();\n        return;\n      }\n\n      if (this.connection) {\n        this.debug(`A connection object was found. Cleaning up before continuing.\n    State: ${CONNECTION_STATE[this.connection.readyState]}`);\n        this.destroy({\n          emit: false\n        });\n      }\n\n      const wsQuery = {\n        v: client.options.ws.version\n      };\n\n      if (zlib) {\n        this.inflate = new zlib.Inflate({\n          chunkSize: 65535,\n          flush: zlib.Z_SYNC_FLUSH,\n          to: WebSocket.encoding === 'json' ? 'string' : ''\n        });\n        wsQuery.compress = 'zlib-stream';\n      }\n\n      this.debug(`[CONNECT]\n    Gateway    : ${gateway}\n    Version    : ${client.options.ws.version}\n    Encoding   : ${WebSocket.encoding}\n    Compression: ${zlib ? 'zlib-stream' : 'none'}`);\n      this.status = this.status === Status.DISCONNECTED ? Status.RECONNECTING : Status.CONNECTING;\n      this.setHelloTimeout();\n      this.connectedAt = Date.now();\n      const ws = this.connection = WebSocket.create(gateway, wsQuery);\n      ws.onopen = this.onOpen.bind(this);\n      ws.onmessage = this.onMessage.bind(this);\n      ws.onerror = this.onError.bind(this);\n      ws.onclose = this.onClose.bind(this);\n    });\n  }\n  /**\n   * Called whenever a connection is opened to the gateway.\n   * @private\n   */\n\n\n  onOpen() {\n    this.debug(`[CONNECTED] ${this.connection.url} in ${Date.now() - this.connectedAt}ms`);\n    this.status = Status.NEARLY;\n  }\n  /**\n   * Called whenever a message is received.\n   * @param {MessageEvent} event Event received\n   * @private\n   */\n\n\n  onMessage({\n    data\n  }) {\n    let raw;\n    if (data instanceof ArrayBuffer) data = new Uint8Array(data);\n\n    if (zlib) {\n      const l = data.length;\n      const flush = l >= 4 && data[l - 4] === 0x00 && data[l - 3] === 0x00 && data[l - 2] === 0xff && data[l - 1] === 0xff;\n      this.inflate.push(data, flush && zlib.Z_SYNC_FLUSH);\n      if (!flush) return;\n      raw = this.inflate.result;\n    } else {\n      raw = data;\n    }\n\n    let packet;\n\n    try {\n      packet = WebSocket.unpack(raw);\n    } catch (err) {\n      this.manager.client.emit(Events.SHARD_ERROR, err, this.id);\n      return;\n    }\n\n    this.manager.client.emit(Events.RAW, packet, this.id);\n    if (packet.op === OPCodes.DISPATCH) this.manager.emit(packet.t, packet.d, this.id);\n    this.onPacket(packet);\n  }\n  /**\n   * Called whenever an error occurs with the WebSocket.\n   * @param {ErrorEvent} event The error that occurred\n   * @private\n   */\n\n\n  onError(event) {\n    const error = event && event.error ? event.error : event;\n    if (!error) return;\n    /**\n     * Emitted whenever a shard's WebSocket encounters a connection error.\n     * @event Client#shardError\n     * @param {Error} error The encountered error\n     * @param {number} shardID The shard that encountered this error\n     */\n\n    this.manager.client.emit(Events.SHARD_ERROR, error, this.id);\n  }\n  /**\n   * @external CloseEvent\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent}\n   */\n\n  /**\n   * @external ErrorEvent\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/ErrorEvent}\n   */\n\n  /**\n   * @external MessageEvent\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/MessageEvent}\n   */\n\n  /**\n   * Called whenever a connection to the gateway is closed.\n   * @param {CloseEvent} event Close event that was received\n   * @private\n   */\n\n\n  onClose(event) {\n    if (this.sequence !== -1) this.closeSequence = this.sequence;\n    this.sequence = -1;\n    this.debug(`[CLOSE]\n    Event Code: ${event.code}\n    Clean     : ${event.wasClean}\n    Reason    : ${event.reason || 'No reason received'}`);\n    this.setHeartbeatTimer(-1);\n    this.setHelloTimeout(-1); // If we still have a connection object, clean up its listeners\n\n    if (this.connection) this._cleanupConnection();\n    this.status = Status.DISCONNECTED;\n    /**\n     * Emitted when a shard's WebSocket closes.\n     * @private\n     * @event WebSocketShard#close\n     * @param {CloseEvent} event The received event\n     */\n\n    this.emit(ShardEvents.CLOSE, event);\n  }\n  /**\n   * Called whenever a packet is received.\n   * @param {Object} packet The received packet\n   * @private\n   */\n\n\n  onPacket(packet) {\n    if (!packet) {\n      this.debug(`Received broken packet: '${packet}'.`);\n      return;\n    }\n\n    switch (packet.t) {\n      case WSEvents.READY:\n        /**\n         * Emitted when the shard receives the READY payload and is now waiting for guilds\n         * @event WebSocketShard#ready\n         */\n        this.emit(ShardEvents.READY);\n        this.sessionID = packet.d.session_id;\n        this.expectedGuilds = new Set(packet.d.guilds.map(d => d.id));\n        this.status = Status.WAITING_FOR_GUILDS;\n        this.debug(`[READY] Session ${this.sessionID}.`);\n        this.lastHeartbeatAcked = true;\n        this.sendHeartbeat('ReadyHeartbeat');\n        break;\n\n      case WSEvents.RESUMED:\n        {\n          /**\n           * Emitted when the shard resumes successfully\n           * @event WebSocketShard#resumed\n           */\n          this.emit(ShardEvents.RESUMED);\n          this.status = Status.READY;\n          const replayed = packet.s - this.closeSequence;\n          this.debug(`[RESUMED] Session ${this.sessionID} | Replayed ${replayed} events.`);\n          this.lastHeartbeatAcked = true;\n          this.sendHeartbeat('ResumeHeartbeat');\n          break;\n        }\n    }\n\n    if (packet.s > this.sequence) this.sequence = packet.s;\n\n    switch (packet.op) {\n      case OPCodes.HELLO:\n        this.setHelloTimeout(-1);\n        this.setHeartbeatTimer(packet.d.heartbeat_interval);\n        this.identify();\n        break;\n\n      case OPCodes.RECONNECT:\n        this.debug('[RECONNECT] Discord asked us to reconnect');\n        this.destroy({\n          closeCode: 4000\n        });\n        break;\n\n      case OPCodes.INVALID_SESSION:\n        this.debug(`[INVALID SESSION] Resumable: ${packet.d}.`); // If we can resume the session, do so immediately\n\n        if (packet.d) {\n          this.identifyResume();\n          return;\n        } // Reset the sequence\n\n\n        this.sequence = -1; // Reset the session ID as it's invalid\n\n        this.sessionID = null; // Set the status to reconnecting\n\n        this.status = Status.RECONNECTING; // Finally, emit the INVALID_SESSION event\n\n        this.emit(ShardEvents.INVALID_SESSION);\n        break;\n\n      case OPCodes.HEARTBEAT_ACK:\n        this.ackHeartbeat();\n        break;\n\n      case OPCodes.HEARTBEAT:\n        this.sendHeartbeat('HeartbeatRequest', true);\n        break;\n\n      default:\n        this.manager.handlePacket(packet, this);\n\n        if (this.status === Status.WAITING_FOR_GUILDS && packet.t === WSEvents.GUILD_CREATE) {\n          this.expectedGuilds.delete(packet.d.id);\n          this.checkReady();\n        }\n\n    }\n  }\n  /**\n   * Checks if the shard can be marked as ready\n   * @private\n   */\n\n\n  checkReady() {\n    // Step 0. Clear the ready timeout, if it exists\n    if (this.readyTimeout) {\n      this.manager.client.clearTimeout(this.readyTimeout);\n      this.readyTimeout = null;\n    } // Step 1. If we don't have any other guilds pending, we are ready\n\n\n    if (!this.expectedGuilds.size) {\n      this.debug('Shard received all its guilds. Marking as fully ready.');\n      this.status = Status.READY;\n      /**\n       * Emitted when the shard is fully ready.\n       * This event is emitted if:\n       * * all guilds were received by this shard\n       * * the ready timeout expired, and some guilds are unavailable\n       * @event WebSocketShard#allReady\n       * @param {?Set<string>} unavailableGuilds Set of unavailable guilds, if any\n       */\n\n      this.emit(ShardEvents.ALL_READY);\n      return;\n    } // Step 2. Create a 15s timeout that will mark the shard as ready if there are still unavailable guilds\n\n\n    this.readyTimeout = this.manager.client.setTimeout(() => {\n      this.debug(`Shard did not receive any more guild packets in 15 seconds.\n  Unavailable guild count: ${this.expectedGuilds.size}`);\n      this.readyTimeout = null;\n      this.status = Status.READY;\n      this.emit(ShardEvents.ALL_READY, this.expectedGuilds);\n    }, 15000);\n  }\n  /**\n   * Sets the HELLO packet timeout.\n   * @param {number} [time] If set to -1, it will clear the hello timeout timeout\n   * @private\n   */\n\n\n  setHelloTimeout(time) {\n    if (time === -1) {\n      if (this.helloTimeout) {\n        this.debug('Clearing the HELLO timeout.');\n        this.manager.client.clearTimeout(this.helloTimeout);\n        this.helloTimeout = null;\n      }\n\n      return;\n    }\n\n    this.debug('Setting a HELLO timeout for 20s.');\n    this.helloTimeout = this.manager.client.setTimeout(() => {\n      this.debug('Did not receive HELLO in time. Destroying and connecting again.');\n      this.destroy({\n        reset: true,\n        closeCode: 4009\n      });\n    }, 20000);\n  }\n  /**\n   * Sets the heartbeat timer for this shard.\n   * @param {number} time If -1, clears the interval, any other number sets an interval\n   * @private\n   */\n\n\n  setHeartbeatTimer(time) {\n    if (time === -1) {\n      if (this.heartbeatInterval) {\n        this.debug('Clearing the heartbeat interval.');\n        this.manager.client.clearInterval(this.heartbeatInterval);\n        this.heartbeatInterval = null;\n      }\n\n      return;\n    }\n\n    this.debug(`Setting a heartbeat interval for ${time}ms.`); // Sanity checks\n\n    if (this.heartbeatInterval) this.manager.client.clearInterval(this.heartbeatInterval);\n    this.heartbeatInterval = this.manager.client.setInterval(() => this.sendHeartbeat(), time);\n  }\n  /**\n   * Sends a heartbeat to the WebSocket.\n   * If this shard didn't receive a heartbeat last time, it will destroy it and reconnect\n   * @param {string} [tag='HeartbeatTimer'] What caused this heartbeat to be sent\n   * @param {boolean} [ignoreHeartbeatAck] If we should send the heartbeat forcefully.\n   * @private\n   */\n\n\n  sendHeartbeat(tag = 'HeartbeatTimer', ignoreHeartbeatAck = [Status.WAITING_FOR_GUILDS, Status.IDENTIFYING, Status.RESUMING].includes(this.status)) {\n    if (ignoreHeartbeatAck && !this.lastHeartbeatAcked) {\n      this.debug(`[${tag}] Didn't process heartbeat ack yet but we are still connected. Sending one now.`);\n    } else if (!this.lastHeartbeatAcked) {\n      this.debug(`[${tag}] Didn't receive a heartbeat ack last time, assuming zombie connection. Destroying and reconnecting.\n    Status          : ${STATUS_KEYS[this.status]}\n    Sequence        : ${this.sequence}\n    Connection State: ${this.connection ? CONNECTION_STATE[this.connection.readyState] : 'No Connection??'}`);\n      this.destroy({\n        closeCode: 4009,\n        reset: true\n      });\n      return;\n    }\n\n    this.debug(`[${tag}] Sending a heartbeat.`);\n    this.lastHeartbeatAcked = false;\n    this.lastPingTimestamp = Date.now();\n    this.send({\n      op: OPCodes.HEARTBEAT,\n      d: this.sequence\n    }, true);\n  }\n  /**\n   * Acknowledges a heartbeat.\n   * @private\n   */\n\n\n  ackHeartbeat() {\n    this.lastHeartbeatAcked = true;\n    const latency = Date.now() - this.lastPingTimestamp;\n    this.debug(`Heartbeat acknowledged, latency of ${latency}ms.`);\n    this.ping = latency;\n  }\n  /**\n   * Identifies the client on the connection.\n   * @private\n   * @returns {void}\n   */\n\n\n  identify() {\n    return this.sessionID ? this.identifyResume() : this.identifyNew();\n  }\n  /**\n   * Identifies as a new connection on the gateway.\n   * @private\n   */\n\n\n  identifyNew() {\n    const {\n      client\n    } = this.manager;\n\n    if (!client.token) {\n      this.debug('[IDENTIFY] No token available to identify a new session.');\n      return;\n    }\n\n    this.status = Status.IDENTIFYING; // Clone the identify payload and assign the token and shard info\n\n    const d = { ...client.options.ws,\n      intents: Intents.resolve(client.options.intents),\n      token: client.token,\n      shard: [this.id, Number(client.options.shardCount)]\n    };\n    this.debug(`[IDENTIFY] Shard ${this.id}/${client.options.shardCount} with intents: ${d.intents}`);\n    this.send({\n      op: OPCodes.IDENTIFY,\n      d\n    }, true);\n  }\n  /**\n   * Resumes a session on the gateway.\n   * @private\n   */\n\n\n  identifyResume() {\n    if (!this.sessionID) {\n      this.debug('[RESUME] No session ID was present; identifying as a new session.');\n      this.identifyNew();\n      return;\n    }\n\n    this.status = Status.RESUMING;\n    this.debug(`[RESUME] Session ${this.sessionID}, sequence ${this.closeSequence}`);\n    const d = {\n      token: this.manager.client.token,\n      session_id: this.sessionID,\n      seq: this.closeSequence\n    };\n    this.send({\n      op: OPCodes.RESUME,\n      d\n    }, true);\n  }\n  /**\n   * Adds a packet to the queue to be sent to the gateway.\n   * <warn>If you use this method, make sure you understand that you need to provide\n   * a full [Payload](https://discord.com/developers/docs/topics/gateway#commands-and-events-gateway-commands).\n   * Do not use this method if you don't know what you're doing.</warn>\n   * @param {Object} data The full packet to send\n   * @param {boolean} [important=false] If this packet should be added first in queue\n   */\n\n\n  send(data, important = false) {\n    this.ratelimit.queue[important ? 'unshift' : 'push'](data);\n    this.processQueue();\n  }\n  /**\n   * Sends data, bypassing the queue.\n   * @param {Object} data Packet to send\n   * @returns {void}\n   * @private\n   */\n\n\n  _send(data) {\n    if (!this.connection || this.connection.readyState !== WebSocket.OPEN) {\n      this.debug(`Tried to send packet '${JSON.stringify(data)}' but no WebSocket is available!`);\n      this.destroy({\n        closeCode: 4000\n      });\n      return;\n    }\n\n    this.connection.send(WebSocket.pack(data), err => {\n      if (err) this.manager.client.emit(Events.SHARD_ERROR, err, this.id);\n    });\n  }\n  /**\n   * Processes the current WebSocket queue.\n   * @returns {void}\n   * @private\n   */\n\n\n  processQueue() {\n    if (this.ratelimit.remaining === 0) return;\n    if (this.ratelimit.queue.length === 0) return;\n\n    if (this.ratelimit.remaining === this.ratelimit.total) {\n      this.ratelimit.timer = this.manager.client.setTimeout(() => {\n        this.ratelimit.remaining = this.ratelimit.total;\n        this.processQueue();\n      }, this.ratelimit.time);\n    }\n\n    while (this.ratelimit.remaining > 0) {\n      const item = this.ratelimit.queue.shift();\n      if (!item) return;\n\n      this._send(item);\n\n      this.ratelimit.remaining--;\n    }\n  }\n  /**\n   * Destroys this shard and closes its WebSocket connection.\n   * @param {Object} [options={ closeCode: 1000, reset: false, emit: true, log: true }] Options for destroying the shard\n   * @private\n   */\n\n\n  destroy({\n    closeCode = 1000,\n    reset = false,\n    emit = true,\n    log = true\n  } = {}) {\n    if (log) {\n      this.debug(`[DESTROY]\n    Close Code    : ${closeCode}\n    Reset         : ${reset}\n    Emit DESTROYED: ${emit}`);\n    } // Step 0: Remove all timers\n\n\n    this.setHeartbeatTimer(-1);\n    this.setHelloTimeout(-1); // Step 1: Close the WebSocket connection, if any, otherwise, emit DESTROYED\n\n    if (this.connection) {\n      // If the connection is currently opened, we will (hopefully) receive close\n      if (this.connection.readyState === WebSocket.OPEN) {\n        this.connection.close(closeCode);\n      } else {\n        // Connection is not OPEN\n        this.debug(`WS State: ${CONNECTION_STATE[this.connection.readyState]}`); // Remove listeners from the connection\n\n        this._cleanupConnection(); // Attempt to close the connection just in case\n\n\n        try {\n          this.connection.close(closeCode);\n        } catch {// No-op\n        } // Emit the destroyed event if needed\n\n\n        if (emit) this._emitDestroyed();\n      }\n    } else if (emit) {\n      // We requested a destroy, but we had no connection. Emit destroyed\n      this._emitDestroyed();\n    } // Step 2: Null the connection object\n\n\n    this.connection = null; // Step 3: Set the shard status to DISCONNECTED\n\n    this.status = Status.DISCONNECTED; // Step 4: Cache the old sequence (use to attempt a resume)\n\n    if (this.sequence !== -1) this.closeSequence = this.sequence; // Step 5: Reset the sequence and session ID if requested\n\n    if (reset) {\n      this.sequence = -1;\n      this.sessionID = null;\n    } // Step 6: reset the ratelimit data\n\n\n    this.ratelimit.remaining = this.ratelimit.total;\n    this.ratelimit.queue.length = 0;\n\n    if (this.ratelimit.timer) {\n      this.manager.client.clearTimeout(this.ratelimit.timer);\n      this.ratelimit.timer = null;\n    }\n  }\n  /**\n   * Cleans up the WebSocket connection listeners.\n   * @private\n   */\n\n\n  _cleanupConnection() {\n    this.connection.onopen = this.connection.onclose = this.connection.onerror = this.connection.onmessage = null;\n  }\n  /**\n   * Emits the DESTROYED event on the shard\n   * @private\n   */\n\n\n  _emitDestroyed() {\n    /**\n     * Emitted when a shard is destroyed, but no WebSocket connection was present.\n     * @private\n     * @event WebSocketShard#destroyed\n     */\n    this.emit(ShardEvents.DESTROYED);\n  }\n\n}\n\nmodule.exports = WebSocketShard;\n\n//# sourceURL=webpack://Fosscord/./src/client/websocket/WebSocketShard.js?")},"./src/client/websocket/handlers sync recursive ^\\.\\/.*\\.js$":function(module,exports,__webpack_require__){eval('var map = {\n\t"./APPLICATION_COMMAND_CREATE.js": "./src/client/websocket/handlers/APPLICATION_COMMAND_CREATE.js",\n\t"./APPLICATION_COMMAND_DELETE.js": "./src/client/websocket/handlers/APPLICATION_COMMAND_DELETE.js",\n\t"./APPLICATION_COMMAND_UPDATE.js": "./src/client/websocket/handlers/APPLICATION_COMMAND_UPDATE.js",\n\t"./CHANNEL_CREATE.js": "./src/client/websocket/handlers/CHANNEL_CREATE.js",\n\t"./CHANNEL_DELETE.js": "./src/client/websocket/handlers/CHANNEL_DELETE.js",\n\t"./CHANNEL_PINS_UPDATE.js": "./src/client/websocket/handlers/CHANNEL_PINS_UPDATE.js",\n\t"./CHANNEL_UPDATE.js": "./src/client/websocket/handlers/CHANNEL_UPDATE.js",\n\t"./GUILD_BAN_ADD.js": "./src/client/websocket/handlers/GUILD_BAN_ADD.js",\n\t"./GUILD_BAN_REMOVE.js": "./src/client/websocket/handlers/GUILD_BAN_REMOVE.js",\n\t"./GUILD_CREATE.js": "./src/client/websocket/handlers/GUILD_CREATE.js",\n\t"./GUILD_DELETE.js": "./src/client/websocket/handlers/GUILD_DELETE.js",\n\t"./GUILD_EMOJIS_UPDATE.js": "./src/client/websocket/handlers/GUILD_EMOJIS_UPDATE.js",\n\t"./GUILD_INTEGRATIONS_UPDATE.js": "./src/client/websocket/handlers/GUILD_INTEGRATIONS_UPDATE.js",\n\t"./GUILD_MEMBERS_CHUNK.js": "./src/client/websocket/handlers/GUILD_MEMBERS_CHUNK.js",\n\t"./GUILD_MEMBER_ADD.js": "./src/client/websocket/handlers/GUILD_MEMBER_ADD.js",\n\t"./GUILD_MEMBER_REMOVE.js": "./src/client/websocket/handlers/GUILD_MEMBER_REMOVE.js",\n\t"./GUILD_MEMBER_UPDATE.js": "./src/client/websocket/handlers/GUILD_MEMBER_UPDATE.js",\n\t"./GUILD_ROLE_CREATE.js": "./src/client/websocket/handlers/GUILD_ROLE_CREATE.js",\n\t"./GUILD_ROLE_DELETE.js": "./src/client/websocket/handlers/GUILD_ROLE_DELETE.js",\n\t"./GUILD_ROLE_UPDATE.js": "./src/client/websocket/handlers/GUILD_ROLE_UPDATE.js",\n\t"./GUILD_UPDATE.js": "./src/client/websocket/handlers/GUILD_UPDATE.js",\n\t"./INTERACTION_CREATE.js": "./src/client/websocket/handlers/INTERACTION_CREATE.js",\n\t"./INVITE_CREATE.js": "./src/client/websocket/handlers/INVITE_CREATE.js",\n\t"./INVITE_DELETE.js": "./src/client/websocket/handlers/INVITE_DELETE.js",\n\t"./MESSAGE_CREATE.js": "./src/client/websocket/handlers/MESSAGE_CREATE.js",\n\t"./MESSAGE_DELETE.js": "./src/client/websocket/handlers/MESSAGE_DELETE.js",\n\t"./MESSAGE_DELETE_BULK.js": "./src/client/websocket/handlers/MESSAGE_DELETE_BULK.js",\n\t"./MESSAGE_REACTION_ADD.js": "./src/client/websocket/handlers/MESSAGE_REACTION_ADD.js",\n\t"./MESSAGE_REACTION_REMOVE.js": "./src/client/websocket/handlers/MESSAGE_REACTION_REMOVE.js",\n\t"./MESSAGE_REACTION_REMOVE_ALL.js": "./src/client/websocket/handlers/MESSAGE_REACTION_REMOVE_ALL.js",\n\t"./MESSAGE_REACTION_REMOVE_EMOJI.js": "./src/client/websocket/handlers/MESSAGE_REACTION_REMOVE_EMOJI.js",\n\t"./MESSAGE_UPDATE.js": "./src/client/websocket/handlers/MESSAGE_UPDATE.js",\n\t"./PRESENCE_UPDATE.js": "./src/client/websocket/handlers/PRESENCE_UPDATE.js",\n\t"./READY.js": "./src/client/websocket/handlers/READY.js",\n\t"./RESUMED.js": "./src/client/websocket/handlers/RESUMED.js",\n\t"./STAGE_INSTANCE_CREATE.js": "./src/client/websocket/handlers/STAGE_INSTANCE_CREATE.js",\n\t"./STAGE_INSTANCE_DELETE.js": "./src/client/websocket/handlers/STAGE_INSTANCE_DELETE.js",\n\t"./STAGE_INSTANCE_UPDATE.js": "./src/client/websocket/handlers/STAGE_INSTANCE_UPDATE.js",\n\t"./THREAD_CREATE.js": "./src/client/websocket/handlers/THREAD_CREATE.js",\n\t"./THREAD_DELETE.js": "./src/client/websocket/handlers/THREAD_DELETE.js",\n\t"./THREAD_LIST_SYNC.js": "./src/client/websocket/handlers/THREAD_LIST_SYNC.js",\n\t"./THREAD_MEMBERS_UPDATE.js": "./src/client/websocket/handlers/THREAD_MEMBERS_UPDATE.js",\n\t"./THREAD_MEMBER_UPDATE.js": "./src/client/websocket/handlers/THREAD_MEMBER_UPDATE.js",\n\t"./THREAD_UPDATE.js": "./src/client/websocket/handlers/THREAD_UPDATE.js",\n\t"./TYPING_START.js": "./src/client/websocket/handlers/TYPING_START.js",\n\t"./USER_UPDATE.js": "./src/client/websocket/handlers/USER_UPDATE.js",\n\t"./VOICE_SERVER_UPDATE.js": "./src/client/websocket/handlers/VOICE_SERVER_UPDATE.js",\n\t"./VOICE_STATE_UPDATE.js": "./src/client/websocket/handlers/VOICE_STATE_UPDATE.js",\n\t"./WEBHOOKS_UPDATE.js": "./src/client/websocket/handlers/WEBHOOKS_UPDATE.js",\n\t"./index.js": "./src/client/websocket/handlers/index.js"\n};\n\n\nfunction webpackContext(req) {\n\tvar id = webpackContextResolve(req);\n\treturn __webpack_require__(id);\n}\nfunction webpackContextResolve(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\tvar e = new Error("Cannot find module \'" + req + "\'");\n\t\te.code = \'MODULE_NOT_FOUND\';\n\t\tthrow e;\n\t}\n\treturn map[req];\n}\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = "./src/client/websocket/handlers sync recursive ^\\\\.\\\\/.*\\\\.js$";\n\n//# sourceURL=webpack://Fosscord/./src/client/websocket/handlers_sync_^\\.\\/.*\\.js$?')},"./src/client/websocket/handlers/APPLICATION_COMMAND_CREATE.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nconst {\n  Events\n} = __webpack_require__(/*! ../../../util/Constants */ "./src/util/Constants.js");\n\nmodule.exports = (client, {\n  d: data\n}) => {\n  let command;\n\n  if (data.guild_id) {\n    const guild = client.guilds.cache.get(data.guild_id);\n    if (!guild) return;\n    command = guild.commands.add(data);\n  } else {\n    command = client.application.commands.add(data);\n  }\n  /**\n   * Emitted when an application command is created.\n   * @event Client#applicationCommandCreate\n   * @param {ApplicationCommand} command The command which was created\n   */\n\n\n  client.emit(Events.APPLICATION_COMMAND_CREATE, command);\n};\n\n//# sourceURL=webpack://Fosscord/./src/client/websocket/handlers/APPLICATION_COMMAND_CREATE.js?')},"./src/client/websocket/handlers/APPLICATION_COMMAND_DELETE.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nconst {\n  Events\n} = __webpack_require__(/*! ../../../util/Constants */ "./src/util/Constants.js");\n\nmodule.exports = (client, {\n  d: data\n}) => {\n  let command;\n\n  if (data.guild_id) {\n    const guild = client.guilds.cache.get(data.guild_id);\n    if (!guild) return;\n    command = guild.commands.add(data);\n    guild.commands.cache.delete(data.id);\n  } else {\n    command = client.application.commands.add(data);\n    client.application.commands.cache.delete(data.id);\n  }\n  /**\n   * Emitted when an application command is deleted.\n   * @event Client#applicationCommandDelete\n   * @param {ApplicationCommand} command The command which was deleted\n   */\n\n\n  client.emit(Events.APPLICATION_COMMAND_DELETE, command);\n};\n\n//# sourceURL=webpack://Fosscord/./src/client/websocket/handlers/APPLICATION_COMMAND_DELETE.js?')},"./src/client/websocket/handlers/APPLICATION_COMMAND_UPDATE.js":function(module,exports){eval('throw new Error("Module parse failed: Unexpected token (16:51)\\nFile was processed with these loaders:\\n * ./node_modules/babel-loader/lib/index.js\\nYou may need an additional loader to handle the result of these loaders.\\n|     const guild = client.guilds.cache.get(data.guild_id);\\n|     if (!guild) return;\\n>     oldCommand = guild.commands.cache.get(data.id)?._clone() ?? null;\\n|     newCommand = guild.commands.add(data);\\n|   } else {");\n\n//# sourceURL=webpack://Fosscord/./src/client/websocket/handlers/APPLICATION_COMMAND_UPDATE.js?')},"./src/client/websocket/handlers/CHANNEL_CREATE.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nmodule.exports = (client, packet) => {\n  client.actions.ChannelCreate.handle(packet.d);\n};\n\n//# sourceURL=webpack://Fosscord/./src/client/websocket/handlers/CHANNEL_CREATE.js?")},"./src/client/websocket/handlers/CHANNEL_DELETE.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nmodule.exports = (client, packet) => {\n  client.actions.ChannelDelete.handle(packet.d);\n};\n\n//# sourceURL=webpack://Fosscord/./src/client/websocket/handlers/CHANNEL_DELETE.js?")},"./src/client/websocket/handlers/CHANNEL_PINS_UPDATE.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nconst {\n  Events\n} = __webpack_require__(/*! ../../../util/Constants */ "./src/util/Constants.js");\n\nmodule.exports = (client, {\n  d: data\n}) => {\n  const channel = client.channels.cache.get(data.channel_id);\n  const time = new Date(data.last_pin_timestamp);\n\n  if (channel && !Number.isNaN(time.getTime())) {\n    // Discord sends null for last_pin_timestamp if the last pinned message was removed\n    channel.lastPinTimestamp = time.getTime() || null;\n    /**\n     * Emitted whenever the pins of a channel are updated. Due to the nature of the WebSocket event,\n     * not much information can be provided easily here - you need to manually check the pins yourself.\n     * @event Client#channelPinsUpdate\n     * @param {DMChannel|TextChannel|NewsChannel} channel The channel that the pins update occurred in\n     * @param {Date} time The time of the pins update\n     */\n\n    client.emit(Events.CHANNEL_PINS_UPDATE, channel, time);\n  }\n};\n\n//# sourceURL=webpack://Fosscord/./src/client/websocket/handlers/CHANNEL_PINS_UPDATE.js?')},"./src/client/websocket/handlers/CHANNEL_UPDATE.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nconst {\n  Events\n} = __webpack_require__(/*! ../../../util/Constants */ "./src/util/Constants.js");\n\nmodule.exports = (client, packet) => {\n  const {\n    old,\n    updated\n  } = client.actions.ChannelUpdate.handle(packet.d);\n\n  if (old && updated) {\n    /**\n     * Emitted whenever a channel is updated - e.g. name change, topic change, channel type change.\n     * @event Client#channelUpdate\n     * @param {DMChannel|GuildChannel} oldChannel The channel before the update\n     * @param {DMChannel|GuildChannel} newChannel The channel after the update\n     */\n    client.emit(Events.CHANNEL_UPDATE, old, updated);\n  }\n};\n\n//# sourceURL=webpack://Fosscord/./src/client/websocket/handlers/CHANNEL_UPDATE.js?')},"./src/client/websocket/handlers/GUILD_BAN_ADD.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nmodule.exports = (client, packet) => {\n  client.actions.GuildBanAdd.handle(packet.d);\n};\n\n//# sourceURL=webpack://Fosscord/./src/client/websocket/handlers/GUILD_BAN_ADD.js?")},"./src/client/websocket/handlers/GUILD_BAN_REMOVE.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nmodule.exports = (client, packet) => {\n  client.actions.GuildBanRemove.handle(packet.d);\n};\n\n//# sourceURL=webpack://Fosscord/./src/client/websocket/handlers/GUILD_BAN_REMOVE.js?")},"./src/client/websocket/handlers/GUILD_CREATE.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nconst {\n  Events,\n  Status\n} = __webpack_require__(/*! ../../../util/Constants */ "./src/util/Constants.js");\n\nmodule.exports = (client, {\n  d: data\n}, shard) => {\n  let guild = client.guilds.cache.get(data.id);\n\n  if (guild) {\n    if (!guild.available && !data.unavailable) {\n      // A newly available guild\n      guild._patch(data);\n    }\n  } else {\n    // A new guild\n    data.shardID = shard.id;\n    guild = client.guilds.add(data);\n\n    if (client.ws.status === Status.READY) {\n      /**\n       * Emitted whenever the client joins a guild.\n       * @event Client#guildCreate\n       * @param {Guild} guild The created guild\n       */\n      client.emit(Events.GUILD_CREATE, guild);\n    }\n  }\n};\n\n//# sourceURL=webpack://Fosscord/./src/client/websocket/handlers/GUILD_CREATE.js?')},"./src/client/websocket/handlers/GUILD_DELETE.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nmodule.exports = (client, packet) => {\n  client.actions.GuildDelete.handle(packet.d);\n};\n\n//# sourceURL=webpack://Fosscord/./src/client/websocket/handlers/GUILD_DELETE.js?")},"./src/client/websocket/handlers/GUILD_EMOJIS_UPDATE.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nmodule.exports = (client, packet) => {\n  client.actions.GuildEmojisUpdate.handle(packet.d);\n};\n\n//# sourceURL=webpack://Fosscord/./src/client/websocket/handlers/GUILD_EMOJIS_UPDATE.js?")},"./src/client/websocket/handlers/GUILD_INTEGRATIONS_UPDATE.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nmodule.exports = (client, packet) => {\n  client.actions.GuildIntegrationsUpdate.handle(packet.d);\n};\n\n//# sourceURL=webpack://Fosscord/./src/client/websocket/handlers/GUILD_INTEGRATIONS_UPDATE.js?")},"./src/client/websocket/handlers/GUILD_MEMBERS_CHUNK.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nconst Collection = __webpack_require__(/*! ../../../util/Collection */ "./src/util/Collection.js");\n\nconst {\n  Events\n} = __webpack_require__(/*! ../../../util/Constants */ "./src/util/Constants.js");\n\nmodule.exports = (client, {\n  d: data\n}) => {\n  const guild = client.guilds.cache.get(data.guild_id);\n  if (!guild) return;\n  const members = new Collection();\n\n  for (const member of data.members) members.set(member.user.id, guild.members.add(member));\n\n  if (data.presences) {\n    for (const presence of data.presences) guild.presences.add(Object.assign(presence, {\n      guild\n    }));\n  }\n  /**\n   * Emitted whenever a chunk of guild members is received (all members come from the same guild).\n   * @event Client#guildMembersChunk\n   * @param {Collection<Snowflake, GuildMember>} members The members in the chunk\n   * @param {Guild} guild The guild related to the member chunk\n   * @param {Object} chunk Properties of the received chunk\n   * @param {number} chunk.index Index of the received chunk\n   * @param {number} chunk.count Number of chunks the client should receive\n   * @param {?string} chunk.nonce Nonce for this chunk\n   */\n\n\n  client.emit(Events.GUILD_MEMBERS_CHUNK, members, guild, {\n    count: data.chunk_count,\n    index: data.chunk_index,\n    nonce: data.nonce\n  });\n};\n\n//# sourceURL=webpack://Fosscord/./src/client/websocket/handlers/GUILD_MEMBERS_CHUNK.js?')},"./src/client/websocket/handlers/GUILD_MEMBER_ADD.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nconst {\n  Events,\n  Status\n} = __webpack_require__(/*! ../../../util/Constants */ "./src/util/Constants.js");\n\nmodule.exports = (client, {\n  d: data\n}, shard) => {\n  const guild = client.guilds.cache.get(data.guild_id);\n\n  if (guild) {\n    guild.memberCount++;\n    const member = guild.members.add(data);\n\n    if (shard.status === Status.READY) {\n      /**\n       * Emitted whenever a user joins a guild.\n       * @event Client#guildMemberAdd\n       * @param {GuildMember} member The member that has joined a guild\n       */\n      client.emit(Events.GUILD_MEMBER_ADD, member);\n    }\n  }\n};\n\n//# sourceURL=webpack://Fosscord/./src/client/websocket/handlers/GUILD_MEMBER_ADD.js?')},"./src/client/websocket/handlers/GUILD_MEMBER_REMOVE.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nmodule.exports = (client, packet, shard) => {\n  client.actions.GuildMemberRemove.handle(packet.d, shard);\n};\n\n//# sourceURL=webpack://Fosscord/./src/client/websocket/handlers/GUILD_MEMBER_REMOVE.js?")},"./src/client/websocket/handlers/GUILD_MEMBER_UPDATE.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nmodule.exports = (client, packet, shard) => {\n  client.actions.GuildMemberUpdate.handle(packet.d, shard);\n};\n\n//# sourceURL=webpack://Fosscord/./src/client/websocket/handlers/GUILD_MEMBER_UPDATE.js?")},"./src/client/websocket/handlers/GUILD_ROLE_CREATE.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nmodule.exports = (client, packet) => {\n  client.actions.GuildRoleCreate.handle(packet.d);\n};\n\n//# sourceURL=webpack://Fosscord/./src/client/websocket/handlers/GUILD_ROLE_CREATE.js?")},"./src/client/websocket/handlers/GUILD_ROLE_DELETE.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nmodule.exports = (client, packet) => {\n  client.actions.GuildRoleDelete.handle(packet.d);\n};\n\n//# sourceURL=webpack://Fosscord/./src/client/websocket/handlers/GUILD_ROLE_DELETE.js?")},"./src/client/websocket/handlers/GUILD_ROLE_UPDATE.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nmodule.exports = (client, packet) => {\n  client.actions.GuildRoleUpdate.handle(packet.d);\n};\n\n//# sourceURL=webpack://Fosscord/./src/client/websocket/handlers/GUILD_ROLE_UPDATE.js?")},"./src/client/websocket/handlers/GUILD_UPDATE.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nmodule.exports = (client, packet) => {\n  client.actions.GuildUpdate.handle(packet.d);\n};\n\n//# sourceURL=webpack://Fosscord/./src/client/websocket/handlers/GUILD_UPDATE.js?")},"./src/client/websocket/handlers/INTERACTION_CREATE.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nmodule.exports = (client, packet) => {\n  client.actions.InteractionCreate.handle(packet.d);\n};\n\n//# sourceURL=webpack://Fosscord/./src/client/websocket/handlers/INTERACTION_CREATE.js?")},"./src/client/websocket/handlers/INVITE_CREATE.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nmodule.exports = (client, packet) => {\n  client.actions.InviteCreate.handle(packet.d);\n};\n\n//# sourceURL=webpack://Fosscord/./src/client/websocket/handlers/INVITE_CREATE.js?")},"./src/client/websocket/handlers/INVITE_DELETE.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nmodule.exports = (client, packet) => {\n  client.actions.InviteDelete.handle(packet.d);\n};\n\n//# sourceURL=webpack://Fosscord/./src/client/websocket/handlers/INVITE_DELETE.js?")},"./src/client/websocket/handlers/MESSAGE_CREATE.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nmodule.exports = (client, packet) => {\n  client.actions.MessageCreate.handle(packet.d);\n};\n\n//# sourceURL=webpack://Fosscord/./src/client/websocket/handlers/MESSAGE_CREATE.js?")},"./src/client/websocket/handlers/MESSAGE_DELETE.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nmodule.exports = (client, packet) => {\n  client.actions.MessageDelete.handle(packet.d);\n};\n\n//# sourceURL=webpack://Fosscord/./src/client/websocket/handlers/MESSAGE_DELETE.js?")},"./src/client/websocket/handlers/MESSAGE_DELETE_BULK.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nmodule.exports = (client, packet) => {\n  client.actions.MessageDeleteBulk.handle(packet.d);\n};\n\n//# sourceURL=webpack://Fosscord/./src/client/websocket/handlers/MESSAGE_DELETE_BULK.js?")},"./src/client/websocket/handlers/MESSAGE_REACTION_ADD.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nmodule.exports = (client, packet) => {\n  client.actions.MessageReactionAdd.handle(packet.d);\n};\n\n//# sourceURL=webpack://Fosscord/./src/client/websocket/handlers/MESSAGE_REACTION_ADD.js?")},"./src/client/websocket/handlers/MESSAGE_REACTION_REMOVE.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nmodule.exports = (client, packet) => {\n  client.actions.MessageReactionRemove.handle(packet.d);\n};\n\n//# sourceURL=webpack://Fosscord/./src/client/websocket/handlers/MESSAGE_REACTION_REMOVE.js?")},"./src/client/websocket/handlers/MESSAGE_REACTION_REMOVE_ALL.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nmodule.exports = (client, packet) => {\n  client.actions.MessageReactionRemoveAll.handle(packet.d);\n};\n\n//# sourceURL=webpack://Fosscord/./src/client/websocket/handlers/MESSAGE_REACTION_REMOVE_ALL.js?")},"./src/client/websocket/handlers/MESSAGE_REACTION_REMOVE_EMOJI.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nmodule.exports = (client, packet) => {\n  client.actions.MessageReactionRemoveEmoji.handle(packet.d);\n};\n\n//# sourceURL=webpack://Fosscord/./src/client/websocket/handlers/MESSAGE_REACTION_REMOVE_EMOJI.js?")},"./src/client/websocket/handlers/MESSAGE_UPDATE.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nconst {\n  Events\n} = __webpack_require__(/*! ../../../util/Constants */ "./src/util/Constants.js");\n\nmodule.exports = (client, packet) => {\n  const {\n    old,\n    updated\n  } = client.actions.MessageUpdate.handle(packet.d);\n\n  if (old && updated) {\n    /**\n     * Emitted whenever a message is updated - e.g. embed or content change.\n     * @event Client#messageUpdate\n     * @param {Message} oldMessage The message before the update\n     * @param {Message} newMessage The message after the update\n     */\n    client.emit(Events.MESSAGE_UPDATE, old, updated);\n  }\n};\n\n//# sourceURL=webpack://Fosscord/./src/client/websocket/handlers/MESSAGE_UPDATE.js?')},"./src/client/websocket/handlers/PRESENCE_UPDATE.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nmodule.exports = (client, packet) => {\n  client.actions.PresenceUpdate.handle(packet.d);\n};\n\n//# sourceURL=webpack://Fosscord/./src/client/websocket/handlers/PRESENCE_UPDATE.js?")},"./src/client/websocket/handlers/READY.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nconst ClientApplication = __webpack_require__(/*! ../../../structures/ClientApplication */ "./src/structures/ClientApplication.js");\n\nlet ClientUser;\n\nmodule.exports = (client, {\n  d: data\n}, shard) => {\n  if (client.user) {\n    client.user._patch(data.user);\n  } else {\n    if (!ClientUser) ClientUser = __webpack_require__(/*! ../../../structures/ClientUser */ "./src/structures/ClientUser.js");\n    client.user = new ClientUser(client, data.user);\n    client.users.cache.set(client.user.id, client.user);\n  }\n\n  for (const guild of data.guilds) {\n    guild.shardID = shard.id;\n    client.guilds.add(guild);\n  }\n\n  if (client.application) {\n    client.application._patch(data.application);\n  } else {\n    client.application = new ClientApplication(client, data.application);\n  }\n\n  shard.checkReady();\n};\n\n//# sourceURL=webpack://Fosscord/./src/client/websocket/handlers/READY.js?')},"./src/client/websocket/handlers/RESUMED.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nconst {\n  Events\n} = __webpack_require__(/*! ../../../util/Constants */ "./src/util/Constants.js");\n\nmodule.exports = (client, packet, shard) => {\n  const replayed = shard.sequence - shard.closeSequence;\n  /**\n   * Emitted when a shard resumes successfully.\n   * @event Client#shardResume\n   * @param {number} id The shard ID that resumed\n   * @param {number} replayedEvents The amount of replayed events\n   */\n\n  client.emit(Events.SHARD_RESUME, shard.id, replayed);\n};\n\n//# sourceURL=webpack://Fosscord/./src/client/websocket/handlers/RESUMED.js?')},"./src/client/websocket/handlers/STAGE_INSTANCE_CREATE.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nmodule.exports = (client, packet) => {\n  client.actions.StageInstanceCreate.handle(packet.d);\n};\n\n//# sourceURL=webpack://Fosscord/./src/client/websocket/handlers/STAGE_INSTANCE_CREATE.js?")},"./src/client/websocket/handlers/STAGE_INSTANCE_DELETE.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nmodule.exports = (client, packet) => {\n  client.actions.StageInstanceDelete.handle(packet.d);\n};\n\n//# sourceURL=webpack://Fosscord/./src/client/websocket/handlers/STAGE_INSTANCE_DELETE.js?")},"./src/client/websocket/handlers/STAGE_INSTANCE_UPDATE.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nmodule.exports = (client, packet) => {\n  client.actions.StageInstanceUpdate.handle(packet.d);\n};\n\n//# sourceURL=webpack://Fosscord/./src/client/websocket/handlers/STAGE_INSTANCE_UPDATE.js?")},"./src/client/websocket/handlers/THREAD_CREATE.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nmodule.exports = (client, packet) => {\n  client.actions.ThreadCreate.handle(packet.d);\n};\n\n//# sourceURL=webpack://Fosscord/./src/client/websocket/handlers/THREAD_CREATE.js?")},"./src/client/websocket/handlers/THREAD_DELETE.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nmodule.exports = (client, packet) => {\n  client.actions.ThreadDelete.handle(packet.d);\n};\n\n//# sourceURL=webpack://Fosscord/./src/client/websocket/handlers/THREAD_DELETE.js?")},"./src/client/websocket/handlers/THREAD_LIST_SYNC.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nmodule.exports = (client, packet) => {\n  client.actions.ThreadListSync.handle(packet.d);\n};\n\n//# sourceURL=webpack://Fosscord/./src/client/websocket/handlers/THREAD_LIST_SYNC.js?")},"./src/client/websocket/handlers/THREAD_MEMBERS_UPDATE.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nmodule.exports = (client, packet) => {\n  client.actions.ThreadMembersUpdate.handle(packet.d);\n};\n\n//# sourceURL=webpack://Fosscord/./src/client/websocket/handlers/THREAD_MEMBERS_UPDATE.js?")},"./src/client/websocket/handlers/THREAD_MEMBER_UPDATE.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nmodule.exports = (client, packet) => {\n  client.actions.ThreadMemberUpdate.handle(packet.d);\n};\n\n//# sourceURL=webpack://Fosscord/./src/client/websocket/handlers/THREAD_MEMBER_UPDATE.js?")},"./src/client/websocket/handlers/THREAD_UPDATE.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nconst {\n  Events\n} = __webpack_require__(/*! ../../../util/Constants */ "./src/util/Constants.js");\n\nmodule.exports = (client, packet) => {\n  const {\n    old,\n    updated\n  } = client.actions.ChannelUpdate.handle(packet.d);\n\n  if (old && updated) {\n    /**\n     * Emitted whenever a thread is updated - e.g. name change, archive state change, locked state change.\n     * @event Client#threadUpdate\n     * @param {ThreadChannel} oldThread The thread before the update\n     * @param {ThreadChannel} newThread The thread after the update\n     */\n    client.emit(Events.THREAD_UPDATE, old, updated);\n  }\n};\n\n//# sourceURL=webpack://Fosscord/./src/client/websocket/handlers/THREAD_UPDATE.js?')},"./src/client/websocket/handlers/TYPING_START.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nmodule.exports = (client, packet) => {\n  client.actions.TypingStart.handle(packet.d);\n};\n\n//# sourceURL=webpack://Fosscord/./src/client/websocket/handlers/TYPING_START.js?")},"./src/client/websocket/handlers/USER_UPDATE.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nmodule.exports = (client, packet) => {\n  client.actions.UserUpdate.handle(packet.d);\n};\n\n//# sourceURL=webpack://Fosscord/./src/client/websocket/handlers/USER_UPDATE.js?")},"./src/client/websocket/handlers/VOICE_SERVER_UPDATE.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nmodule.exports = (client, packet) => {\n  client.emit('debug', `[VOICE] received voice server: ${JSON.stringify(packet)}`);\n  client.voice.onVoiceServer(packet.d);\n};\n\n//# sourceURL=webpack://Fosscord/./src/client/websocket/handlers/VOICE_SERVER_UPDATE.js?")},"./src/client/websocket/handlers/VOICE_STATE_UPDATE.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nmodule.exports = (client, packet) => {\n  client.actions.VoiceStateUpdate.handle(packet.d);\n};\n\n//# sourceURL=webpack://Fosscord/./src/client/websocket/handlers/VOICE_STATE_UPDATE.js?")},"./src/client/websocket/handlers/WEBHOOKS_UPDATE.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nmodule.exports = (client, packet) => {\n  client.actions.WebhooksUpdate.handle(packet.d);\n};\n\n//# sourceURL=webpack://Fosscord/./src/client/websocket/handlers/WEBHOOKS_UPDATE.js?")},"./src/client/websocket/handlers/index.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nconst {\n  WSEvents\n} = __webpack_require__(/*! ../../../util/Constants */ "./src/util/Constants.js");\n\nconst handlers = {};\n\nfor (const name of Object.keys(WSEvents)) {\n  handlers[name] = __webpack_require__("./src/client/websocket/handlers sync recursive ^\\\\.\\\\/.*\\\\.js$")(`./${name}.js`);\n}\n\nmodule.exports = handlers;\n\n//# sourceURL=webpack://Fosscord/./src/client/websocket/handlers/index.js?')},"./src/errors/DJSError.js":function(module,exports,__webpack_require__){"use strict";eval(" // Heavily inspired by node's `internal/errors` module\n\nconst kCode = Symbol('code');\nconst messages = new Map();\n/**\n * Extend an error of some sort into a DiscordjsError.\n * @param {Error} Base Base error to extend\n * @returns {DiscordjsError}\n */\n\nfunction makeDiscordjsError(Base) {\n  return class DiscordjsError extends Base {\n    constructor(key, ...args) {\n      super(message(key, args));\n      this[kCode] = key;\n      if (Error.captureStackTrace) Error.captureStackTrace(this, DiscordjsError);\n    }\n\n    get name() {\n      return `${super.name} [${this[kCode]}]`;\n    }\n\n    get code() {\n      return this[kCode];\n    }\n\n  };\n}\n/**\n * Format the message for an error.\n * @param {string} key Error key\n * @param {Array<*>} args Arguments to pass for util format or as function args\n * @returns {string} Formatted string\n */\n\n\nfunction message(key, args) {\n  if (typeof key !== 'string') throw new Error('Error message key must be a string');\n  const msg = messages.get(key);\n  if (!msg) throw new Error(`An invalid error message key was used: ${key}.`);\n  if (typeof msg === 'function') return msg(...args);\n  if (args === undefined || args.length === 0) return msg;\n  args.unshift(msg);\n  return String(...args);\n}\n/**\n * Register an error code and message.\n * @param {string} sym Unique name for the error\n * @param {*} val Value of the error\n */\n\n\nfunction register(sym, val) {\n  messages.set(sym, typeof val === 'function' ? val : String(val));\n}\n\nmodule.exports = {\n  register,\n  Error: makeDiscordjsError(Error),\n  TypeError: makeDiscordjsError(TypeError),\n  RangeError: makeDiscordjsError(RangeError)\n};\n\n//# sourceURL=webpack://Fosscord/./src/errors/DJSError.js?")},"./src/errors/Messages.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nconst {\n  register\n} = __webpack_require__(/*! ./DJSError */ \"./src/errors/DJSError.js\");\n\nconst Messages = {\n  CLIENT_INVALID_OPTION: (prop, must) => `The ${prop} option must be ${must}`,\n  CLIENT_INVALID_PROVIDED_SHARDS: 'None of the provided shards were valid.',\n  CLIENT_MISSING_INTENTS: 'Valid intents must be provided for the Client.',\n  CLIENT_NOT_READY: action => `The client needs to be logged in to ${action}.`,\n  TOKEN_INVALID: 'An invalid token was provided.',\n  TOKEN_MISSING: 'Request to use token, but token was unavailable to the client.',\n  WS_CLOSE_REQUESTED: 'WebSocket closed due to user request.',\n  WS_CONNECTION_EXISTS: 'There is already an existing WebSocket connection.',\n  WS_NOT_OPEN: (data = 'data') => `Websocket not open to send ${data}`,\n  MANAGER_DESTROYED: 'Manager was destroyed.',\n  BITFIELD_INVALID: bit => `Invalid bitfield flag or number: ${bit}.`,\n  SHARDING_INVALID: 'Invalid shard settings were provided.',\n  SHARDING_REQUIRED: 'This session would have handled too many guilds - Sharding is required.',\n  INVALID_INTENTS: 'Invalid intent provided for WebSocket intents.',\n  DISALLOWED_INTENTS: 'Privileged intent provided is not enabled or whitelisted.',\n  SHARDING_NO_SHARDS: 'No shards have been spawned.',\n  SHARDING_IN_PROCESS: 'Shards are still being spawned.',\n  SHARDING_INVALID_EVAL_BROADCAST: 'Script to evaluate must be a function',\n  SHARDING_SHARD_NOT_FOUND: id => `Shard ${id} could not be found.`,\n  SHARDING_ALREADY_SPAWNED: count => `Already spawned ${count} shards.`,\n  SHARDING_PROCESS_EXISTS: id => `Shard ${id} already has an active process.`,\n  SHARDING_WORKER_EXISTS: id => `Shard ${id} already has an active worker.`,\n  SHARDING_READY_TIMEOUT: id => `Shard ${id}'s Client took too long to become ready.`,\n  SHARDING_READY_DISCONNECTED: id => `Shard ${id}'s Client disconnected before becoming ready.`,\n  SHARDING_READY_DIED: id => `Shard ${id}'s process exited before its Client became ready.`,\n  SHARDING_NO_CHILD_EXISTS: id => `Shard ${id} has no active process or worker.`,\n  SHARDING_SHARD_MISCALCULATION: (shard, guild, count) => `Calculated invalid shard ${shard} for guild ${guild} with ${count} shards.`,\n  COLOR_RANGE: 'Color must be within the range 0 - 16777215 (0xFFFFFF).',\n  COLOR_CONVERT: 'Unable to convert color to a number.',\n  EMBED_TITLE: 'MessageEmbed title must be a string.',\n  EMBED_FIELD_NAME: 'MessageEmbed field names must be non-empty strings.',\n  EMBED_FIELD_VALUE: 'MessageEmbed field values must be non-empty strings.',\n  EMBED_FOOTER_TEXT: 'MessageEmbed footer text must be a string.',\n  EMBED_DESCRIPTION: 'MessageEmbed description must be a string.',\n  EMBED_AUTHOR_NAME: 'MessageEmbed author name must be a string.',\n  BUTTON_LABEL: 'MessageButton label must be a string',\n  BUTTON_URL: 'MessageButton url must be a string',\n  BUTTON_CUSTOM_ID: 'MessageButton customID must be a string',\n  SELECT_MENU_CUSTOM_ID: 'MessageSelectMenu customID must be a string',\n  SELECT_MENU_PLACEHOLDER: 'MessageSelectMenu placeholder must be a string',\n  SELECT_OPTION_LABEL: 'MessageSelectOption label must be a string',\n  SELECT_OPTION_VALUE: 'MessageSelectOption value must be a string',\n  SELECT_OPTION_DESCRIPTION: 'MessageSelectOption description must be a string',\n  INTERACTION_COLLECTOR_ERROR: reason => `Collector received no interactions before ending with reason: ${reason}`,\n  FILE_NOT_FOUND: file => `File could not be found: ${file}`,\n  USER_NO_DMCHANNEL: 'No DM Channel exists!',\n  VOICE_NOT_STAGE_CHANNEL: 'You are only allowed to do this in stage channels.',\n  VOICE_STATE_UNCACHED_MEMBER: 'The member of this voice state is uncached.',\n  VOICE_STATE_NOT_OWN: 'You cannot self-deafen/mute/request to speak on VoiceStates that do not belong to the ClientUser.',\n  VOICE_STATE_INVALID_TYPE: name => `${name} must be a boolean.`,\n  REQ_RESOURCE_TYPE: 'The resource must be a string, Buffer or a valid file stream.',\n  IMAGE_FORMAT: format => `Invalid image format: ${format}`,\n  IMAGE_SIZE: size => `Invalid image size: ${size}`,\n  MESSAGE_BULK_DELETE_TYPE: 'The messages must be an Array, Collection, or number.',\n  MESSAGE_NONCE_TYPE: 'Message nonce must be an integer or a string.',\n  MESSAGE_CONTENT_TYPE: 'Message content must be a non-empty string.',\n  TYPING_COUNT: 'Count must be at least 1',\n  SPLIT_MAX_LEN: 'Chunk exceeds the max length and contains no split characters.',\n  BAN_RESOLVE_ID: (ban = false) => `Couldn't resolve the user ID to ${ban ? 'ban' : 'unban'}.`,\n  FETCH_BAN_RESOLVE_ID: \"Couldn't resolve the user ID to fetch the ban.\",\n  PRUNE_DAYS_TYPE: 'Days must be a number',\n  GUILD_CHANNEL_RESOLVE: 'Could not resolve channel to a guild channel.',\n  GUILD_VOICE_CHANNEL_RESOLVE: 'Could not resolve channel to a guild voice channel.',\n  GUILD_CHANNEL_ORPHAN: 'Could not find a parent to this guild channel.',\n  GUILD_OWNED: 'Guild is owned by the client.',\n  GUILD_MEMBERS_TIMEOUT: \"Members didn't arrive in time.\",\n  GUILD_UNCACHED_ME: 'The client user as a member of this guild is uncached.',\n  STAGE_CHANNEL_RESOLVE: 'Could not resolve channel to a stage channel.',\n  INVALID_TYPE: (name, expected, an = false) => `Supplied ${name} is not a${an ? 'n' : ''} ${expected}.`,\n  INVALID_ELEMENT: (type, name, elem) => `Supplied ${type} ${name} includes an invalid element: ${elem}`,\n  MESSAGE_THREAD_PARENT: 'The message was not sent in a guild text or news channel',\n  WEBHOOK_MESSAGE: 'The message was not sent by a webhook.',\n  WEBHOOK_TOKEN_UNAVAILABLE: 'This action requires a webhook token, but none is available.',\n  MESSAGE_REFERENCE_MISSING: 'The message does not reference another message',\n  EMOJI_TYPE: 'Emoji must be a string or GuildEmoji/ReactionEmoji',\n  EMOJI_MANAGED: 'Emoji is managed and has no Author.',\n  MISSING_MANAGE_EMOJIS_PERMISSION: guild => `Client must have Manage Emoji permission in guild ${guild} to see emoji authors.`,\n  REACTION_RESOLVE_USER: \"Couldn't resolve the user ID to remove from the reaction.\",\n  VANITY_URL: 'This guild does not have the VANITY_URL feature enabled.',\n  DELETE_GROUP_DM_CHANNEL: \"Bots don't have access to Group DM Channels and cannot delete them\",\n  FETCH_GROUP_DM_CHANNEL: \"Bots don't have access to Group DM Channels and cannot fetch them\",\n  MEMBER_FETCH_NONCE_LENGTH: 'Nonce length must not exceed 32 characters.',\n  GLOBAL_COMMAND_PERMISSIONS: 'Permissions for global commands may only be fetched or modified by providing a guildID' + \"or from a guild's application command manager.\",\n  INTERACTION_ALREADY_REPLIED: 'This interaction has already been deferred or replied to.',\n  INTERACTION_NOT_REPLIED: 'This interaction has not been deferred or replied to.',\n  INTERACTION_EPHEMERAL_REPLIED: 'Ephemeral responses cannot be fetched or deleted.'\n};\n\nfor (const [name, message] of Object.entries(Messages)) register(name, message);\n\n//# sourceURL=webpack://Fosscord/./src/errors/Messages.js?")},"./src/errors/index.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nmodule.exports = __webpack_require__(/*! ./DJSError */ "./src/errors/DJSError.js");\nmodule.exports.Messages = __webpack_require__(/*! ./Messages */ "./src/errors/Messages.js");\n\n//# sourceURL=webpack://Fosscord/./src/errors/index.js?')},"./src/index.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nmodule.exports = {\n  // "Root" classes (starting points)\n  BaseClient: __webpack_require__(/*! ./client/BaseClient */ "./src/client/BaseClient.js"),\n  Client: __webpack_require__(/*! ./client/Client */ "./src/client/Client.js"),\n  Shard: __webpack_require__(/*! ./sharding/Shard */ 7),\n  ShardClientUtil: __webpack_require__(/*! ./sharding/ShardClientUtil */ 8),\n  ShardingManager: __webpack_require__(/*! ./sharding/ShardingManager */ 9),\n  WebhookClient: __webpack_require__(/*! ./client/WebhookClient */ "./src/client/WebhookClient.js"),\n  // Utilities\n  ActivityFlags: __webpack_require__(/*! ./util/ActivityFlags */ "./src/util/ActivityFlags.js"),\n  ApplicationFlags: __webpack_require__(/*! ./util/ApplicationFlags */ "./src/util/ApplicationFlags.js"),\n  BitField: __webpack_require__(/*! ./util/BitField */ "./src/util/BitField.js"),\n  Collection: __webpack_require__(/*! ./util/Collection */ "./src/util/Collection.js"),\n  Constants: __webpack_require__(/*! ./util/Constants */ "./src/util/Constants.js"),\n  DataResolver: __webpack_require__(/*! ./util/DataResolver */ "./src/util/DataResolver.js"),\n  BaseManager: __webpack_require__(/*! ./managers/BaseManager */ "./src/managers/BaseManager.js"),\n  DiscordAPIError: __webpack_require__(/*! ./rest/DiscordAPIError */ "./src/rest/DiscordAPIError.js"),\n  HTTPError: __webpack_require__(/*! ./rest/HTTPError */ "./src/rest/HTTPError.js"),\n  RateLimitError: __webpack_require__(/*! ./rest/RateLimitError */ "./src/rest/RateLimitError.js"),\n  MessageFlags: __webpack_require__(/*! ./util/MessageFlags */ "./src/util/MessageFlags.js"),\n  Intents: __webpack_require__(/*! ./util/Intents */ "./src/util/Intents.js"),\n  Permissions: __webpack_require__(/*! ./util/Permissions */ "./src/util/Permissions.js"),\n  SnowflakeUtil: __webpack_require__(/*! ./util/SnowflakeUtil */ "./src/util/SnowflakeUtil.js"),\n  Structures: __webpack_require__(/*! ./util/Structures */ "./src/util/Structures.js"),\n  SystemChannelFlags: __webpack_require__(/*! ./util/SystemChannelFlags */ "./src/util/SystemChannelFlags.js"),\n  ThreadMemberFlags: __webpack_require__(/*! ./util/ThreadMemberFlags */ "./src/util/ThreadMemberFlags.js"),\n  UserFlags: __webpack_require__(/*! ./util/UserFlags */ "./src/util/UserFlags.js"),\n  Util: __webpack_require__(/*! ./util/Util */ "./src/util/Util.js"),\n  version: __webpack_require__(/*! ../package.json */ "./package.json").version,\n  // Managers\n  ApplicationCommandManager: __webpack_require__(/*! ./managers/ApplicationCommandManager */ "./src/managers/ApplicationCommandManager.js"),\n  BaseGuildEmojiManager: __webpack_require__(/*! ./managers/BaseGuildEmojiManager */ "./src/managers/BaseGuildEmojiManager.js"),\n  ChannelManager: __webpack_require__(/*! ./managers/ChannelManager */ "./src/managers/ChannelManager.js"),\n  GuildApplicationCommandManager: __webpack_require__(/*! ./managers/GuildApplicationCommandManager */ "./src/managers/GuildApplicationCommandManager.js"),\n  GuildBanManager: __webpack_require__(/*! ./managers/GuildBanManager */ "./src/managers/GuildBanManager.js"),\n  GuildChannelManager: __webpack_require__(/*! ./managers/GuildChannelManager */ "./src/managers/GuildChannelManager.js"),\n  GuildEmojiManager: __webpack_require__(/*! ./managers/GuildEmojiManager */ "./src/managers/GuildEmojiManager.js"),\n  GuildEmojiRoleManager: __webpack_require__(/*! ./managers/GuildEmojiRoleManager */ "./src/managers/GuildEmojiRoleManager.js"),\n  GuildMemberManager: __webpack_require__(/*! ./managers/GuildMemberManager */ "./src/managers/GuildMemberManager.js"),\n  GuildMemberRoleManager: __webpack_require__(/*! ./managers/GuildMemberRoleManager */ "./src/managers/GuildMemberRoleManager.js"),\n  GuildManager: __webpack_require__(/*! ./managers/GuildManager */ "./src/managers/GuildManager.js"),\n  ReactionManager: __webpack_require__(/*! ./managers/ReactionManager */ "./src/managers/ReactionManager.js"),\n  ReactionUserManager: __webpack_require__(/*! ./managers/ReactionUserManager */ "./src/managers/ReactionUserManager.js"),\n  MessageManager: __webpack_require__(/*! ./managers/MessageManager */ "./src/managers/MessageManager.js"),\n  PresenceManager: __webpack_require__(/*! ./managers/PresenceManager */ "./src/managers/PresenceManager.js"),\n  RoleManager: __webpack_require__(/*! ./managers/RoleManager */ "./src/managers/RoleManager.js"),\n  ThreadManager: __webpack_require__(/*! ./managers/ThreadManager */ "./src/managers/ThreadManager.js"),\n  ThreadMemberManager: __webpack_require__(/*! ./managers/ThreadMemberManager */ "./src/managers/ThreadMemberManager.js"),\n  UserManager: __webpack_require__(/*! ./managers/UserManager */ "./src/managers/UserManager.js"),\n  // Structures\n  Application: __webpack_require__(/*! ./structures/interfaces/Application */ "./src/structures/interfaces/Application.js"),\n  ApplicationCommand: __webpack_require__(/*! ./structures/ApplicationCommand */ "./src/structures/ApplicationCommand.js"),\n  Base: __webpack_require__(/*! ./structures/Base */ "./src/structures/Base.js"),\n  Activity: __webpack_require__(/*! ./structures/Presence */ "./src/structures/Presence.js").Activity,\n  APIMessage: __webpack_require__(/*! ./structures/APIMessage */ "./src/structures/APIMessage.js"),\n  BaseGuild: __webpack_require__(/*! ./structures/BaseGuild */ "./src/structures/BaseGuild.js"),\n  BaseGuildEmoji: __webpack_require__(/*! ./structures/BaseGuildEmoji */ "./src/structures/BaseGuildEmoji.js"),\n  BaseGuildVoiceChannel: __webpack_require__(/*! ./structures/BaseGuildVoiceChannel */ "./src/structures/BaseGuildVoiceChannel.js"),\n  BaseMessageComponent: __webpack_require__(/*! ./structures/BaseMessageComponent */ "./src/structures/BaseMessageComponent.js"),\n  ButtonInteraction: __webpack_require__(/*! ./structures/ButtonInteraction */ "./src/structures/ButtonInteraction.js"),\n  CategoryChannel: __webpack_require__(/*! ./structures/CategoryChannel */ "./src/structures/CategoryChannel.js"),\n  Channel: __webpack_require__(/*! ./structures/Channel */ "./src/structures/Channel.js"),\n  ClientApplication: __webpack_require__(/*! ./structures/ClientApplication */ "./src/structures/ClientApplication.js"),\n\n  get ClientUser() {\n    // This is a getter so that it properly extends any custom User class\n    return __webpack_require__(/*! ./structures/ClientUser */ "./src/structures/ClientUser.js");\n  },\n\n  Collector: __webpack_require__(/*! ./structures/interfaces/Collector */ "./src/structures/interfaces/Collector.js"),\n  CommandInteraction: __webpack_require__(/*! ./structures/CommandInteraction */ "./src/structures/CommandInteraction.js"),\n  DMChannel: __webpack_require__(/*! ./structures/DMChannel */ "./src/structures/DMChannel.js"),\n  Emoji: __webpack_require__(/*! ./structures/Emoji */ "./src/structures/Emoji.js"),\n  Guild: __webpack_require__(/*! ./structures/Guild */ "./src/structures/Guild.js"),\n  GuildAuditLogs: __webpack_require__(/*! ./structures/GuildAuditLogs */ "./src/structures/GuildAuditLogs.js"),\n  GuildBan: __webpack_require__(/*! ./structures/GuildBan */ "./src/structures/GuildBan.js"),\n  GuildChannel: __webpack_require__(/*! ./structures/GuildChannel */ "./src/structures/GuildChannel.js"),\n  GuildEmoji: __webpack_require__(/*! ./structures/GuildEmoji */ "./src/structures/GuildEmoji.js"),\n  GuildMember: __webpack_require__(/*! ./structures/GuildMember */ "./src/structures/GuildMember.js"),\n  GuildPreview: __webpack_require__(/*! ./structures/GuildPreview */ "./src/structures/GuildPreview.js"),\n  GuildTemplate: __webpack_require__(/*! ./structures/GuildTemplate */ "./src/structures/GuildTemplate.js"),\n  Integration: __webpack_require__(/*! ./structures/Integration */ "./src/structures/Integration.js"),\n  IntegrationApplication: __webpack_require__(/*! ./structures/IntegrationApplication */ "./src/structures/IntegrationApplication.js"),\n  Interaction: __webpack_require__(/*! ./structures/Interaction */ "./src/structures/Interaction.js"),\n  InteractionWebhook: __webpack_require__(/*! ./structures/InteractionWebhook */ "./src/structures/InteractionWebhook.js"),\n  Invite: __webpack_require__(/*! ./structures/Invite */ "./src/structures/Invite.js"),\n  Message: __webpack_require__(/*! ./structures/Message */ "./src/structures/Message.js"),\n  MessageActionRow: __webpack_require__(/*! ./structures/MessageActionRow */ "./src/structures/MessageActionRow.js"),\n  MessageAttachment: __webpack_require__(/*! ./structures/MessageAttachment */ "./src/structures/MessageAttachment.js"),\n  MessageButton: __webpack_require__(/*! ./structures/MessageButton */ "./src/structures/MessageButton.js"),\n  MessageCollector: __webpack_require__(/*! ./structures/MessageCollector */ "./src/structures/MessageCollector.js"),\n  MessageComponentInteraction: __webpack_require__(/*! ./structures/MessageComponentInteraction */ "./src/structures/MessageComponentInteraction.js"),\n  MessageComponentInteractionCollector: __webpack_require__(/*! ./structures/MessageComponentInteractionCollector */ "./src/structures/MessageComponentInteractionCollector.js"),\n  MessageEmbed: __webpack_require__(/*! ./structures/MessageEmbed */ "./src/structures/MessageEmbed.js"),\n  MessageMentions: __webpack_require__(/*! ./structures/MessageMentions */ "./src/structures/MessageMentions.js"),\n  MessageReaction: __webpack_require__(/*! ./structures/MessageReaction */ "./src/structures/MessageReaction.js"),\n  MessageSelectMenu: __webpack_require__(/*! ./structures/MessageSelectMenu */ "./src/structures/MessageSelectMenu.js"),\n  NewsChannel: __webpack_require__(/*! ./structures/NewsChannel */ "./src/structures/NewsChannel.js"),\n  OAuth2Guild: __webpack_require__(/*! ./structures/OAuth2Guild */ "./src/structures/OAuth2Guild.js"),\n  PermissionOverwrites: __webpack_require__(/*! ./structures/PermissionOverwrites */ "./src/structures/PermissionOverwrites.js"),\n  Presence: __webpack_require__(/*! ./structures/Presence */ "./src/structures/Presence.js").Presence,\n  ClientPresence: __webpack_require__(/*! ./structures/ClientPresence */ "./src/structures/ClientPresence.js"),\n  ReactionCollector: __webpack_require__(/*! ./structures/ReactionCollector */ "./src/structures/ReactionCollector.js"),\n  ReactionEmoji: __webpack_require__(/*! ./structures/ReactionEmoji */ "./src/structures/ReactionEmoji.js"),\n  RichPresenceAssets: __webpack_require__(/*! ./structures/Presence */ "./src/structures/Presence.js").RichPresenceAssets,\n  Role: __webpack_require__(/*! ./structures/Role */ "./src/structures/Role.js"),\n  SelectMenuInteraction: __webpack_require__(/*! ./structures/SelectMenuInteraction */ "./src/structures/SelectMenuInteraction.js"),\n  Sticker: __webpack_require__(/*! ./structures/Sticker */ "./src/structures/Sticker.js"),\n  StoreChannel: __webpack_require__(/*! ./structures/StoreChannel */ "./src/structures/StoreChannel.js"),\n  StageChannel: __webpack_require__(/*! ./structures/StageChannel */ "./src/structures/StageChannel.js"),\n  Team: __webpack_require__(/*! ./structures/Team */ "./src/structures/Team.js"),\n  TeamMember: __webpack_require__(/*! ./structures/TeamMember */ "./src/structures/TeamMember.js"),\n  TextChannel: __webpack_require__(/*! ./structures/TextChannel */ "./src/structures/TextChannel.js"),\n  ThreadChannel: __webpack_require__(/*! ./structures/ThreadChannel */ "./src/structures/ThreadChannel.js"),\n  ThreadMember: __webpack_require__(/*! ./structures/ThreadMember */ "./src/structures/ThreadMember.js"),\n  User: __webpack_require__(/*! ./structures/User */ "./src/structures/User.js"),\n  VoiceChannel: __webpack_require__(/*! ./structures/VoiceChannel */ "./src/structures/VoiceChannel.js"),\n  VoiceRegion: __webpack_require__(/*! ./structures/VoiceRegion */ "./src/structures/VoiceRegion.js"),\n  VoiceState: __webpack_require__(/*! ./structures/VoiceState */ "./src/structures/VoiceState.js"),\n  Webhook: __webpack_require__(/*! ./structures/Webhook */ "./src/structures/Webhook.js"),\n  Widget: __webpack_require__(/*! ./structures/Widget */ "./src/structures/Widget.js"),\n  WidgetMember: __webpack_require__(/*! ./structures/WidgetMember */ "./src/structures/WidgetMember.js"),\n  WebSocket: __webpack_require__(/*! ./WebSocket */ "./src/WebSocket.js")\n};\n\n//# sourceURL=webpack://Fosscord/./src/index.js?')},"./src/managers/ApplicationCommandManager.js":function(module,exports){eval('throw new Error("Module parse failed: Unexpected token (54:61)\\nFile was processed with these loaders:\\n * ./node_modules/babel-loader/lib/index.js\\nYou may need an additional loader to handle the result of these loaders.\\n|   } = {}) {\\n|     let path = this.client.api.applications(this.client.application.id);\\n>     if (this.guild || guildID) path = path.guilds(this.guild?.id ?? guildID);\\n|     return id ? path.commands(id) : path.commands;\\n|   }");\n\n//# sourceURL=webpack://Fosscord/./src/managers/ApplicationCommandManager.js?')},"./src/managers/BaseGuildEmojiManager.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nconst BaseManager = __webpack_require__(/*! ./BaseManager */ \"./src/managers/BaseManager.js\");\n\nconst GuildEmoji = __webpack_require__(/*! ../structures/GuildEmoji */ \"./src/structures/GuildEmoji.js\");\n\nconst ReactionEmoji = __webpack_require__(/*! ../structures/ReactionEmoji */ \"./src/structures/ReactionEmoji.js\");\n\nconst {\n  parseEmoji\n} = __webpack_require__(/*! ../util/Util */ \"./src/util/Util.js\");\n/**\n * Holds methods to resolve GuildEmojis and stores their cache.\n * @extends {BaseManager}\n */\n\n\nclass BaseGuildEmojiManager extends BaseManager {\n  constructor(client, iterable) {\n    super(client, iterable, GuildEmoji);\n  }\n  /**\n   * The cache of GuildEmojis\n   * @type {Collection<Snowflake, GuildEmoji>}\n   * @name BaseGuildEmojiManager#cache\n   */\n\n  /**\n   * Data that can be resolved into a GuildEmoji object. This can be:\n   * * A custom emoji ID\n   * * A GuildEmoji object\n   * * A ReactionEmoji object\n   * @typedef {Snowflake|GuildEmoji|ReactionEmoji} EmojiResolvable\n   */\n\n  /**\n   * Resolves an EmojiResolvable to an Emoji object.\n   * @param {EmojiResolvable} emoji The Emoji resolvable to identify\n   * @returns {?GuildEmoji}\n   */\n\n\n  resolve(emoji) {\n    if (emoji instanceof ReactionEmoji) return super.resolve(emoji.id);\n    return super.resolve(emoji);\n  }\n  /**\n   * Resolves an EmojiResolvable to an Emoji ID string.\n   * @param {EmojiResolvable} emoji The Emoji resolvable to identify\n   * @returns {?Snowflake}\n   */\n\n\n  resolveID(emoji) {\n    if (emoji instanceof ReactionEmoji) return emoji.id;\n    return super.resolveID(emoji);\n  }\n  /**\n   * Data that can be resolved to give an emoji identifier. This can be:\n   * * The unicode representation of an emoji\n   * * The `<a:name:id>`, `<:name:id>`, `a:name:id` or `name:id` emoji identifier string of an emoji\n   * * An EmojiResolvable\n   * @typedef {string|EmojiResolvable} EmojiIdentifierResolvable\n   */\n\n  /**\n   * Resolves an EmojiResolvable to an emoji identifier.\n   * @param {EmojiIdentifierResolvable} emoji The emoji resolvable to resolve\n   * @returns {?string}\n   */\n\n\n  resolveIdentifier(emoji) {\n    const emojiResolvable = this.resolve(emoji);\n    if (emojiResolvable) return emojiResolvable.identifier;\n    if (emoji instanceof ReactionEmoji) return emoji.identifier;\n\n    if (typeof emoji === 'string') {\n      const res = parseEmoji(emoji);\n\n      if (res && res.name.length) {\n        emoji = `${res.animated ? 'a:' : ''}${res.name}${res.id ? `:${res.id}` : ''}`;\n      }\n\n      if (!emoji.includes('%')) return encodeURIComponent(emoji);\n      return emoji;\n    }\n\n    return null;\n  }\n\n}\n\nmodule.exports = BaseGuildEmojiManager;\n\n//# sourceURL=webpack://Fosscord/./src/managers/BaseGuildEmojiManager.js?")},"./src/managers/BaseManager.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nconst Collection = __webpack_require__(/*! ../util/Collection */ \"./src/util/Collection.js\");\n\nlet Structures;\n/**\n * Manages the API methods of a data model and holds its cache.\n * @abstract\n */\n\nclass BaseManager {\n  constructor(client, iterable, holds, cacheType = Collection, ...cacheOptions) {\n    if (!Structures) Structures = __webpack_require__(/*! ../util/Structures */ \"./src/util/Structures.js\");\n    /**\n     * The data structure belonging to this manager\n     * @name BaseManager#holds\n     * @type {Function}\n     * @private\n     * @readonly\n     */\n\n    Object.defineProperty(this, 'holds', {\n      value: Structures.get(holds.name) || holds\n    });\n    /**\n     * The client that instantiated this Manager\n     * @name BaseManager#client\n     * @type {Client}\n     * @readonly\n     */\n\n    Object.defineProperty(this, 'client', {\n      value: client\n    });\n    /**\n     * The type of Collection of the Manager\n     * @type {Collection}\n     */\n\n    this.cacheType = cacheType;\n    /**\n     * Holds the cache for the data model\n     * @type {Collection}\n     */\n\n    this.cache = new cacheType(...cacheOptions);\n    if (iterable) for (const i of iterable) this.add(i);\n  }\n\n  add(data, cache = true, {\n    id,\n    extras = []\n  } = {}) {\n    const existing = this.cache.get(id || data.id);\n    if (existing && existing._patch && cache) existing._patch(data);\n    if (existing) return existing;\n    const entry = this.holds ? new this.holds(this.client, data, ...extras) : data;\n    if (cache) this.cache.set(id || entry.id, entry);\n    return entry;\n  }\n  /**\n   * Resolves a data entry to a data Object.\n   * @param {string|Object} idOrInstance The id or instance of something in this Manager\n   * @returns {?Object} An instance from this Manager\n   */\n\n\n  resolve(idOrInstance) {\n    if (idOrInstance instanceof this.holds) return idOrInstance;\n    if (typeof idOrInstance === 'string') return this.cache.get(idOrInstance) || null;\n    return null;\n  }\n  /**\n   * Resolves a data entry to an instance ID.\n   * @param {string|Object} idOrInstance The id or instance of something in this Manager\n   * @returns {?Snowflake}\n   */\n\n\n  resolveID(idOrInstance) {\n    if (idOrInstance instanceof this.holds) return idOrInstance.id;\n    if (typeof idOrInstance === 'string') return idOrInstance;\n    return null;\n  }\n\n  valueOf() {\n    return this.cache;\n  }\n\n}\n\nmodule.exports = BaseManager;\n\n//# sourceURL=webpack://Fosscord/./src/managers/BaseManager.js?")},"./src/managers/ChannelManager.js":function(module,exports){eval("throw new Error(\"Module parse failed: Unexpected token (33:32)\\nFile was processed with these loaders:\\n * ./node_modules/babel-loader/lib/index.js\\nYou may need an additional loader to handle the result of these loaders.\\n|     if (existing) {\\n|       if (existing._patch && cache) existing._patch(data);\\n>       if (guild) guild.channels?.add(existing);\\n| \\n|       if (ThreadChannelTypes.includes(existing.type) && typeof existing.parent?.threads !== 'undefined') {\");\n\n//# sourceURL=webpack://Fosscord/./src/managers/ChannelManager.js?")},"./src/managers/GuildApplicationCommandManager.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nconst ApplicationCommandManager = __webpack_require__(/*! ./ApplicationCommandManager */ "./src/managers/ApplicationCommandManager.js");\n/**\n * An extension for guild-specific application commands.\n * @extends {ApplicationCommandManager}\n */\n\n\nclass GuildApplicationCommandManager extends ApplicationCommandManager {\n  constructor(guild, iterable) {\n    super(guild.client, iterable);\n    /**\n     * The guild that this manager belongs to\n     * @type {Guild}\n     */\n\n    this.guild = guild;\n  }\n\n}\n\nmodule.exports = GuildApplicationCommandManager;\n\n//# sourceURL=webpack://Fosscord/./src/managers/GuildApplicationCommandManager.js?')},"./src/managers/GuildBanManager.js":function(module,exports){eval('throw new Error("Module parse failed: Unexpected token (59:31)\\nFile was processed with these loaders:\\n * ./node_modules/babel-loader/lib/index.js\\nYou may need an additional loader to handle the result of these loaders.\\n| \\n|   resolve(ban) {\\n>     return super.resolve(ban) ?? super.resolve(this.client.users.resolveID(ban));\\n|   }\\n|   /**");\n\n//# sourceURL=webpack://Fosscord/./src/managers/GuildBanManager.js?')},"./src/managers/GuildChannelManager.js":function(module,exports){eval('throw new Error("Module parse failed: Unexpected token (193:34)\\nFile was processed with these loaders:\\n * ./node_modules/babel-loader/lib/index.js\\nYou may need an additional loader to handle the result of these loaders.\\n|     for (const channel of data) channels.set(channel.id, this.client.channels.add(channel, this.guild, cache));\\n| \\n>     return id ? channels.get(id) ?? null : channels;\\n|   }\\n| ");\n\n//# sourceURL=webpack://Fosscord/./src/managers/GuildChannelManager.js?')},"./src/managers/GuildEmojiManager.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nconst BaseGuildEmojiManager = __webpack_require__(/*! ./BaseGuildEmojiManager */ \"./src/managers/BaseGuildEmojiManager.js\");\n\nconst {\n  TypeError\n} = __webpack_require__(/*! ../errors */ \"./src/errors/index.js\");\n\nconst Collection = __webpack_require__(/*! ../util/Collection */ \"./src/util/Collection.js\");\n\nconst DataResolver = __webpack_require__(/*! ../util/DataResolver */ \"./src/util/DataResolver.js\");\n/**\n * Manages API methods for GuildEmojis and stores their cache.\n * @extends {BaseGuildEmojiManager}\n */\n\n\nclass GuildEmojiManager extends BaseGuildEmojiManager {\n  constructor(guild, iterable) {\n    super(guild.client, iterable);\n    /**\n     * The guild this manager belongs to\n     * @type {Guild}\n     */\n\n    this.guild = guild;\n  }\n\n  add(data, cache) {\n    return super.add(data, cache, {\n      extras: [this.guild]\n    });\n  }\n  /**\n   * Options used for creating an emoji in a guild.\n   * @typedef {Object} GuildEmojiCreateOptions\n   * @property {Collection<Snowflake, Role>|RoleResolvable[]} [roles] The roles to limit the emoji to\n   * @property {string} [reason] The reason for creating the emoji\n   */\n\n  /**\n   * Creates a new custom emoji in the guild.\n   * @param {BufferResolvable|Base64Resolvable} attachment The image for the emoji\n   * @param {string} name The name for the emoji\n   * @param {GuildEmojiCreateOptions} [options] Options for creating the emoji\n   * @returns {Promise<Emoji>} The created emoji\n   * @example\n   * // Create a new emoji from a url\n   * guild.emojis.create('https://i.imgur.com/w3duR07.png', 'rip')\n   *   .then(emoji => console.log(`Created new emoji with name ${emoji.name}!`))\n   *   .catch(console.error);\n   * @example\n   * // Create a new emoji from a file on your computer\n   * guild.emojis.create('./memes/banana.png', 'banana')\n   *   .then(emoji => console.log(`Created new emoji with name ${emoji.name}!`))\n   *   .catch(console.error);\n   */\n\n\n  async create(attachment, name, {\n    roles,\n    reason\n  } = {}) {\n    attachment = await DataResolver.resolveImage(attachment);\n    if (!attachment) throw new TypeError('REQ_RESOURCE_TYPE');\n    const data = {\n      image: attachment,\n      name\n    };\n\n    if (roles) {\n      if (!Array.isArray(roles) && !(roles instanceof Collection)) {\n        throw new TypeError('INVALID_TYPE', 'options.roles', 'Array or Collection of Roles or Snowflakes', true);\n      }\n\n      data.roles = [];\n\n      for (const role of roles.values()) {\n        const resolvedRole = this.guild.roles.resolveID(role);\n        if (!resolvedRole) throw new TypeError('INVALID_ELEMENT', 'Array or Collection', 'options.roles', role);\n        data.roles.push(resolvedRole);\n      }\n    }\n\n    return this.client.api.guilds(this.guild.id).emojis.post({\n      data,\n      reason\n    }).then(emoji => this.client.actions.GuildEmojiCreate.handle(this.guild, emoji).emoji);\n  }\n  /**\n   * Obtains one or more emojis from Discord, or the emoji cache if they're already available.\n   * @param {Snowflake} [id] ID of the emoji\n   * @param {BaseFetchOptions} [options] Additional options for this fetch\n   * @returns {Promise<GuildEmoji|Collection<Snowflake, GuildEmoji>>}\n   * @example\n   * // Fetch all emojis from the guild\n   * message.guild.emojis.fetch()\n   *   .then(emojis => console.log(`There are ${emojis.size} emojis.`))\n   *   .catch(console.error);\n   * @example\n   * // Fetch a single emoji\n   * message.guild.emojis.fetch('222078108977594368')\n   *   .then(emoji => console.log(`The emoji name is: ${emoji.name}`))\n   *   .catch(console.error);\n   */\n\n\n  async fetch(id, {\n    cache = true,\n    force = false\n  } = {}) {\n    if (id) {\n      if (!force) {\n        const existing = this.cache.get(id);\n        if (existing) return existing;\n      }\n\n      const emoji = await this.client.api.guilds(this.guild.id).emojis(id).get();\n      return this.add(emoji, cache);\n    }\n\n    const data = await this.client.api.guilds(this.guild.id).emojis.get();\n    const emojis = new Collection();\n\n    for (const emoji of data) emojis.set(emoji.id, this.add(emoji, cache));\n\n    return emojis;\n  }\n\n}\n\nmodule.exports = GuildEmojiManager;\n\n//# sourceURL=webpack://Fosscord/./src/managers/GuildEmojiManager.js?")},"./src/managers/GuildEmojiRoleManager.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nconst {\n  TypeError\n} = __webpack_require__(/*! ../errors */ \"./src/errors/index.js\");\n\nconst Collection = __webpack_require__(/*! ../util/Collection */ \"./src/util/Collection.js\");\n/**\n * Manages API methods for roles belonging to emojis and stores their cache.\n */\n\n\nclass GuildEmojiRoleManager {\n  constructor(emoji) {\n    /**\n     * The emoji belonging to this manager\n     * @type {GuildEmoji}\n     */\n    this.emoji = emoji;\n    /**\n     * The guild belonging to this manager\n     * @type {Guild}\n     */\n\n    this.guild = emoji.guild;\n    /**\n     * The client belonging to this manager\n     * @type {Client}\n     * @readonly\n     */\n\n    Object.defineProperty(this, 'client', {\n      value: emoji.client\n    });\n  }\n  /**\n   * The cache of roles belonging to this emoji\n   * @type {Collection<Snowflake, Role>}\n   * @readonly\n   */\n\n\n  get cache() {\n    return this.guild.roles.cache.filter(role => this.emoji._roles.includes(role.id));\n  }\n  /**\n   * Adds a role (or multiple roles) to the list of roles that can use this emoji.\n   * @param {RoleResolvable|RoleResolvable[]|Collection<Snowflake, Role>} roleOrRoles The role or roles to add\n   * @returns {Promise<GuildEmoji>}\n   */\n\n\n  add(roleOrRoles) {\n    if (!Array.isArray(roleOrRoles) && !(roleOrRoles instanceof Collection)) roleOrRoles = [roleOrRoles];\n    const resolvedRoles = [];\n\n    for (const role of roleOrRoles.values()) {\n      const resolvedRole = this.guild.roles.resolveID(role);\n\n      if (!resolvedRole) {\n        return Promise.reject(new TypeError('INVALID_ELEMENT', 'Array or Collection', 'roles', role));\n      }\n\n      resolvedRoles.push(resolvedRole);\n    }\n\n    const newRoles = [...new Set(resolvedRoles.concat(...this.cache.values()))];\n    return this.set(newRoles);\n  }\n  /**\n   * Removes a role (or multiple roles) from the list of roles that can use this emoji.\n   * @param {RoleResolvable|RoleResolvable[]|Collection<Snowflake, Role>} roleOrRoles The role or roles to remove\n   * @returns {Promise<GuildEmoji>}\n   */\n\n\n  remove(roleOrRoles) {\n    if (!Array.isArray(roleOrRoles) && !(roleOrRoles instanceof Collection)) roleOrRoles = [roleOrRoles];\n    const resolvedRoleIDs = [];\n\n    for (const role of roleOrRoles.values()) {\n      const roleID = this.guild.roles.resolveID(role);\n\n      if (!roleID) {\n        return Promise.reject(new TypeError('INVALID_ELEMENT', 'Array or Collection', 'roles', role));\n      }\n\n      resolvedRoleIDs.push(roleID);\n    }\n\n    const newRoles = this.cache.keyArray().filter(id => !resolvedRoleIDs.includes(id));\n    return this.set(newRoles);\n  }\n  /**\n   * Sets the role(s) that can use this emoji.\n   * @param {Collection<Snowflake, Role>|RoleResolvable[]} roles The roles or role IDs to apply\n   * @returns {Promise<GuildEmoji>}\n   * @example\n   * // Set the emoji's roles to a single role\n   * guildEmoji.roles.set(['391156570408615936'])\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // Remove all roles from an emoji\n   * guildEmoji.roles.set([])\n   *    .then(console.log)\n   *    .catch(console.error);\n   */\n\n\n  set(roles) {\n    return this.emoji.edit({\n      roles\n    });\n  }\n\n  clone() {\n    const clone = new this.constructor(this.emoji);\n\n    clone._patch(this.cache.keyArray().slice());\n\n    return clone;\n  }\n  /**\n   * Patches the roles for this manager's cache\n   * @param {Snowflake[]} roles The new roles\n   * @private\n   */\n\n\n  _patch(roles) {\n    this.emoji._roles = roles;\n  }\n\n  valueOf() {\n    return this.cache;\n  }\n\n}\n\nmodule.exports = GuildEmojiRoleManager;\n\n//# sourceURL=webpack://Fosscord/./src/managers/GuildEmojiRoleManager.js?")},"./src/managers/GuildManager.js":function(module,exports){eval('throw new Error("Module parse failed: Unexpected token (269:40)\\nFile was processed with these loaders:\\n * ./node_modules/babel-loader/lib/index.js\\nYou may need an additional loader to handle the result of these loaders.\\n| \\n|   async fetch(options = {}) {\\n>     const id = this.resolveID(options) ?? this.resolveID(options.guild);\\n| \\n|     if (id) {");\n\n//# sourceURL=webpack://Fosscord/./src/managers/GuildManager.js?')},"./src/managers/GuildMemberManager.js":function(module,exports){eval('throw new Error("Module parse failed: Unexpected token (239:37)\\nFile was processed with these loaders:\\n * ./node_modules/babel-loader/lib/index.js\\nYou may need an additional loader to handle the result of these loaders.\\n|       reason\\n|     });\\n>     const clone = this.cache.get(id)?._clone();\\n|     clone?._patch(d);\\n|     return clone ?? this.add(d, false);");\n\n//# sourceURL=webpack://Fosscord/./src/managers/GuildMemberManager.js?')},"./src/managers/GuildMemberRoleManager.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nconst {\n  TypeError\n} = __webpack_require__(/*! ../errors */ \"./src/errors/index.js\");\n\nconst Collection = __webpack_require__(/*! ../util/Collection */ \"./src/util/Collection.js\");\n/**\n * Manages API methods for roles of a GuildMember and stores their cache.\n */\n\n\nclass GuildMemberRoleManager {\n  constructor(member) {\n    /**\n     * The GuildMember this manager belongs to\n     * @type {GuildMember}\n     */\n    this.member = member;\n    /**\n     * The Guild this manager belongs to\n     * @type {Guild}\n     */\n\n    this.guild = member.guild;\n    Object.defineProperty(this, 'client', {\n      value: member.client\n    });\n  }\n  /**\n   * The roles of this member\n   * @type {Collection<Snowflake, Role>}\n   * @readonly\n   */\n\n\n  get cache() {\n    const everyone = this.guild.roles.everyone;\n    return this.guild.roles.cache.filter(role => this.member._roles.includes(role.id)).set(everyone.id, everyone);\n  }\n  /**\n   * The role of the member used to hoist them in a separate category in the users list\n   * @type {?Role}\n   * @readonly\n   */\n\n\n  get hoist() {\n    const hoistedRoles = this.cache.filter(role => role.hoist);\n    if (!hoistedRoles.size) return null;\n    return hoistedRoles.reduce((prev, role) => !prev || role.comparePositionTo(prev) > 0 ? role : prev);\n  }\n  /**\n   * The role of the member used to set their color\n   * @type {?Role}\n   * @readonly\n   */\n\n\n  get color() {\n    const coloredRoles = this.cache.filter(role => role.color);\n    if (!coloredRoles.size) return null;\n    return coloredRoles.reduce((prev, role) => !prev || role.comparePositionTo(prev) > 0 ? role : prev);\n  }\n  /**\n   * The role of the member with the highest position\n   * @type {Role}\n   * @readonly\n   */\n\n\n  get highest() {\n    return this.cache.reduce((prev, role) => role.comparePositionTo(prev) > 0 ? role : prev, this.cache.first());\n  }\n  /**\n   * The premium subscriber role of the guild, if present on the member\n   * @type {?Role}\n   * @readonly\n   */\n\n\n  get premiumSubscriberRole() {\n    return this.cache.find(role => role.tags && role.tags.premiumSubscriberRole) || null;\n  }\n  /**\n   * The managed role this member created when joining the guild, if any\n   * <info>Only ever available on bots</info>\n   * @type {?Role}\n   * @readonly\n   */\n\n\n  get botRole() {\n    if (!this.member.user.bot) return null;\n    return this.cache.find(role => role.tags && role.tags.botID === this.member.user.id) || null;\n  }\n  /**\n   * Adds a role (or multiple roles) to the member.\n   * @param {RoleResolvable|RoleResolvable[]|Collection<Snowflake, Role>} roleOrRoles The role or roles to add\n   * @param {string} [reason] Reason for adding the role(s)\n   * @returns {Promise<GuildMember>}\n   */\n\n\n  async add(roleOrRoles, reason) {\n    if (roleOrRoles instanceof Collection || Array.isArray(roleOrRoles)) {\n      const resolvedRoles = [];\n\n      for (const role of roleOrRoles.values()) {\n        const resolvedRole = this.guild.roles.resolveID(role);\n        if (!resolvedRole) throw new TypeError('INVALID_ELEMENT', 'Array or Collection', 'roles', role);\n        resolvedRoles.push(resolvedRole);\n      }\n\n      const newRoles = [...new Set(resolvedRoles.concat(...this.cache.values()))];\n      return this.set(newRoles, reason);\n    } else {\n      roleOrRoles = this.guild.roles.resolveID(roleOrRoles);\n\n      if (roleOrRoles === null) {\n        throw new TypeError('INVALID_TYPE', 'roles', 'Role, Snowflake or Array or Collection of Roles or Snowflakes');\n      }\n\n      await this.client.api.guilds[this.guild.id].members[this.member.id].roles[roleOrRoles].put({\n        reason\n      });\n\n      const clone = this.member._clone();\n\n      clone._roles = [...this.cache.keys(), roleOrRoles];\n      return clone;\n    }\n  }\n  /**\n   * Removes a role (or multiple roles) from the member.\n   * @param {RoleResolvable|RoleResolvable[]|Collection<Snowflake, Role>} roleOrRoles The role or roles to remove\n   * @param {string} [reason] Reason for removing the role(s)\n   * @returns {Promise<GuildMember>}\n   */\n\n\n  async remove(roleOrRoles, reason) {\n    if (roleOrRoles instanceof Collection || Array.isArray(roleOrRoles)) {\n      const resolvedRoles = [];\n\n      for (const role of roleOrRoles.values()) {\n        const resolvedRole = this.guild.roles.resolveID(role);\n        if (!resolvedRole) throw new TypeError('INVALID_ELEMENT', 'Array or Collection', 'roles', role);\n        resolvedRoles.push(resolvedRole);\n      }\n\n      const newRoles = this.cache.filter(role => !resolvedRoles.includes(role.id));\n      return this.set(newRoles, reason);\n    } else {\n      roleOrRoles = this.guild.roles.resolveID(roleOrRoles);\n\n      if (roleOrRoles === null) {\n        throw new TypeError('INVALID_TYPE', 'roles', 'Role, Snwoflake or Array or Collection of Roles or Snowflakes');\n      }\n\n      await this.client.api.guilds[this.guild.id].members[this.member.id].roles[roleOrRoles].delete({\n        reason\n      });\n\n      const clone = this.member._clone();\n\n      const newRoles = this.cache.filter(role => role.id !== roleOrRoles);\n      clone._roles = [...newRoles.keys()];\n      return clone;\n    }\n  }\n  /**\n   * Sets the roles applied to the member.\n   * @param {Collection<Snowflake, Role>|RoleResolvable[]} roles The roles or role IDs to apply\n   * @param {string} [reason] Reason for applying the roles\n   * @returns {Promise<GuildMember>}\n   * @example\n   * // Set the member's roles to a single role\n   * guildMember.roles.set(['391156570408615936'])\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // Remove all the roles from a member\n   * guildMember.roles.set([])\n   *   .then(member => console.log(`Member roles is now of ${member.roles.cache.size} size`))\n   *   .catch(console.error);\n   */\n\n\n  set(roles, reason) {\n    return this.member.edit({\n      roles\n    }, reason);\n  }\n\n  clone() {\n    const clone = new this.constructor(this.member);\n    clone.member._roles = [...this.cache.keyArray()];\n    return clone;\n  }\n\n  valueOf() {\n    return this.cache;\n  }\n\n}\n\nmodule.exports = GuildMemberRoleManager;\n\n//# sourceURL=webpack://Fosscord/./src/managers/GuildMemberRoleManager.js?")},"./src/managers/MessageManager.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nconst BaseManager = __webpack_require__(/*! ./BaseManager */ \"./src/managers/BaseManager.js\");\n\nconst {\n  TypeError\n} = __webpack_require__(/*! ../errors */ \"./src/errors/index.js\");\n\nconst APIMessage = __webpack_require__(/*! ../structures/APIMessage */ \"./src/structures/APIMessage.js\");\n\nconst Message = __webpack_require__(/*! ../structures/Message */ \"./src/structures/Message.js\");\n\nconst Collection = __webpack_require__(/*! ../util/Collection */ \"./src/util/Collection.js\");\n\nconst LimitedCollection = __webpack_require__(/*! ../util/LimitedCollection */ \"./src/util/LimitedCollection.js\");\n/**\n * Manages API methods for Messages and holds their cache.\n * @extends {BaseManager}\n */\n\n\nclass MessageManager extends BaseManager {\n  constructor(channel, iterable) {\n    super(channel.client, iterable, Message, LimitedCollection, channel.client.options.messageCacheMaxSize);\n    /**\n     * The channel that the messages belong to\n     * @type {TextBasedChannel}\n     */\n\n    this.channel = channel;\n  }\n  /**\n   * The cache of Messages\n   * @type {Collection<Snowflake, Message>}\n   * @name MessageManager#cache\n   */\n\n\n  add(data, cache) {\n    return super.add(data, cache, {\n      extras: [this.channel]\n    });\n  }\n  /**\n   * The parameters to pass in when requesting previous messages from a channel. `around`, `before` and\n   * `after` are mutually exclusive. All the parameters are optional.\n   * @typedef {Object} ChannelLogsQueryOptions\n   * @property {number} [limit=50] Number of messages to acquire\n   * @property {Snowflake} [before] ID of a message to get the messages that were posted before it\n   * @property {Snowflake} [after] ID of a message to get the messages that were posted after it\n   * @property {Snowflake} [around] ID of a message to get the messages that were posted around it\n   */\n\n  /**\n   * Gets a message, or messages, from this channel.\n   * <info>The returned Collection does not contain reaction users of the messages if they were not cached.\n   * Those need to be fetched separately in such a case.</info>\n   * @param {Snowflake|ChannelLogsQueryOptions} [message] The ID of the message to fetch, or query parameters.\n   * @param {BaseFetchOptions} [options] Additional options for this fetch\n   * @returns {Promise<Message>|Promise<Collection<Snowflake, Message>>}\n   * @example\n   * // Get message\n   * channel.messages.fetch('99539446449315840')\n   *   .then(message => console.log(message.content))\n   *   .catch(console.error);\n   * @example\n   * // Get messages\n   * channel.messages.fetch({ limit: 10 })\n   *   .then(messages => console.log(`Received ${messages.size} messages`))\n   *   .catch(console.error);\n   * @example\n   * // Get messages and filter by user ID\n   * channel.messages.fetch()\n   *   .then(messages => console.log(`${messages.filter(m => m.author.id === '84484653687267328').size} messages`))\n   *   .catch(console.error);\n   */\n\n\n  fetch(message, {\n    cache = true,\n    force = false\n  } = {}) {\n    return typeof message === 'string' ? this._fetchId(message, cache, force) : this._fetchMany(message, cache);\n  }\n  /**\n   * Fetches the pinned messages of this channel and returns a collection of them.\n   * <info>The returned Collection does not contain any reaction data of the messages.\n   * Those need to be fetched separately.</info>\n   * @param {boolean} [cache=true] Whether to cache the message(s)\n   * @returns {Promise<Collection<Snowflake, Message>>}\n   * @example\n   * // Get pinned messages\n   * channel.messages.fetchPinned()\n   *   .then(messages => console.log(`Received ${messages.size} messages`))\n   *   .catch(console.error);\n   */\n\n\n  fetchPinned(cache = true) {\n    return this.client.api.channels[this.channel.id].pins.get().then(data => {\n      const messages = new Collection();\n\n      for (const message of data) messages.set(message.id, this.add(message, cache));\n\n      return messages;\n    });\n  }\n  /**\n   * Data that can be resolved to a Message object. This can be:\n   * * A Message\n   * * A Snowflake\n   * @typedef {Message|Snowflake} MessageResolvable\n   */\n\n  /**\n   * Resolves a MessageResolvable to a Message object.\n   * @method resolve\n   * @memberof MessageManager\n   * @instance\n   * @param {MessageResolvable} message The message resolvable to resolve\n   * @returns {?Message}\n   */\n\n  /**\n   * Resolves a MessageResolvable to a Message ID string.\n   * @method resolveID\n   * @memberof MessageManager\n   * @instance\n   * @param {MessageResolvable} message The message resolvable to resolve\n   * @returns {?Snowflake}\n   */\n\n  /**\n   * Edits a message, even if it's not cached.\n   * @param {MessageResolvable} message The message to edit\n   * @param {MessageEditOptions|APIMessage} [options] The options to provide\n   * @returns {Promise<Message>}\n   */\n\n\n  async edit(message, options) {\n    const messageID = this.resolveID(message);\n    if (!messageID) throw new TypeError('INVALID_TYPE', 'message', 'MessageResolvable');\n    const {\n      data,\n      files\n    } = await (options instanceof APIMessage ? options : APIMessage.create(message instanceof Message ? message : this, options)).resolveData().resolveFiles();\n    const d = await this.client.api.channels[this.channel.id].messages[messageID].patch({\n      data,\n      files\n    });\n    const existing = this.cache.get(messageID);\n\n    if (existing) {\n      const clone = existing._clone();\n\n      clone._patch(d);\n\n      return clone;\n    }\n\n    return this.add(d);\n  }\n  /**\n   * Publishes a message in an announcement channel to all channels following it, even if it's not cached.\n   * @param {MessageResolvable} message The message to publish\n   * @returns {Promise<Message>}\n   */\n\n\n  async crosspost(message) {\n    message = this.resolveID(message);\n    if (!message) throw new TypeError('INVALID_TYPE', 'message', 'MessageResolvable');\n    const data = await this.client.api.channels(this.channel.id).messages(message).crosspost.post();\n    return this.cache.get(data.id) || this.add(data);\n  }\n  /**\n   * Pins a message to the channel's pinned messages, even if it's not cached.\n   * @param {MessageResolvable} message The message to pin\n   * @returns {Promise<void>}\n   */\n\n\n  async pin(message) {\n    message = this.resolveID(message);\n    if (!message) throw new TypeError('INVALID_TYPE', 'message', 'MessageResolvable');\n    await this.client.api.channels(this.channel.id).pins(message).put();\n  }\n  /**\n   * Unins a message from the channel's pinned messages, even if it's not cached.\n   * @param {MessageResolvable} message The message to unpin\n   * @returns {Promise<void>}\n   */\n\n\n  async unpin(message) {\n    message = this.resolveID(message);\n    if (!message) throw new TypeError('INVALID_TYPE', 'message', 'MessageResolvable');\n    await this.client.api.channels(this.channel.id).pins(message).delete();\n  }\n  /**\n   * Adds a reaction to a message, even if it's not cached.\n   * @param {MessageResolvable} message The messag to react to\n   * @param {EmojiIdentifierResolvable} emoji The emoji to react with\n   * @returns {Promise<void>}\n   */\n\n\n  async react(message, emoji) {\n    message = this.resolveID(message);\n    if (!message) throw new TypeError('INVALID_TYPE', 'message', 'MessageResolvable');\n    emoji = this.client.emojis.resolveIdentifier(emoji);\n    if (!emoji) throw new TypeError('EMOJI_TYPE', 'emoji', 'EmojiIdentifierResolvable'); // eslint-disable-next-line newline-per-chained-call\n\n    await this.client.api.channels(this.channel.id).messages(message).reactions(emoji, '@me').put();\n  }\n  /**\n   * Deletes a message, even if it's not cached.\n   * @param {MessageResolvable} message The message to delete\n   * @returns {Promise<void>}\n   */\n\n\n  async delete(message) {\n    message = this.resolveID(message);\n    if (!message) throw new TypeError('INVALID_TYPE', 'message', 'MessageResolvable');\n    await this.client.api.channels(this.channel.id).messages(message).delete();\n  }\n\n  async _fetchId(messageID, cache, force) {\n    if (!force) {\n      const existing = this.cache.get(messageID);\n      if (existing && !existing.partial) return existing;\n    }\n\n    const data = await this.client.api.channels[this.channel.id].messages[messageID].get();\n    return this.add(data, cache);\n  }\n\n  async _fetchMany(options = {}, cache) {\n    const data = await this.client.api.channels[this.channel.id].messages.get({\n      query: options\n    });\n    const messages = new Collection();\n\n    for (const message of data) messages.set(message.id, this.add(message, cache));\n\n    return messages;\n  }\n\n}\n\nmodule.exports = MessageManager;\n\n//# sourceURL=webpack://Fosscord/./src/managers/MessageManager.js?")},"./src/managers/PresenceManager.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nconst BaseManager = __webpack_require__(/*! ./BaseManager */ "./src/managers/BaseManager.js");\n\nconst {\n  Presence\n} = __webpack_require__(/*! ../structures/Presence */ "./src/structures/Presence.js");\n/**\n * Manages API methods for Presences and holds their cache.\n * @extends {BaseManager}\n */\n\n\nclass PresenceManager extends BaseManager {\n  constructor(client, iterable) {\n    super(client, iterable, Presence);\n  }\n  /**\n   * The cache of Presences\n   * @type {Collection<Snowflake, Presence>}\n   * @name PresenceManager#cache\n   */\n\n\n  add(data, cache) {\n    const existing = this.cache.get(data.user.id);\n    return existing ? existing.patch(data) : super.add(data, cache, {\n      id: data.user.id\n    });\n  }\n  /**\n   * Data that can be resolved to a Presence object. This can be:\n   * * A Presence\n   * * A UserResolvable\n   * * A Snowflake\n   * @typedef {Presence|UserResolvable|Snowflake} PresenceResolvable\n   */\n\n  /**\n   * Resolves a PresenceResolvable to a Presence object.\n   * @param {PresenceResolvable} presence The presence resolvable to resolve\n   * @returns {?Presence}\n   */\n\n\n  resolve(presence) {\n    const presenceResolvable = super.resolve(presence);\n    if (presenceResolvable) return presenceResolvable;\n    const UserResolvable = this.client.users.resolveID(presence);\n    return super.resolve(UserResolvable) || null;\n  }\n  /**\n   * Resolves a PresenceResolvable to a Presence ID string.\n   * @param {PresenceResolvable} presence The presence resolvable to resolve\n   * @returns {?Snowflake}\n   */\n\n\n  resolveID(presence) {\n    const presenceResolvable = super.resolveID(presence);\n    if (presenceResolvable) return presenceResolvable;\n    const userResolvable = this.client.users.resolveID(presence);\n    return this.cache.has(userResolvable) ? userResolvable : null;\n  }\n\n}\n\nmodule.exports = PresenceManager;\n\n//# sourceURL=webpack://Fosscord/./src/managers/PresenceManager.js?')},"./src/managers/ReactionManager.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nconst BaseManager = __webpack_require__(/*! ./BaseManager */ "./src/managers/BaseManager.js");\n\nconst MessageReaction = __webpack_require__(/*! ../structures/MessageReaction */ "./src/structures/MessageReaction.js");\n/**\n * Manages API methods for reactions and holds their cache.\n * @extends {BaseManager}\n */\n\n\nclass ReactionManager extends BaseManager {\n  constructor(message, iterable) {\n    super(message.client, iterable, MessageReaction);\n    /**\n     * The message that this manager belongs to\n     * @type {Message}\n     */\n\n    this.message = message;\n  }\n\n  add(data, cache) {\n    return super.add(data, cache, {\n      id: data.emoji.id || data.emoji.name,\n      extras: [this.message]\n    });\n  }\n  /**\n   * The reaction cache of this manager\n   * @type {Collection<string|Snowflake, MessageReaction>}\n   * @name ReactionManager#cache\n   */\n\n  /**\n   * Data that can be resolved to a MessageReaction object. This can be:\n   * * A MessageReaction\n   * * A Snowflake\n   * @typedef {MessageReaction|Snowflake} MessageReactionResolvable\n   */\n\n  /**\n   * Resolves a MessageReactionResolvable to a MessageReaction object.\n   * @method resolve\n   * @memberof ReactionManager\n   * @instance\n   * @param {MessageReactionResolvable} reaction The MessageReaction to resolve\n   * @returns {?MessageReaction}\n   */\n\n  /**\n   * Resolves a MessageReactionResolvable to a MessageReaction ID string.\n   * @method resolveID\n   * @memberof ReactionManager\n   * @instance\n   * @param {MessageReactionResolvable} reaction The MessageReaction to resolve\n   * @returns {?Snowflake}\n   */\n\n  /**\n   * Removes all reactions from a message.\n   * @returns {Promise<Message>}\n   */\n\n\n  removeAll() {\n    return this.client.api.channels(this.message.channel.id).messages(this.message.id).reactions.delete().then(() => this.message);\n  }\n\n}\n\nmodule.exports = ReactionManager;\n\n//# sourceURL=webpack://Fosscord/./src/managers/ReactionManager.js?')},"./src/managers/ReactionUserManager.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nconst BaseManager = __webpack_require__(/*! ./BaseManager */ \"./src/managers/BaseManager.js\");\n\nconst {\n  Error\n} = __webpack_require__(/*! ../errors */ \"./src/errors/index.js\");\n\nconst Collection = __webpack_require__(/*! ../util/Collection */ \"./src/util/Collection.js\");\n/**\n * Manages API methods for users who reacted to a reaction and stores their cache.\n * @extends {BaseManager}\n */\n\n\nclass ReactionUserManager extends BaseManager {\n  constructor(client, iterable, reaction) {\n    super(client, iterable, {\n      name: 'User'\n    });\n    /**\n     * The reaction that this manager belongs to\n     * @type {MessageReaction}\n     */\n\n    this.reaction = reaction;\n  }\n  /**\n   * The cache of this manager\n   * @type {Collection<Snowflake, User>}\n   * @name ReactionUserManager#cache\n   */\n\n  /**\n   * Options used to fetch users who gave a reaction.\n   * @typedef {Object} FetchReactionUsersOptions\n   * @property {number} [limit=100] The maximum amount of users to fetch, defaults to `100`\n   * @property {Snowflake} [after] Limit fetching users to those with an id greater than the supplied id\n   */\n\n  /**\n   * Fetches all the users that gave this reaction. Resolves with a collection of users, mapped by their IDs.\n   * @param {FetchReactionUsersOptions} [options] Options for fetching the users\n   * @returns {Promise<Collection<Snowflake, User>>}\n   */\n\n\n  async fetch({\n    limit = 100,\n    after\n  } = {}) {\n    const message = this.reaction.message;\n    const data = await this.client.api.channels[message.channel.id].messages[message.id].reactions[this.reaction.emoji.identifier].get({\n      query: {\n        limit,\n        after\n      }\n    });\n    const users = new Collection();\n\n    for (const rawUser of data) {\n      const user = this.client.users.add(rawUser);\n      this.cache.set(user.id, user);\n      users.set(user.id, user);\n    }\n\n    return users;\n  }\n  /**\n   * Removes a user from this reaction.\n   * @param {UserResolvable} [user=this.client.user] The user to remove the reaction of\n   * @returns {Promise<MessageReaction>}\n   */\n\n\n  remove(user = this.client.user) {\n    const userID = this.client.users.resolveID(user);\n    if (!userID) return Promise.reject(new Error('REACTION_RESOLVE_USER'));\n    const message = this.reaction.message;\n    return this.client.api.channels[message.channel.id].messages[message.id].reactions[this.reaction.emoji.identifier][userID === this.client.user.id ? '@me' : userID].delete().then(() => this.reaction);\n  }\n\n}\n\nmodule.exports = ReactionUserManager;\n\n//# sourceURL=webpack://Fosscord/./src/managers/ReactionUserManager.js?")},"./src/managers/RoleManager.js":function(module,exports){eval('throw new Error("Module parse failed: Unexpected token (75:31)\\nFile was processed with these loaders:\\n * ./node_modules/babel-loader/lib/index.js\\nYou may need an additional loader to handle the result of these loaders.\\n|     for (const role of data) roles.set(role.id, this.add(role, cache));\\n| \\n>     return id ? roles.get(id) ?? null : roles;\\n|   }\\n|   /**");\n\n//# sourceURL=webpack://Fosscord/./src/managers/RoleManager.js?')},"./src/managers/ThreadManager.js":function(module,exports){eval('throw new Error("Module parse failed: Unexpected token (238:41)\\nFile was processed with these loaders:\\n * ./node_modules/babel-loader/lib/index.js\\nYou may need an additional loader to handle the result of these loaders.\\n|       if (before instanceof ThreadChannel || /^\\\\d{16,19}$/.test(String(before))) {\\n|         id = this.resolveID(before);\\n>         timestamp = this.resolve(before)?.archivedAt?.toISOString();\\n|       } else {\\n|         try {");\n\n//# sourceURL=webpack://Fosscord/./src/managers/ThreadManager.js?')},"./src/managers/ThreadMemberManager.js":function(module,exports){eval('throw new Error("Module parse failed: Unexpected token (37:24)\\nFile was processed with these loaders:\\n * ./node_modules/babel-loader/lib/index.js\\nYou may need an additional loader to handle the result of these loaders.\\n|   _add(data, cache = true) {\\n|     const existing = this.cache.get(data.user_id);\\n>     if (cache) existing?._patch(data);\\n|     if (existing) return existing;\\n|     const member = new ThreadMember(this.thread, data);");\n\n//# sourceURL=webpack://Fosscord/./src/managers/ThreadMemberManager.js?')},"./src/managers/UserManager.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nconst BaseManager = __webpack_require__(/*! ./BaseManager */ "./src/managers/BaseManager.js");\n\nconst GuildMember = __webpack_require__(/*! ../structures/GuildMember */ "./src/structures/GuildMember.js");\n\nconst Message = __webpack_require__(/*! ../structures/Message */ "./src/structures/Message.js");\n\nconst ThreadMember = __webpack_require__(/*! ../structures/ThreadMember */ "./src/structures/ThreadMember.js");\n\nconst User = __webpack_require__(/*! ../structures/User */ "./src/structures/User.js");\n/**\n * Manages API methods for users and stores their cache.\n * @extends {BaseManager}\n */\n\n\nclass UserManager extends BaseManager {\n  constructor(client, iterable) {\n    super(client, iterable, User);\n  }\n  /**\n   * The cache of this manager\n   * @type {Collection<Snowflake, User>}\n   * @name UserManager#cache\n   */\n\n  /**\n   * Data that resolves to give a User object. This can be:\n   * * A User object\n   * * A Snowflake\n   * * A Message object (resolves to the message author)\n   * * A GuildMember object\n   * * A ThreadMember object\n   * @typedef {User|Snowflake|Message|GuildMember|ThreadMember} UserResolvable\n   */\n\n  /**\n   * Resolves a UserResolvable to a User object.\n   * @param {UserResolvable} user The UserResolvable to identify\n   * @returns {?User}\n   */\n\n\n  resolve(user) {\n    if (user instanceof GuildMember || user instanceof ThreadMember) return user.user;\n    if (user instanceof Message) return user.author;\n    return super.resolve(user);\n  }\n  /**\n   * Resolves a UserResolvable to a user ID string.\n   * @param {UserResolvable} user The UserResolvable to identify\n   * @returns {?Snowflake}\n   */\n\n\n  resolveID(user) {\n    if (user instanceof ThreadMember) return user.id;\n    if (user instanceof GuildMember) return user.user.id;\n    if (user instanceof Message) return user.author.id;\n    return super.resolveID(user);\n  }\n  /**\n   * Obtains a user from Discord, or the user cache if it\'s already available.\n   * @param {Snowflake} id ID of the user\n   * @param {BaseFetchOptions} [options] Additional options for this fetch\n   * @returns {Promise<User>}\n   */\n\n\n  async fetch(id, {\n    cache = true,\n    force = false\n  } = {}) {\n    if (!force) {\n      const existing = this.cache.get(id);\n      if (existing && !existing.partial) return existing;\n    }\n\n    const data = await this.client.api.users(id).get();\n    return this.add(data, cache);\n  }\n\n}\n\nmodule.exports = UserManager;\n\n//# sourceURL=webpack://Fosscord/./src/managers/UserManager.js?')},"./src/rest/APIRequest.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nconst https = __webpack_require__(/*! https */ 0);\n\nconst FormData = __webpack_require__(/*! @discordjs/form-data */ \"./node_modules/@discordjs/form-data/lib/browser.js\");\n\nconst AbortController = __webpack_require__(/*! abort-controller */ \"./node_modules/abort-controller/browser.js\");\n\nconst fetch = __webpack_require__(/*! node-fetch */ \"./node_modules/node-fetch/browser.js\");\n\nconst {\n  UserAgent\n} = __webpack_require__(/*! ../util/Constants */ \"./src/util/Constants.js\");\n\nif (https.Agent) var agent = new https.Agent({\n  keepAlive: true\n});\n\nclass APIRequest {\n  constructor(rest, method, path, options) {\n    this.rest = rest;\n    this.client = rest.client;\n    this.method = method;\n    this.route = options.route;\n    this.options = options;\n    this.retries = 0;\n    let queryString = '';\n\n    if (options.query) {\n      const query = Object.entries(options.query).filter(([, value]) => value !== null && typeof value !== 'undefined').flatMap(([key, value]) => Array.isArray(value) ? value.map(v => [key, v]) : [[key, value]]);\n      queryString = new URLSearchParams(query).toString();\n    }\n\n    this.path = `${path}${queryString && `?${queryString}`}`;\n  }\n\n  make() {\n    const API = this.options.versioned === false ? this.client.options.http.api : `${this.client.options.http.api}/v${this.client.options.http.version}`;\n    const url = API + this.path;\n    let headers = { ...this.client.options.http.headers\n    };\n    if (this.options.auth !== false) headers.Authorization = this.rest.getAuth();\n    if (this.options.reason) headers['X-Audit-Log-Reason'] = encodeURIComponent(this.options.reason);\n    headers['User-Agent'] = UserAgent;\n    if (this.options.headers) headers = Object.assign(headers, this.options.headers);\n    let body;\n\n    if (this.options.files && this.options.files.length) {\n      body = new FormData();\n\n      for (const file of this.options.files) if (file && file.file) body.append(file.name, file.file, file.name);\n\n      if (typeof this.options.data !== 'undefined') body.append('payload_json', JSON.stringify(this.options.data));\n      headers = Object.assign(headers, body.getHeaders()); // eslint-disable-next-line eqeqeq\n    } else if (this.options.data != null) {\n      body = JSON.stringify(this.options.data);\n      headers['Content-Type'] = 'application/json';\n    }\n\n    const controller = new AbortController();\n    const timeout = this.client.setTimeout(() => controller.abort(), this.client.options.restRequestTimeout);\n    return fetch(url, {\n      method: this.method,\n      headers,\n      agent,\n      body,\n      signal: controller.signal\n    }).finally(() => this.client.clearTimeout(timeout));\n  }\n\n}\n\nmodule.exports = APIRequest;\n\n//# sourceURL=webpack://Fosscord/./src/rest/APIRequest.js?")},"./src/rest/APIRouter.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nconst noop = () => {}; // eslint-disable-line no-empty-function\n\n\nconst methods = ['get', 'post', 'delete', 'patch', 'put'];\nconst reflectors = ['toString', 'valueOf', 'inspect', 'constructor', Symbol.toPrimitive, Symbol.for('nodejs.util.inspect.custom')];\n\nfunction buildRoute(manager) {\n  const route = [''];\n  const handler = {\n    get(target, name) {\n      if (reflectors.includes(name)) return () => route.join('/');\n\n      if (methods.includes(name)) {\n        const routeBucket = [];\n\n        for (let i = 0; i < route.length; i++) {\n          // Reactions routes and sub-routes all share the same bucket\n          if (route[i - 1] === 'reactions') break; // Literal IDs should only be taken account if they are the Major ID (the Channel/Guild ID)\n\n          if (/\\d{16,19}/g.test(route[i]) && !/channels|guilds/.test(route[i - 1])) routeBucket.push(':id'); // All other parts of the route should be considered as part of the bucket identifier\n          else routeBucket.push(route[i]);\n        }\n\n        return options => manager.request(name, route.join('/'), Object.assign({\n          versioned: manager.versioned,\n          route: routeBucket.join('/')\n        }, options));\n      }\n\n      route.push(name);\n      return new Proxy(noop, handler);\n    },\n\n    apply(target, _, args) {\n      route.push(...args.filter(x => x != null)); // eslint-disable-line eqeqeq\n\n      return new Proxy(noop, handler);\n    }\n\n  };\n  return new Proxy(noop, handler);\n}\n\nmodule.exports = buildRoute;\n\n//# sourceURL=webpack://Fosscord/./src/rest/APIRouter.js?")},"./src/rest/DiscordAPIError.js":function(module,exports){eval('throw new Error("Module parse failed: Unexpected token (44:36)\\nFile was processed with these loaders:\\n * ./node_modules/babel-loader/lib/index.js\\nYou may need an additional loader to handle the result of these loaders.\\n|     this.requestData = {\\n|       json: request.options.data,\\n>       files: request.options.files ?? []\\n|     };\\n|   }");\n\n//# sourceURL=webpack://Fosscord/./src/rest/DiscordAPIError.js?')},"./src/rest/HTTPError.js":function(module,exports){eval('throw new Error("Module parse failed: Unexpected token (56:36)\\nFile was processed with these loaders:\\n * ./node_modules/babel-loader/lib/index.js\\nYou may need an additional loader to handle the result of these loaders.\\n|     this.requestData = {\\n|       json: request.options.data,\\n>       files: request.options.files ?? []\\n|     };\\n|   }");\n\n//# sourceURL=webpack://Fosscord/./src/rest/HTTPError.js?')},"./src/rest/RESTManager.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nconst APIRequest = __webpack_require__(/*! ./APIRequest */ "./src/rest/APIRequest.js");\n\nconst routeBuilder = __webpack_require__(/*! ./APIRouter */ "./src/rest/APIRouter.js");\n\nconst RequestHandler = __webpack_require__(/*! ./RequestHandler */ "./src/rest/RequestHandler.js");\n\nconst {\n  Error\n} = __webpack_require__(/*! ../errors */ "./src/errors/index.js");\n\nconst Collection = __webpack_require__(/*! ../util/Collection */ "./src/util/Collection.js");\n\nconst {\n  Endpoints\n} = __webpack_require__(/*! ../util/Constants */ "./src/util/Constants.js");\n\nclass RESTManager {\n  constructor(client) {\n    this.client = client;\n    this.handlers = new Collection();\n    this.versioned = true;\n    this.globalLimit = client.options.restGlobalRateLimit > 0 ? client.options.restGlobalRateLimit : Infinity;\n    this.globalRemaining = this.globalLimit;\n    this.globalReset = null;\n    this.globalDelay = null;\n\n    if (client.options.restSweepInterval > 0) {\n      const interval = client.setInterval(() => {\n        this.handlers.sweep(handler => handler._inactive);\n      }, client.options.restSweepInterval * 1000);\n      interval.unref();\n    }\n  }\n\n  get api() {\n    return routeBuilder(this);\n  }\n\n  getAuth() {\n    const token = this.client.token || this.client.accessToken;\n    if (token) return `${token}`;\n    throw new Error(\'TOKEN_MISSING\');\n  }\n\n  get cdn() {\n    return Endpoints.CDN(this.client.options.http.cdn);\n  }\n\n  request(method, url, options = {}) {\n    const apiRequest = new APIRequest(this, method, url, options);\n    let handler = this.handlers.get(apiRequest.route);\n\n    if (!handler) {\n      handler = new RequestHandler(this);\n      this.handlers.set(apiRequest.route, handler);\n    }\n\n    return handler.push(apiRequest);\n  }\n\n  get endpoint() {\n    return this.client.options.http.api;\n  }\n\n  set endpoint(endpoint) {\n    this.client.options.http.api = endpoint;\n  }\n\n}\n\nmodule.exports = RESTManager;\n\n//# sourceURL=webpack://Fosscord/./src/rest/RESTManager.js?')},"./src/rest/RateLimitError.js":function(module,exports,__webpack_require__){"use strict";eval("\n/**\n * Represents a RateLimit error from a request.\n * @extends Error\n */\n\nclass RateLimitError extends Error {\n  constructor({\n    timeout,\n    limit,\n    method,\n    path,\n    route,\n    global\n  }) {\n    super(`A ${global ? 'global ' : ''}rate limit was hit on route ${route}`);\n    /**\n     * The name of the error\n     * @type {string}\n     */\n\n    this.name = 'RateLimitError';\n    /**\n     * Time until this rate limit ends, in ms\n     * @type {number}\n     */\n\n    this.timeout = timeout;\n    /**\n     * The HTTP method used for the request\n     * @type {string}\n     */\n\n    this.method = method;\n    /**\n     * The path of the request relative to the HTTP endpoint\n     * @type {string}\n     */\n\n    this.path = path;\n    /**\n     * The route of the request relative to the HTTP endpoint\n     * @type {string}\n     */\n\n    this.route = route;\n    /**\n     * Whether this rate limit is global\n     * @type {boolean}\n     */\n\n    this.global = global;\n    /**\n     * The maximum amount of requests of this end point\n     * @type {number}\n     */\n\n    this.limit = limit;\n  }\n\n}\n\nmodule.exports = RateLimitError;\n\n//# sourceURL=webpack://Fosscord/./src/rest/RateLimitError.js?")},"./src/rest/RequestHandler.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nconst {\n  AsyncQueue\n} = __webpack_require__(/*! @sapphire/async-queue */ \"./node_modules/@sapphire/async-queue/dist/index.umd.js\");\n\nconst DiscordAPIError = __webpack_require__(/*! ./DiscordAPIError */ \"./src/rest/DiscordAPIError.js\");\n\nconst HTTPError = __webpack_require__(/*! ./HTTPError */ \"./src/rest/HTTPError.js\");\n\nconst RateLimitError = __webpack_require__(/*! ./RateLimitError */ \"./src/rest/RateLimitError.js\");\n\nconst {\n  Events: {\n    DEBUG,\n    RATE_LIMIT,\n    INVALID_REQUEST_WARNING\n  },\n  browser\n} = __webpack_require__(/*! ../util/Constants */ \"./src/util/Constants.js\");\n\nconst Util = __webpack_require__(/*! ../util/Util */ \"./src/util/Util.js\");\n\nfunction parseResponse(res) {\n  if (res.headers.get('content-type').startsWith('application/json')) return res.json();\n  if (browser) return res.blob();\n  return res.buffer();\n}\n\nfunction getAPIOffset(serverDate) {\n  return new Date(serverDate).getTime() - Date.now();\n}\n\nfunction calculateReset(reset, resetAfter, serverDate) {\n  // Use direct reset time when available, server date becomes irrelevant in this case\n  if (resetAfter) {\n    return Date.now() + Number(resetAfter) * 1000;\n  }\n\n  return new Date(Number(reset) * 1000).getTime() - getAPIOffset(serverDate);\n}\n/* Invalid request limiting is done on a per-IP basis, not a per-token basis.\n * The best we can do is track invalid counts process-wide (on the theory that\n * users could have multiple bots run from one process) rather than per-bot.\n * Therefore, store these at file scope here rather than in the client's\n * RESTManager object.\n */\n\n\nlet invalidCount = 0;\nlet invalidCountResetTime = null;\n\nclass RequestHandler {\n  constructor(manager) {\n    this.manager = manager;\n    this.queue = new AsyncQueue();\n    this.reset = -1;\n    this.remaining = -1;\n    this.limit = -1;\n  }\n\n  async push(request) {\n    await this.queue.wait();\n\n    try {\n      return await this.execute(request);\n    } finally {\n      this.queue.shift();\n    }\n  }\n\n  get globalLimited() {\n    return this.manager.globalRemaining <= 0 && Date.now() < this.manager.globalReset;\n  }\n\n  get localLimited() {\n    return this.remaining <= 0 && Date.now() < this.reset;\n  }\n\n  get limited() {\n    return this.globalLimited || this.localLimited;\n  }\n\n  get _inactive() {\n    return this.queue.remaining === 0 && !this.limited;\n  }\n\n  globalDelayFor(ms) {\n    return new Promise(resolve => {\n      this.manager.client.setTimeout(() => {\n        this.manager.globalDelay = null;\n        resolve();\n      }, ms);\n    });\n  }\n  /*\n   * Determines whether the request should be queued or whether a RateLimitError should be thrown\n   */\n\n\n  async onRateLimit(request, limit, timeout, isGlobal) {\n    const {\n      options\n    } = this.manager.client;\n    if (!options.rejectOnRateLimit) return;\n    const rateLimitData = {\n      timeout,\n      limit,\n      method: request.method,\n      path: request.path,\n      route: request.route,\n      global: isGlobal\n    };\n    const shouldThrow = typeof options.rejectOnRateLimit === 'function' ? await options.rejectOnRateLimit(rateLimitData) : options.rejectOnRateLimit.some(route => rateLimitData.route.startsWith(route.toLowerCase()));\n\n    if (shouldThrow) {\n      throw new RateLimitError(rateLimitData);\n    }\n  }\n\n  async execute(request) {\n    /*\n     * After calculations have been done, pre-emptively stop further requests\n     * Potentially loop until this task can run if e.g. the global rate limit is hit twice\n     */\n    while (this.limited) {\n      const isGlobal = this.globalLimited;\n      let limit, timeout, delayPromise;\n\n      if (isGlobal) {\n        // Set the variables based on the global rate limit\n        limit = this.manager.globalLimit;\n        timeout = this.manager.globalReset + this.manager.client.options.restTimeOffset - Date.now();\n      } else {\n        // Set the variables based on the route-specific rate limit\n        limit = this.limit;\n        timeout = this.reset + this.manager.client.options.restTimeOffset - Date.now();\n      }\n\n      if (this.manager.client.listenerCount(RATE_LIMIT)) {\n        /**\n         * Emitted when the client hits a rate limit while making a request\n         * @event Client#rateLimit\n         * @param {RateLimitData} rateLimitData Object containing the rate limit info\n         */\n        this.manager.client.emit(RATE_LIMIT, {\n          timeout,\n          limit,\n          method: request.method,\n          path: request.path,\n          route: request.route,\n          global: isGlobal\n        });\n      }\n\n      if (isGlobal) {\n        // If this is the first task to reach the global timeout, set the global delay\n        if (!this.manager.globalDelay) {\n          // The global delay function should clear the global delay state when it is resolved\n          this.manager.globalDelay = this.globalDelayFor(timeout);\n        }\n\n        delayPromise = this.manager.globalDelay;\n      } else {\n        delayPromise = Util.delayFor(timeout);\n      } // Determine whether a RateLimitError should be thrown\n\n\n      await this.onRateLimit(request, limit, timeout, isGlobal); // eslint-disable-line no-await-in-loop\n      // Wait for the timeout to expire in order to avoid an actual 429\n\n      await delayPromise; // eslint-disable-line no-await-in-loop\n    } // As the request goes out, update the global usage information\n\n\n    if (!this.manager.globalReset || this.manager.globalReset < Date.now()) {\n      this.manager.globalReset = Date.now() + 1000;\n      this.manager.globalRemaining = this.manager.globalLimit;\n    }\n\n    this.manager.globalRemaining--; // Perform the request\n\n    let res;\n\n    try {\n      res = await request.make();\n    } catch (error) {\n      // Retry the specified number of times for request abortions\n      if (request.retries === this.manager.client.options.retryLimit) {\n        throw new HTTPError(error.message, error.constructor.name, error.status, request);\n      }\n\n      request.retries++;\n      return this.execute(request);\n    }\n\n    let sublimitTimeout;\n\n    if (res && res.headers) {\n      const serverDate = res.headers.get('date');\n      const limit = res.headers.get('x-ratelimit-limit');\n      const remaining = res.headers.get('x-ratelimit-remaining');\n      const reset = res.headers.get('x-ratelimit-reset');\n      const resetAfter = res.headers.get('x-ratelimit-reset-after');\n      this.limit = limit ? Number(limit) : Infinity;\n      this.remaining = remaining ? Number(remaining) : 1;\n      this.reset = reset || resetAfter ? calculateReset(reset, resetAfter, serverDate) : Date.now(); // https://github.com/discordapp/discord-api-docs/issues/182\n\n      if (!resetAfter && request.route.includes('reactions')) {\n        this.reset = new Date(serverDate).getTime() - getAPIOffset(serverDate) + 250;\n      } // Handle retryAfter, which means we have actually hit a rate limit\n\n\n      let retryAfter = res.headers.get('retry-after');\n      retryAfter = retryAfter ? Number(retryAfter) * 1000 : -1;\n\n      if (retryAfter > 0) {\n        // If the global ratelimit header is set, that means we hit the global rate limit\n        if (res.headers.get('x-ratelimit-global')) {\n          this.manager.globalRemaining = 0;\n          this.manager.globalReset = Date.now() + retryAfter;\n        } else if (!this.localLimited) {\n          /*\n           * This is a sublimit (e.g. 2 channel name changes/10 minutes) since the headers don't indicate a\n           * route-wide rate limit. Don't update remaining or reset to avoid rate limiting the whole\n           * endpoint, just set a reset time on the request itself to avoid retrying too soon.\n           */\n          sublimitTimeout = retryAfter;\n        }\n      }\n    } // Count the invalid requests\n\n\n    if (res.status === 401 || res.status === 403 || res.status === 429) {\n      if (!invalidCountResetTime || invalidCountResetTime < Date.now()) {\n        invalidCountResetTime = Date.now() + 1000 * 60 * 10;\n        invalidCount = 0;\n      }\n\n      invalidCount++;\n      const emitInvalid = this.manager.client.listenerCount(INVALID_REQUEST_WARNING) && this.manager.client.options.invalidRequestWarningInterval > 0 && invalidCount % this.manager.client.options.invalidRequestWarningInterval === 0;\n\n      if (emitInvalid) {\n        /**\n         * @typedef {Object} InvalidRequestWarningData\n         * @property {number} count Number of invalid requests that have been made in the window\n         * @property {number} remainingTime Time in ms remaining before the count resets\n         */\n\n        /**\n         * Emitted periodically when the process sends invalid requests to let users avoid the\n         * 10k invalid requests in 10 minutes threshold that causes a ban\n         * @event Client#invalidRequestWarning\n         * @param {InvalidRequestWarningData} invalidRequestWarningData Object containing the invalid request info\n         */\n        this.manager.client.emit(INVALID_REQUEST_WARNING, {\n          count: invalidCount,\n          remainingTime: invalidCountResetTime - Date.now()\n        });\n      }\n    } // Handle 2xx and 3xx responses\n\n\n    if (res.ok) {\n      // Nothing wrong with the request, proceed with the next one\n      return parseResponse(res);\n    } // Handle 4xx responses\n\n\n    if (res.status >= 400 && res.status < 500) {\n      // Handle ratelimited requests\n      if (res.status === 429) {\n        const isGlobal = this.globalLimited;\n        let limit, timeout;\n\n        if (isGlobal) {\n          // Set the variables based on the global rate limit\n          limit = this.manager.globalLimit;\n          timeout = this.manager.globalReset + this.manager.client.options.restTimeOffset - Date.now();\n        } else {\n          // Set the variables based on the route-specific rate limit\n          limit = this.limit;\n          timeout = this.reset + this.manager.client.options.restTimeOffset - Date.now();\n        }\n\n        this.manager.client.emit(DEBUG, `Hit a 429 while executing a request.\n    Global  : ${isGlobal}\n    Method  : ${request.method}\n    Path    : ${request.path}\n    Route   : ${request.route}\n    Limit   : ${limit}\n    Timeout : ${timeout}ms\n    Sublimit: ${sublimitTimeout ? `${sublimitTimeout}ms` : 'None'}`);\n        await this.onRateLimit(request, limit, timeout, isGlobal); // If caused by a sublimit, wait it out here so other requests on the route can be handled\n\n        if (sublimitTimeout) {\n          await Util.delayFor(sublimitTimeout);\n        }\n\n        return this.execute(request);\n      } // Handle possible malformed requests\n\n\n      let data;\n\n      try {\n        data = await parseResponse(res);\n      } catch (err) {\n        throw new HTTPError(err.message, err.constructor.name, err.status, request);\n      }\n\n      throw new DiscordAPIError(data, res.status, request);\n    } // Handle 5xx responses\n\n\n    if (res.status >= 500 && res.status < 600) {\n      // Retry the specified number of times for possible serverside issues\n      if (request.retries === this.manager.client.options.retryLimit) {\n        throw new HTTPError(res.statusText, res.constructor.name, res.status, request);\n      }\n\n      request.retries++;\n      return this.execute(request);\n    } // Fallback in the rare case a status code outside the range 200..=599 is returned\n\n\n    return null;\n  }\n\n}\n\nmodule.exports = RequestHandler;\n\n//# sourceURL=webpack://Fosscord/./src/rest/RequestHandler.js?")},"./src/structures/APIMessage.js":function(module,exports){eval('throw new Error("Module parse failed: Unexpected token (190:47)\\nFile was processed with these loaders:\\n * ./node_modules/babel-loader/lib/index.js\\nYou may need an additional loader to handle the result of these loaders.\\n|     }\\n| \\n>     const components = this.options.components?.map(c => BaseMessageComponent.create(Array.isArray(c) ? {\\n|       type: MessageComponentTypes.ACTION_ROW,\\n|       components: c");\n\n//# sourceURL=webpack://Fosscord/./src/structures/APIMessage.js?')},"./src/structures/ApplicationCommand.js":function(module,exports){eval('throw new Error("Module parse failed: Unexpected token (30:24)\\nFile was processed with these loaders:\\n * ./node_modules/babel-loader/lib/index.js\\nYou may need an additional loader to handle the result of these loaders.\\n|      */\\n| \\n>     this.guild = guild ?? null;\\n| \\n|     this._patch(data);");\n\n//# sourceURL=webpack://Fosscord/./src/structures/ApplicationCommand.js?')},"./src/structures/Base.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nconst Util = __webpack_require__(/*! ../util/Util */ \"./src/util/Util.js\");\n/**\n * Represents a data model that is identifiable by a Snowflake (i.e. Discord API data models).\n * @abstract\n */\n\n\nclass Base {\n  constructor(client) {\n    /**\n     * The client that instantiated this\n     * @name Base#client\n     * @type {Client}\n     * @readonly\n     */\n    Object.defineProperty(this, 'client', {\n      value: client\n    });\n  }\n\n  _clone() {\n    return Object.assign(Object.create(this), this);\n  }\n\n  _patch(data) {\n    return data;\n  }\n\n  _update(data) {\n    const clone = this._clone();\n\n    this._patch(data);\n\n    return clone;\n  }\n\n  toJSON(...props) {\n    return Util.flatten(this, ...props);\n  }\n\n  valueOf() {\n    return this.id;\n  }\n\n}\n\nmodule.exports = Base;\n\n//# sourceURL=webpack://Fosscord/./src/structures/Base.js?")},"./src/structures/BaseGuild.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nconst Base = __webpack_require__(/*! ./Base */ \"./src/structures/Base.js\");\n\nconst SnowflakeUtil = __webpack_require__(/*! ../util/SnowflakeUtil */ \"./src/util/SnowflakeUtil.js\");\n/**\n * The base class for {@link Guild}, {@link OAuth2Guild} and {@link InviteGuild}.\n * @extends {Base}\n * @abstract\n */\n\n\nclass BaseGuild extends Base {\n  constructor(client, data) {\n    super(client);\n    /**\n     * The ID of this guild\n     * @type {Snowflake}\n     */\n\n    this.id = data.id;\n    /**\n     * The name of this guild\n     * @type {string}\n     */\n\n    this.name = data.name;\n    /**\n     * The icon hash of this guild\n     * @type {?string}\n     */\n\n    this.icon = data.icon;\n    /**\n     * An array of features available to this guild\n     * @type {Features[]}\n     */\n\n    this.features = data.features;\n  }\n  /**\n   * The timestamp this guild was created at\n   * @type {number}\n   * @readonly\n   */\n\n\n  get createdTimestamp() {\n    return SnowflakeUtil.deconstruct(this.id).timestamp;\n  }\n  /**\n   * The time this guild was created at\n   * @type {Date}\n   * @readonly\n   */\n\n\n  get createdAt() {\n    return new Date(this.createdTimestamp);\n  }\n  /**\n   * The acronym that shows up in place of a guild icon\n   * @type {string}\n   * @readonly\n   */\n\n\n  get nameAcronym() {\n    return this.name.replace(/'s /g, ' ').replace(/\\w+/g, e => e[0]).replace(/\\s/g, '');\n  }\n  /**\n   * Whether this guild is partnered\n   * @type {boolean}\n   * @readonly\n   */\n\n\n  get partnered() {\n    return this.features.includes('PARTNERED');\n  }\n  /**\n   * Whether this guild is verified\n   * @type {boolean}\n   * @readonly\n   */\n\n\n  get verified() {\n    return this.features.includes('VERIFIED');\n  }\n  /**\n   * The URL to this guild's icon.\n   * @param {ImageURLOptions} [options={}] Options for the Image URL\n   * @returns {?string}\n   */\n\n\n  iconURL({\n    format,\n    size,\n    dynamic\n  } = {}) {\n    if (!this.icon) return null;\n    return this.client.rest.cdn.Icon(this.id, this.icon, format, size, dynamic);\n  }\n  /**\n   * Fetches this guild.\n   * @returns {Promise<Guild>}\n   */\n\n\n  async fetch() {\n    const data = await this.client.api.guilds(this.id).get({\n      query: {\n        with_counts: true\n      }\n    });\n    return this.client.guilds.add(data);\n  }\n  /**\n   * When concatenated with a string, this automatically returns the guild's name instead of the Guild object.\n   * @returns {string}\n   */\n\n\n  toString() {\n    return this.name;\n  }\n\n}\n\nmodule.exports = BaseGuild;\n\n//# sourceURL=webpack://Fosscord/./src/structures/BaseGuild.js?")},"./src/structures/BaseGuildEmoji.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nconst Emoji = __webpack_require__(/*! ./Emoji */ \"./src/structures/Emoji.js\");\n/**\n * Parent class for {@link GuildEmoji} and {@link GuildPreviewEmoji}.\n * @extends {Emoji}\n * @abstract\n */\n\n\nclass BaseGuildEmoji extends Emoji {\n  constructor(client, data, guild) {\n    super(client, data);\n    /**\n     * The guild this emoji is a part of\n     * @type {Guild|GuildPreview}\n     */\n\n    this.guild = guild;\n    this.requiresColons = null;\n    this.managed = null;\n    this.available = null;\n\n    this._patch(data);\n  }\n\n  _patch(data) {\n    if (data.name) this.name = data.name;\n\n    if (typeof data.require_colons !== 'undefined') {\n      /**\n       * Whether or not this emoji requires colons surrounding it\n       * @type {?boolean}\n       */\n      this.requiresColons = data.require_colons;\n    }\n\n    if (typeof data.managed !== 'undefined') {\n      /**\n       * Whether this emoji is managed by an external service\n       * @type {?boolean}\n       */\n      this.managed = data.managed;\n    }\n\n    if (typeof data.available !== 'undefined') {\n      /**\n       * Whether this emoji is available\n       * @type {?boolean}\n       */\n      this.available = data.available;\n    }\n  }\n\n}\n\nmodule.exports = BaseGuildEmoji;\n\n//# sourceURL=webpack://Fosscord/./src/structures/BaseGuildEmoji.js?")},"./src/structures/BaseGuildVoiceChannel.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nconst GuildChannel = __webpack_require__(/*! ./GuildChannel */ "./src/structures/GuildChannel.js");\n\nconst Collection = __webpack_require__(/*! ../util/Collection */ "./src/util/Collection.js");\n\nconst Permissions = __webpack_require__(/*! ../util/Permissions */ "./src/util/Permissions.js");\n/**\n * Represents a voice-based guild channel on Discord.\n * @extends {GuildChannel}\n */\n\n\nclass BaseGuildVoiceChannel extends GuildChannel {\n  _patch(data) {\n    super._patch(data);\n    /**\n     * The RTC region for this voice-based channel. This region is automatically selected if `null`.\n     * @type {?string}\n     */\n\n\n    this.rtcRegion = data.rtc_region;\n    /**\n     * The bitrate of this voice-based channel\n     * @type {number}\n     */\n\n    this.bitrate = data.bitrate;\n    /**\n     * The maximum amount of users allowed in this channel.\n     * @type {number}\n     */\n\n    this.userLimit = data.user_limit;\n  }\n  /**\n   * The members in this voice-based channel\n   * @type {Collection<Snowflake, GuildMember>}\n   * @readonly\n   */\n\n\n  get members() {\n    const coll = new Collection();\n\n    for (const state of this.guild.voiceStates.cache.values()) {\n      if (state.channelID === this.id && state.member) {\n        coll.set(state.id, state.member);\n      }\n    }\n\n    return coll;\n  }\n  /**\n   * Checks if the voice-based channel is full\n   * @type {boolean}\n   * @readonly\n   */\n\n\n  get full() {\n    return this.userLimit > 0 && this.members.size >= this.userLimit;\n  }\n  /**\n   * Whether the channel is joinable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n\n\n  get joinable() {\n    if (!this.viewable) return false;\n    if (!this.permissionsFor(this.client.user).has(Permissions.FLAGS.CONNECT, false)) return false;\n    return true;\n  }\n  /**\n   * Sets the RTC region of the channel.\n   * @param {?string} region The new region of the channel. Set to `null` to remove a specific region for the channel\n   * @returns {Promise<BaseGuildVoiceChannel>}\n   * @example\n   * // Set the RTC region to europe\n   * channel.setRTCRegion(\'europe\');\n   * @example\n   * // Remove a fixed region for this channel - let Discord decide automatically\n   * channel.setRTCRegion(null);\n   */\n\n\n  setRTCRegion(region) {\n    return this.edit({\n      rtcRegion: region\n    });\n  }\n\n}\n\nmodule.exports = BaseGuildVoiceChannel;\n\n//# sourceURL=webpack://Fosscord/./src/structures/BaseGuildVoiceChannel.js?')},"./src/structures/BaseMessageComponent.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nconst {\n  TypeError\n} = __webpack_require__(/*! ../errors */ \"./src/errors/index.js\");\n\nconst {\n  MessageComponentTypes,\n  Events\n} = __webpack_require__(/*! ../util/Constants */ \"./src/util/Constants.js\");\n/**\n * Represents an interactive component of a Message. It should not be necessary to construct this directly.\n * See {@link MessageComponent}\n */\n\n\nclass BaseMessageComponent {\n  /**\n   * Options for a BaseMessageComponent\n   * @typedef {Object} BaseMessageComponentOptions\n   * @property {MessageComponentTypeResolvable} type The type of this component\n   */\n\n  /**\n   * Data that can be resolved into options for a MessageComponent. This can be:\n   * * MessageActionRowOptions\n   * * MessageButtonOptions\n   * * MessageSelectMenuOptions\n   * @typedef {MessageActionRowOptions|MessageButtonOptions|MessageSelectMenuOptions} MessageComponentOptions\n   */\n\n  /**\n   * Components that can be sent in a message. This can be:\n   * * MessageActionRow\n   * * MessageButton\n   * * MessageSelectMenu\n   * @typedef {MessageActionRow|MessageButton|MessageSelectMenu} MessageComponent\n   */\n\n  /**\n   * Data that can be resolved to a MessageComponentType. This can be:\n   * * MessageComponentType\n   * * string\n   * * number\n   * @typedef {string|number|MessageComponentType} MessageComponentTypeResolvable\n   */\n\n  /**\n   * @param {BaseMessageComponent|BaseMessageComponentOptions} [data={}] The options for this component\n   */\n  constructor(data) {\n    /**\n     * The type of this component\n     * @type {?MessageComponentType}\n     */\n    this.type = 'type' in data ? BaseMessageComponent.resolveType(data.type) : null;\n  }\n  /**\n   * Constructs a MessageComponent based on the type of the incoming data\n   * @param {MessageComponentOptions} data Data for a MessageComponent\n   * @param {Client|WebhookClient} [client] Client constructing this component\n   * @param {boolean} [skipValidation=false] Whether or not to validate the component type\n   * @returns {?MessageComponent}\n   * @private\n   */\n\n\n  static create(data, client, skipValidation = false) {\n    let component;\n    let type = data.type;\n    if (typeof type === 'string') type = MessageComponentTypes[type];\n\n    switch (type) {\n      case MessageComponentTypes.ACTION_ROW:\n        {\n          const MessageActionRow = __webpack_require__(/*! ./MessageActionRow */ \"./src/structures/MessageActionRow.js\");\n\n          component = new MessageActionRow(data);\n          break;\n        }\n\n      case MessageComponentTypes.BUTTON:\n        {\n          const MessageButton = __webpack_require__(/*! ./MessageButton */ \"./src/structures/MessageButton.js\");\n\n          component = new MessageButton(data);\n          break;\n        }\n\n      case MessageComponentTypes.SELECT_MENU:\n        {\n          const MessageSelectMenu = __webpack_require__(/*! ./MessageSelectMenu */ \"./src/structures/MessageSelectMenu.js\");\n\n          component = new MessageSelectMenu(data);\n          break;\n        }\n\n      default:\n        if (client) {\n          client.emit(Events.DEBUG, `[BaseMessageComponent] Received component with unknown type: ${data.type}`);\n        } else if (!skipValidation) {\n          throw new TypeError('INVALID_TYPE', 'data.type', 'valid MessageComponentType');\n        }\n\n    }\n\n    return component;\n  }\n  /**\n   * Resolves the type of a MessageComponent\n   * @param {MessageComponentTypeResolvable} type The type to resolve\n   * @returns {MessageComponentType}\n   * @private\n   */\n\n\n  static resolveType(type) {\n    return typeof type === 'string' ? type : MessageComponentTypes[type];\n  }\n\n}\n\nmodule.exports = BaseMessageComponent;\n\n//# sourceURL=webpack://Fosscord/./src/structures/BaseMessageComponent.js?")},"./src/structures/ButtonInteraction.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nconst MessageComponentInteraction = __webpack_require__(/*! ./MessageComponentInteraction */ "./src/structures/MessageComponentInteraction.js");\n/**\n * Represents a button interaction.\n * @extends {MessageComponentInteraction}\n */\n\n\nclass ButtonInteraction extends MessageComponentInteraction {}\n\nmodule.exports = ButtonInteraction;\n\n//# sourceURL=webpack://Fosscord/./src/structures/ButtonInteraction.js?')},"./src/structures/CategoryChannel.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nconst GuildChannel = __webpack_require__(/*! ./GuildChannel */ "./src/structures/GuildChannel.js");\n/**\n * Represents a guild category channel on Discord.\n * @extends {GuildChannel}\n */\n\n\nclass CategoryChannel extends GuildChannel {\n  /**\n   * Channels that are a part of this category\n   * @type {Collection<Snowflake, GuildChannel>}\n   * @readonly\n   */\n  get children() {\n    return this.guild.channels.cache.filter(c => c.parentID === this.id);\n  }\n  /**\n   * Sets the category parent of this channel.\n   * <warn>It is not currently possible to set the parent of a CategoryChannel.</warn>\n   * @method setParent\n   * @memberof CategoryChannel\n   * @instance\n   * @param {?(GuildChannel|Snowflake)} channel The channel to set as parent\n   * @param {SetParentOptions} [options={}] The options for setting the parent\n   * @returns {Promise<GuildChannel>}\n   */\n\n\n}\n\nmodule.exports = CategoryChannel;\n\n//# sourceURL=webpack://Fosscord/./src/structures/CategoryChannel.js?')},"./src/structures/Channel.js":function(module,exports){eval("throw new Error(\"Module parse failed: Unexpected token (187:29)\\nFile was processed with these loaders:\\n * ./node_modules/babel-loader/lib/index.js\\nYou may need an additional loader to handle the result of these loaders.\\n|               const ThreadChannel = Structures.get('ThreadChannel');\\n|               channel = new ThreadChannel(guild, data);\\n>               channel.parent?.threads.cache.set(channel.id, channel);\\n|               break;\\n|             }\");\n\n//# sourceURL=webpack://Fosscord/./src/structures/Channel.js?")},"./src/structures/ClientApplication.js":function(module,exports){eval('throw new Error("Module parse failed: Unexpected token (41:35)\\nFile was processed with these loaders:\\n * ./node_modules/babel-loader/lib/index.js\\nYou may need an additional loader to handle the result of these loaders.\\n|      */\\n| \\n>     this.cover = data.cover_image ?? this.cover ?? null;\\n|     /**\\n|      * The application\'s RPC origins, if enabled");\n\n//# sourceURL=webpack://Fosscord/./src/structures/ClientApplication.js?')},"./src/structures/ClientPresence.js":function(module,exports){eval("throw new Error(\"Module parse failed: Unexpected token (70:19)\\nFile was processed with these loaders:\\n * ./node_modules/babel-loader/lib/index.js\\nYou may need an additional loader to handle the result of these loaders.\\n|     };\\n| \\n>     if (activities?.length) {\\n|       for (const [i, activity] of activities.entries()) {\\n|         if (typeof activity.name !== 'string') throw new TypeError('INVALID_TYPE', `activities[${i}].name`, 'string');\");\n\n//# sourceURL=webpack://Fosscord/./src/structures/ClientPresence.js?")},"./src/structures/ClientUser.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nconst DataResolver = __webpack_require__(/*! ../util/DataResolver */ \"./src/util/DataResolver.js\");\n\nconst Structures = __webpack_require__(/*! ../util/Structures */ \"./src/util/Structures.js\");\n/**\n * Represents the logged in client's Discord user.\n * @extends {User}\n */\n\n\nclass ClientUser extends Structures.get('User') {\n  constructor(client, data) {\n    super(client, data);\n    this._typing = new Map();\n  }\n\n  _patch(data) {\n    super._patch(data);\n\n    if ('verified' in data) {\n      /**\n       * Whether or not this account has been verified\n       * @type {boolean}\n       */\n      this.verified = data.verified;\n    }\n\n    if ('mfa_enabled' in data) {\n      /**\n       * If the bot's {@link ClientApplication#owner Owner} has MFA enabled on their account\n       * @type {?boolean}\n       */\n      this.mfaEnabled = typeof data.mfa_enabled === 'boolean' ? data.mfa_enabled : null;\n    } else if (typeof this.mfaEnabled === 'undefined') {\n      this.mfaEnabled = null;\n    }\n\n    if (data.token) this.client.token = data.token;\n  }\n  /**\n   * ClientUser's presence\n   * @type {Presence}\n   * @readonly\n   */\n\n\n  get presence() {\n    return this.client.presence;\n  }\n  /**\n   * Edits the logged in client.\n   * @param {APIModifyClientData} data The new data\n   * @param {string} [data.username] The new username\n   * @param {BufferResolvable|Base64Resolvable} [data.avatar] The new avatar\n   */\n\n\n  async edit(data) {\n    const newData = await this.client.api.users('@me').patch({\n      data\n    });\n    this.client.token = newData.token;\n    const {\n      updated\n    } = this.client.actions.UserUpdate.handle(newData);\n    if (updated) return updated;\n    return this;\n  }\n  /**\n   * Sets the username of the logged in client.\n   * <info>Changing usernames in Discord is heavily rate limited, with only 2 requests\n   * every hour. Use this sparingly!</info>\n   * @param {string} username The new username\n   * @returns {Promise<ClientUser>}\n   * @example\n   * // Set username\n   * client.user.setUsername('discordjs')\n   *   .then(user => console.log(`My new username is ${user.username}`))\n   *   .catch(console.error);\n   */\n\n\n  setUsername(username) {\n    return this.edit({\n      username\n    });\n  }\n  /**\n   * Sets the avatar of the logged in client.\n   * @param {BufferResolvable|Base64Resolvable} avatar The new avatar\n   * @returns {Promise<ClientUser>}\n   * @example\n   * // Set avatar\n   * client.user.setAvatar('./avatar.png')\n   *   .then(user => console.log(`New avatar set!`))\n   *   .catch(console.error);\n   */\n\n\n  async setAvatar(avatar) {\n    return this.edit({\n      avatar: await DataResolver.resolveImage(avatar)\n    });\n  }\n  /**\n   * Options for setting activities\n   * @typedef {Object} ActivitiesOptions\n   * @property {string} [name] Name of the activity\n   * @property {ActivityType|number} [type] Type of the activity\n   * @property {string} [url] Twitch / YouTube stream URL\n   */\n\n  /**\n   * Data resembling a raw Discord presence.\n   * @typedef {Object} PresenceData\n   * @property {PresenceStatusData} [status] Status of the user\n   * @property {boolean} [afk] Whether the user is AFK\n   * @property {ActivitiesOptions[]} [activities] Activity the user is playing\n   * @property {?number|number[]} [shardID] Shard Id(s) to have the activity set on\n   */\n\n  /**\n   * Sets the full presence of the client user.\n   * @param {PresenceData} data Data for the presence\n   * @returns {Presence}\n   * @example\n   * // Set the client user's presence\n   * client.user.setPresence({ activities: [{ name: 'with discord.js' }], status: 'idle' });\n   */\n\n\n  setPresence(data) {\n    return this.client.presence.set(data);\n  }\n  /**\n   * A user's status. Must be one of:\n   * * `online`\n   * * `idle`\n   * * `invisible`\n   * * `dnd` (do not disturb)\n   * @typedef {string} PresenceStatusData\n   */\n\n  /**\n   * Sets the status of the client user.\n   * @param {PresenceStatusData} status Status to change to\n   * @param {?number|number[]} [shardID] Shard ID(s) to have the activity set on\n   * @returns {Presence}\n   * @example\n   * // Set the client user's status\n   * client.user.setStatus('idle');\n   */\n\n\n  setStatus(status, shardID) {\n    return this.setPresence({\n      status,\n      shardID\n    });\n  }\n  /**\n   * Options for setting an activity.\n   * @typedef {Object} ActivityOptions\n   * @property {string} [name] Name of the activity\n   * @property {string} [url] Twitch / YouTube stream URL\n   * @property {ActivityType|number} [type] Type of the activity\n   * @property {number|number[]} [shardID] Shard Id(s) to have the activity set on\n   */\n\n  /**\n   * Sets the activity the client user is playing.\n   * @param {string|ActivityOptions} [name] Activity being played, or options for setting the activity\n   * @param {ActivityOptions} [options] Options for setting the activity\n   * @returns {Presence}\n   * @example\n   * // Set the client user's activity\n   * client.user.setActivity('discord.js', { type: 'WATCHING' });\n   */\n\n\n  setActivity(name, options = {}) {\n    if (!name) return this.setPresence({\n      activities: [],\n      shardID: options.shardID\n    });\n    const activity = Object.assign({}, options, typeof name === 'object' ? name : {\n      name\n    });\n    return this.setPresence({\n      activities: [activity],\n      shardID: activity.shardID\n    });\n  }\n  /**\n   * Sets/removes the AFK flag for the client user.\n   * @param {boolean} afk Whether or not the user is AFK\n   * @param {number|number[]} [shardID] Shard Id(s) to have the AFK flag set on\n   * @returns {Presence}\n   */\n\n\n  setAFK(afk, shardID) {\n    return this.setPresence({\n      afk,\n      shardID\n    });\n  }\n\n}\n\nmodule.exports = ClientUser;\n/**\n * @external APIModifyClientData\n * @see {@link https://discord.com/developers/docs/resources/user#modify-current-user-json-params}\n */\n\n//# sourceURL=webpack://Fosscord/./src/structures/ClientUser.js?")},"./src/structures/CommandInteraction.js":function(module,exports){eval('throw new Error("Module parse failed: Unexpected token (88:22)\\nFile was processed with these loaders:\\n * ./node_modules/babel-loader/lib/index.js\\nYou may need an additional loader to handle the result of these loaders.\\n|   get command() {\\n|     const id = this.commandID;\\n>     return this.guild?.commands.cache.get(id) ?? this.client.application.commands.cache.get(id) ?? null;\\n|   }\\n|   /**");\n\n//# sourceURL=webpack://Fosscord/./src/structures/CommandInteraction.js?')},"./src/structures/DMChannel.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nconst Channel = __webpack_require__(/*! ./Channel */ \"./src/structures/Channel.js\");\n\nconst TextBasedChannel = __webpack_require__(/*! ./interfaces/TextBasedChannel */ \"./src/structures/interfaces/TextBasedChannel.js\");\n\nconst MessageManager = __webpack_require__(/*! ../managers/MessageManager */ \"./src/managers/MessageManager.js\");\n/**\n * Represents a direct message channel between two users.\n * @extends {Channel}\n * @implements {TextBasedChannel}\n */\n\n\nclass DMChannel extends Channel {\n  /**\n   * @param {Client} client The instantiating client\n   * @param {APIChannel} data The data for the DM channel\n   */\n  constructor(client, data) {\n    super(client, data); // Override the channel type so partials have a known type\n\n    this.type = 'dm';\n    /**\n     * A manager of the messages belonging to this channel\n     * @type {MessageManager}\n     */\n\n    this.messages = new MessageManager(this);\n    this._typing = new Map();\n  }\n\n  _patch(data) {\n    super._patch(data);\n\n    if (data.recipients) {\n      /**\n       * The recipient on the other end of the DM\n       * @type {User}\n       */\n      this.recipient = this.client.users.add(data.recipients[0]);\n    }\n    /**\n     * The ID of the last message in the channel, if one was sent\n     * @type {?Snowflake}\n     */\n\n\n    this.lastMessageID = data.last_message_id;\n    /**\n     * The timestamp when the last pinned message was pinned, if there was one\n     * @type {?number}\n     */\n\n    this.lastPinTimestamp = data.last_pin_timestamp ? new Date(data.last_pin_timestamp).getTime() : null;\n  }\n  /**\n   * Whether this DMChannel is a partial\n   * @type {boolean}\n   * @readonly\n   */\n\n\n  get partial() {\n    return typeof this.lastMessageID === 'undefined';\n  }\n  /**\n   * Fetch this DMChannel.\n   * @param {boolean} [force=false] Whether to skip the cache check and request the API\n   * @returns {Promise<DMChannel>}\n   */\n\n\n  fetch(force = false) {\n    return this.recipient.createDM(force);\n  }\n  /**\n   * When concatenated with a string, this automatically returns the recipient's mention instead of the\n   * DMChannel object.\n   * @returns {string}\n   * @example\n   * // Logs: Hello from <@123456789012345678>!\n   * console.log(`Hello from ${channel}!`);\n   */\n\n\n  toString() {\n    return this.recipient.toString();\n  } // These are here only for documentation purposes - they are implemented by TextBasedChannel\n\n  /* eslint-disable no-empty-function */\n\n\n  get lastMessage() {}\n\n  get lastPinAt() {}\n\n  send() {}\n\n  startTyping() {}\n\n  stopTyping() {}\n\n  get typing() {}\n\n  get typingCount() {}\n\n  createMessageCollector() {}\n\n  awaitMessages() {}\n\n  createMessageComponentInteractionCollector() {}\n\n  awaitMessageComponentInteraction() {} // Doesn't work on DM channels; bulkDelete() {}\n\n\n}\n\nTextBasedChannel.applyToClass(DMChannel, true, ['bulkDelete']);\nmodule.exports = DMChannel;\n\n//# sourceURL=webpack://Fosscord/./src/structures/DMChannel.js?")},"./src/structures/Emoji.js":function(module,exports){eval('throw new Error("Module parse failed: Unexpected token (28:36)\\nFile was processed with these loaders:\\n * ./node_modules/babel-loader/lib/index.js\\nYou may need an additional loader to handle the result of these loaders.\\n|      */\\n| \\n>     this.animated = emoji.animated ?? null;\\n|     /**\\n|      * The name of this emoji");\n\n//# sourceURL=webpack://Fosscord/./src/structures/Emoji.js?')},"./src/structures/Guild.js":function(module,exports){eval('throw new Error("Module parse failed: Unexpected token (989:45)\\nFile was processed with these loaders:\\n * ./node_modules/babel-loader/lib/index.js\\nYou may need an additional loader to handle the result of these loaders.\\n|       welcomeChannels\\n|     } = data;\\n>     const welcome_channels = welcomeChannels?.map(welcomeChannelData => {\\n|       const emoji = this.emojis.resolve(welcomeChannelData.emoji);\\n|       return {");\n\n//# sourceURL=webpack://Fosscord/./src/structures/Guild.js?')},"./src/structures/GuildAuditLogs.js":function(module,exports){eval('throw new Error("Module parse failed: Unexpected token (363:70)\\nFile was processed with these loaders:\\n * ./node_modules/babel-loader/lib/index.js\\nYou may need an additional loader to handle the result of these loaders.\\n|       case Actions.MESSAGE_BULK_DELETE:\\n|         this.extra = {\\n>           channel: guild.channels.cache.get(data.options.channel_id) ?? {\\n|             id: data.options.channel_id\\n|           },");\n\n//# sourceURL=webpack://Fosscord/./src/structures/GuildAuditLogs.js?')},"./src/structures/GuildBan.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nconst Base = __webpack_require__(/*! ./Base */ \"./src/structures/Base.js\");\n/**\n * Represents a ban in a guild on Discord.\n * @extends {Base}\n */\n\n\nclass GuildBan extends Base {\n  /**\n   * @param {Client} client The instantiating client\n   * @param {APIBanData} data The data for the ban\n   * @param {Guild} guild The guild in which the ban is\n   */\n  constructor(client, data, guild) {\n    super(client);\n    /**\n     * The guild in which the ban is\n     * @type {Guild}\n     */\n\n    this.guild = guild;\n\n    this._patch(data);\n  }\n\n  _patch(data) {\n    /**\n     * The user this ban applies to\n     * @type {User}\n     */\n    this.user = this.client.users.add(data.user, true);\n\n    if ('reason' in data) {\n      /**\n       * The reason for the ban\n       * @type {?string}\n       */\n      this.reason = data.reason;\n    }\n  }\n  /**\n   * Whether this GuildBan is a partial\n   * If the reason is not provided the value is null\n   * @type {boolean}\n   * @readonly\n   */\n\n\n  get partial() {\n    return !('reason' in this);\n  }\n  /**\n   * Fetches this GuildBan.\n   * @param {boolean} [force=false] Whether to skip the cache check and request the API\n   * @returns {Promise<GuildBan>}\n   */\n\n\n  fetch(force = false) {\n    return this.guild.bans.fetch({\n      user: this.user,\n      cache: true,\n      force\n    });\n  }\n\n}\n\nmodule.exports = GuildBan;\n/**\n * @external APIBanData\n * @see {@link https://discord.com/developers/docs/resources/guild#create-guild-ban-json-params}\n */\n\n//# sourceURL=webpack://Fosscord/./src/structures/GuildBan.js?")},"./src/structures/GuildChannel.js":function(module,exports){eval('throw new Error("Module parse failed: Unexpected token (55:35)\\nFile was processed with these loaders:\\n * ./node_modules/babel-loader/lib/index.js\\nYou may need an additional loader to handle the result of these loaders.\\n| \\n|     this.guild = guild;\\n>     this.parentID = this.parentID ?? null;\\n|     this.permissionOverwrites = this.permissionOverwrites ?? new Collection();\\n|   }");\n\n//# sourceURL=webpack://Fosscord/./src/structures/GuildChannel.js?')},"./src/structures/GuildEmoji.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nconst BaseGuildEmoji = __webpack_require__(/*! ./BaseGuildEmoji */ \"./src/structures/BaseGuildEmoji.js\");\n\nconst {\n  Error\n} = __webpack_require__(/*! ../errors */ \"./src/errors/index.js\");\n\nconst GuildEmojiRoleManager = __webpack_require__(/*! ../managers/GuildEmojiRoleManager */ \"./src/managers/GuildEmojiRoleManager.js\");\n\nconst Permissions = __webpack_require__(/*! ../util/Permissions */ \"./src/util/Permissions.js\");\n/**\n * Represents a custom emoji.\n * @extends {BaseGuildEmoji}\n */\n\n\nclass GuildEmoji extends BaseGuildEmoji {\n  /**\n   * @param {Client} client The instantiating client\n   * @param {APIEmoji} data The data for the guild emoji\n   * @param {Guild} guild The guild the guild emoji is part of\n   */\n  constructor(client, data, guild) {\n    super(client, data, guild);\n    /**\n     * The user who created this emoji\n     * @type {?User}\n     */\n\n    this.author = null;\n    /**\n     * Array of role ids this emoji is active for\n     * @name GuildEmoji#_roles\n     * @type {Snowflake[]}\n     * @private\n     */\n\n    Object.defineProperty(this, '_roles', {\n      value: [],\n      writable: true\n    });\n  }\n  /**\n   * The guild this emoji is part of\n   * @type {Guild}\n   * @name GuildEmoji#guild\n   */\n\n\n  _clone() {\n    const clone = super._clone();\n\n    clone._roles = this._roles.slice();\n    return clone;\n  }\n\n  _patch(data) {\n    super._patch(data);\n\n    if (data.user) this.author = this.client.users.add(data.user);\n    if (data.roles) this._roles = data.roles;\n  }\n  /**\n   * Whether the emoji is deletable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n\n\n  get deletable() {\n    if (!this.guild.me) throw new Error('GUILD_UNCACHED_ME');\n    return !this.managed && this.guild.me.permissions.has(Permissions.FLAGS.MANAGE_EMOJIS);\n  }\n  /**\n   * A manager for roles this emoji is active for.\n   * @type {GuildEmojiRoleManager}\n   * @readonly\n   */\n\n\n  get roles() {\n    return new GuildEmojiRoleManager(this);\n  }\n  /**\n   * Fetches the author for this emoji\n   * @returns {Promise<User>}\n   */\n\n\n  async fetchAuthor() {\n    if (this.managed) {\n      throw new Error('EMOJI_MANAGED');\n    } else {\n      if (!this.guild.me) throw new Error('GUILD_UNCACHED_ME');\n\n      if (!this.guild.me.permissions.has(Permissions.FLAGS.MANAGE_EMOJIS)) {\n        throw new Error('MISSING_MANAGE_EMOJIS_PERMISSION', this.guild);\n      }\n    }\n\n    const data = await this.client.api.guilds(this.guild.id).emojis(this.id).get();\n\n    this._patch(data);\n\n    return this.author;\n  }\n  /**\n   * Data for editing an emoji.\n   * @typedef {Object} GuildEmojiEditData\n   * @property {string} [name] The name of the emoji\n   * @property {Collection<Snowflake, Role>|RoleResolvable[]} [roles] Roles to restrict emoji to\n   */\n\n  /**\n   * Edits the emoji.\n   * @param {GuildEmojiEditData} data The new data for the emoji\n   * @param {string} [reason] Reason for editing this emoji\n   * @returns {Promise<GuildEmoji>}\n   * @example\n   * // Edit an emoji\n   * emoji.edit({ name: 'newemoji' })\n   *   .then(e => console.log(`Edited emoji ${e}`))\n   *   .catch(console.error);\n   */\n\n\n  edit(data, reason) {\n    const roles = data.roles ? data.roles.map(r => r.id || r) : undefined;\n    return this.client.api.guilds(this.guild.id).emojis(this.id).patch({\n      data: {\n        name: data.name,\n        roles\n      },\n      reason\n    }).then(newData => {\n      const clone = this._clone();\n\n      clone._patch(newData);\n\n      return clone;\n    });\n  }\n  /**\n   * Sets the name of the emoji.\n   * @param {string} name The new name for the emoji\n   * @param {string} [reason] Reason for changing the emoji's name\n   * @returns {Promise<GuildEmoji>}\n   */\n\n\n  setName(name, reason) {\n    return this.edit({\n      name\n    }, reason);\n  }\n  /**\n   * Deletes the emoji.\n   * @param {string} [reason] Reason for deleting the emoji\n   * @returns {Promise<GuildEmoji>}\n   */\n\n\n  delete(reason) {\n    return this.client.api.guilds(this.guild.id).emojis(this.id).delete({\n      reason\n    }).then(() => this);\n  }\n  /**\n   * Whether this emoji is the same as another one.\n   * @param {GuildEmoji|APIEmoji} other The emoji to compare it to\n   * @returns {boolean} Whether the emoji is equal to the given emoji or not\n   */\n\n\n  equals(other) {\n    if (other instanceof GuildEmoji) {\n      return other.id === this.id && other.name === this.name && other.managed === this.managed && other.available === this.available && other.requiresColons === this.requiresColons && other.roles.cache.size === this.roles.cache.size && other.roles.cache.every(role => this.roles.cache.has(role.id));\n    } else {\n      return other.id === this.id && other.name === this.name && other.roles.length === this.roles.cache.size && other.roles.every(role => this.roles.cache.has(role));\n    }\n  }\n\n}\n\nmodule.exports = GuildEmoji;\n\n//# sourceURL=webpack://Fosscord/./src/structures/GuildEmoji.js?")},"./src/structures/GuildMember.js":function(module,exports){eval("throw new Error(\"Module parse failed: Unexpected token (99:33)\\nFile was processed with these loaders:\\n * ./node_modules/babel-loader/lib/index.js\\nYou may need an additional loader to handle the result of these loaders.\\n| \\n|     if ('roles' in data) this._roles = data.roles;\\n>     this.pending = data.pending ?? false;\\n|   }\\n| \");\n\n//# sourceURL=webpack://Fosscord/./src/structures/GuildMember.js?")},"./src/structures/GuildPreview.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nconst Base = __webpack_require__(/*! ./Base */ "./src/structures/Base.js");\n\nconst GuildPreviewEmoji = __webpack_require__(/*! ./GuildPreviewEmoji */ "./src/structures/GuildPreviewEmoji.js");\n\nconst Collection = __webpack_require__(/*! ../util/Collection */ "./src/util/Collection.js");\n/**\n * Represents the data about the guild any bot can preview, connected to the specified guild.\n * @extends {Base}\n */\n\n\nclass GuildPreview extends Base {\n  constructor(client, data) {\n    super(client);\n    if (!data) return;\n\n    this._patch(data);\n  }\n  /**\n   * Builds the guild with the provided data.\n   * @param {*} data The raw data of the guild\n   * @private\n   */\n\n\n  _patch(data) {\n    /**\n     * The id of this guild\n     * @type {string}\n     */\n    this.id = data.id;\n    /**\n     * The name of this guild\n     * @type {string}\n     */\n\n    this.name = data.name;\n    /**\n     * The icon of this guild\n     * @type {?string}\n     */\n\n    this.icon = data.icon;\n    /**\n     * The splash icon of this guild\n     * @type {?string}\n     */\n\n    this.splash = data.splash;\n    /**\n     * The discovery splash icon of this guild\n     * @type {?string}\n     */\n\n    this.discoverySplash = data.discovery_splash;\n    /**\n     * An array of enabled guild features\n     * @type {Features[]}\n     */\n\n    this.features = data.features;\n    /**\n     * The approximate count of members in this guild\n     * @type {number}\n     */\n\n    this.approximateMemberCount = data.approximate_member_count;\n    /**\n     * The approximate count of online members in this guild\n     * @type {number}\n     */\n\n    this.approximatePresenceCount = data.approximate_presence_count;\n    /**\n     * The description for this guild\n     * @type {?string}\n     */\n\n    this.description = data.description || null;\n\n    if (!this.emojis) {\n      /**\n       * Collection of emojis belonging to this guild\n       * @type {Collection<Snowflake, GuildPreviewEmoji>}\n       */\n      this.emojis = new Collection();\n    } else {\n      this.emojis.clear();\n    }\n\n    for (const emoji of data.emojis) {\n      this.emojis.set(emoji.id, new GuildPreviewEmoji(this.client, emoji, this));\n    }\n  }\n  /**\n   * The URL to this guild\'s splash.\n   * @param {StaticImageURLOptions} [options={}] Options for the Image URL\n   * @returns {?string}\n   */\n\n\n  splashURL({\n    format,\n    size\n  } = {}) {\n    if (!this.splash) return null;\n    return this.client.rest.cdn.Splash(this.id, this.splash, format, size);\n  }\n  /**\n   * The URL to this guild\'s discovery splash.\n   * @param {StaticImageURLOptions} [options={}] Options for the Image URL\n   * @returns {?string}\n   */\n\n\n  discoverySplashURL({\n    format,\n    size\n  } = {}) {\n    if (!this.discoverySplash) return null;\n    return this.client.rest.cdn.DiscoverySplash(this.id, this.discoverySplash, format, size);\n  }\n  /**\n   * The URL to this guild\'s icon.\n   * @param {ImageURLOptions} [options={}] Options for the Image URL\n   * @returns {?string}\n   */\n\n\n  iconURL({\n    format,\n    size,\n    dynamic\n  } = {}) {\n    if (!this.icon) return null;\n    return this.client.rest.cdn.Icon(this.id, this.icon, format, size, dynamic);\n  }\n  /**\n   * Fetches this guild.\n   * @returns {Promise<GuildPreview>}\n   */\n\n\n  fetch() {\n    return this.client.api.guilds(this.id).preview.get().then(data => {\n      this._patch(data);\n\n      return this;\n    });\n  }\n  /**\n   * When concatenated with a string, this automatically returns the guild\'s name instead of the Guild object.\n   * @returns {string}\n   * @example\n   * // Logs: Hello from My Guild!\n   * console.log(`Hello from ${previewGuild}!`);\n   */\n\n\n  toString() {\n    return this.name;\n  }\n\n  toJSON() {\n    const json = super.toJSON();\n    json.iconURL = this.iconURL();\n    json.splashURL = this.splashURL();\n    return json;\n  }\n\n}\n\nmodule.exports = GuildPreview;\n\n//# sourceURL=webpack://Fosscord/./src/structures/GuildPreview.js?')},"./src/structures/GuildPreviewEmoji.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nconst BaseGuildEmoji = __webpack_require__(/*! ./BaseGuildEmoji */ "./src/structures/BaseGuildEmoji.js");\n/**\n * Represents an instance of an emoji belonging to a public guild obtained through Discord\'s preview endpoint.\n * @extends {BaseGuildEmoji}\n */\n\n\nclass GuildPreviewEmoji extends BaseGuildEmoji {\n  /**\n   * The public guild this emoji is part of\n   * @type {GuildPreview}\n   * @name GuildPreviewEmoji#guild\n   */\n  constructor(client, data, guild) {\n    super(client, data, guild);\n    /**\n     * The roles this emoji is active for\n     * @type {Snowflake[]}\n     */\n\n    this.roles = data.roles;\n  }\n\n}\n\nmodule.exports = GuildPreviewEmoji;\n\n//# sourceURL=webpack://Fosscord/./src/structures/GuildPreviewEmoji.js?')},"./src/structures/GuildTemplate.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nconst Base = __webpack_require__(/*! ./Base */ "./src/structures/Base.js");\n\nconst {\n  Events\n} = __webpack_require__(/*! ../util/Constants */ "./src/util/Constants.js");\n\nconst DataResolver = __webpack_require__(/*! ../util/DataResolver */ "./src/util/DataResolver.js");\n/**\n * Represents the template for a guild.\n * @extends {Base}\n */\n\n\nclass GuildTemplate extends Base {\n  /**\n   * @param {Client} client The instantiating client\n   * @param {APIGuildTemplate} data The raw data for the template\n   */\n  constructor(client, data) {\n    super(client);\n\n    this._patch(data);\n  }\n  /**\n   * Builds or updates the template with the provided data.\n   * @param {APIGuildTemplate} data The raw data for the template\n   * @returns {GuildTemplate}\n   * @private\n   */\n\n\n  _patch(data) {\n    /**\n     * The unique code of this template\n     * @type {string}\n     */\n    this.code = data.code;\n    /**\n     * The name of this template\n     * @type {string}\n     */\n\n    this.name = data.name;\n    /**\n     * The description of this template\n     * @type {?string}\n     */\n\n    this.description = data.description;\n    /**\n     * The amount of times this template has been used\n     * @type {number}\n     */\n\n    this.usageCount = data.usage_count;\n    /**\n     * The ID of the user that created this template\n     * @type {Snowflake}\n     */\n\n    this.creatorID = data.creator_id;\n    /**\n     * The user that created this template\n     * @type {User}\n     */\n\n    this.creator = this.client.users.add(data.creator);\n    /**\n     * The time of when this template was created at\n     * @type {Date}\n     */\n\n    this.createdAt = new Date(data.created_at);\n    /**\n     * The time of when this template was last synced to the guild\n     * @type {Date}\n     */\n\n    this.updatedAt = new Date(data.updated_at);\n    /**\n     * The ID of the guild that this template belongs to\n     * @type {Snowflake}\n     */\n\n    this.guildID = data.source_guild_id;\n    /**\n     * The data of the guild that this template would create\n     * @type {APIGuild}\n     */\n\n    this.serializedGuild = data.serialized_source_guild;\n    /**\n     * Whether this template has unsynced changes\n     * @type {?boolean}\n     */\n\n    this.unSynced = \'is_dirty\' in data ? Boolean(data.is_dirty) : null;\n    return this;\n  }\n  /**\n   * Creates a guild based from this template.\n   * <warn>This is only available to bots in fewer than 10 guilds.</warn>\n   * @param {string} name The name of the guild\n   * @param {BufferResolvable|Base64Resolvable} [icon] The icon for the guild\n   * @returns {Promise<Guild>}\n   */\n\n\n  async createGuild(name, icon) {\n    const {\n      client\n    } = this;\n    const data = await client.api.guilds.templates(this.code).post({\n      data: {\n        name,\n        icon: await DataResolver.resolveImage(icon)\n      }\n    }); // eslint-disable-next-line consistent-return\n\n    return new Promise(resolve => {\n      const createdGuild = client.guilds.cache.get(data.id);\n      if (createdGuild) return resolve(createdGuild);\n\n      const resolveGuild = guild => {\n        client.off(Events.GUILD_CREATE, handleGuild);\n        client.decrementMaxListeners();\n        resolve(guild);\n      };\n\n      const handleGuild = guild => {\n        if (guild.id === data.id) {\n          client.clearTimeout(timeout);\n          resolveGuild(guild);\n        }\n      };\n\n      client.incrementMaxListeners();\n      client.on(Events.GUILD_CREATE, handleGuild);\n      const timeout = client.setTimeout(() => resolveGuild(client.guilds.add(data)), 10000);\n    });\n  }\n  /**\n   * Options used to edit a guild template.\n   * @typedef {Object} EditGuildTemplateOptions\n   * @property {string} [name] The name of this template\n   * @property {string} [description] The description of this template\n   */\n\n  /**\n   * Updates the metadata of this template.\n   * @param {EditGuildTemplateOptions} [options] Options for editing the template\n   * @returns {Promise<GuildTemplate>}\n   */\n\n\n  edit({\n    name,\n    description\n  } = {}) {\n    return this.client.api.guilds(this.guildID).templates(this.code).patch({\n      data: {\n        name,\n        description\n      }\n    }).then(data => this._patch(data));\n  }\n  /**\n   * Deletes this template.\n   * @returns {Promise<GuildTemplate>}\n   */\n\n\n  delete() {\n    return this.client.api.guilds(this.guildID).templates(this.code).delete().then(() => this);\n  }\n  /**\n   * Syncs this template to the current state of the guild.\n   * @returns {Promise<GuildTemplate>}\n   */\n\n\n  sync() {\n    return this.client.api.guilds(this.guildID).templates(this.code).put().then(data => this._patch(data));\n  }\n  /**\n   * The timestamp of when this template was created at\n   * @type {number}\n   * @readonly\n   */\n\n\n  get createdTimestamp() {\n    return this.createdAt.getTime();\n  }\n  /**\n   * The timestamp of when this template was last synced to the guild\n   * @type {number}\n   * @readonly\n   */\n\n\n  get updatedTimestamp() {\n    return this.updatedAt.getTime();\n  }\n  /**\n   * The guild that this template belongs to\n   * @type {?Guild}\n   * @readonly\n   */\n\n\n  get guild() {\n    return this.client.guilds.cache.get(this.guildID) || null;\n  }\n  /**\n   * The URL of this template\n   * @type {string}\n   * @readonly\n   */\n\n\n  get url() {\n    return `${this.client.options.http.template}/${this.code}`;\n  }\n  /**\n   * When concatenated with a string, this automatically returns the templates\'s code instead of the template object.\n   * @returns {string}\n   * @example\n   * // Logs: Template: FKvmczH2HyUf\n   * console.log(`Template: ${guildTemplate}!`);\n   */\n\n\n  toString() {\n    return this.code;\n  }\n\n}\n/**\n * Regular expression that globally matches guild template links\n * @type {RegExp}\n */\n\n\nGuildTemplate.GUILD_TEMPLATES_PATTERN = /discord(?:app)?\\.(?:com\\/template|new)\\/([\\w-]{2,255})/gi;\nmodule.exports = GuildTemplate;\n/* eslint-disable max-len */\n\n/**\n * @external APIGuildTemplate\n * @see {@link https://discord.com/developers/docs/resources/guild-template#guild-template-object-guild-template-structure}\n */\n\n//# sourceURL=webpack://Fosscord/./src/structures/GuildTemplate.js?')},"./src/structures/Integration.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nconst Base = __webpack_require__(/*! ./Base */ \"./src/structures/Base.js\");\n\nconst IntegrationApplication = __webpack_require__(/*! ./IntegrationApplication */ \"./src/structures/IntegrationApplication.js\");\n/**\n * The information account for an integration\n * @typedef {Object} IntegrationAccount\n * @property {string} id The id of the account\n * @property {string} name The name of the account\n */\n\n/**\n *  Represents a guild integration.\n */\n\n\nclass Integration extends Base {\n  constructor(client, data, guild) {\n    super(client);\n    /**\n     * The guild this integration belongs to\n     * @type {Guild}\n     */\n\n    this.guild = guild;\n    /**\n     * The integration id\n     * @type {Snowflake}\n     */\n\n    this.id = data.id;\n    /**\n     * The integration name\n     * @type {string}\n     */\n\n    this.name = data.name;\n    /**\n     * The integration type (twitch, youtube, etc)\n     * @type {string}\n     */\n\n    this.type = data.type;\n    /**\n     * Whether this integration is enabled\n     * @type {boolean}\n     */\n\n    this.enabled = data.enabled;\n    /**\n     * Whether this integration is syncing\n     * @type {boolean}\n     */\n\n    this.syncing = data.syncing;\n    /**\n     * The role that this integration uses for subscribers\n     * @type {Role}\n     */\n\n    this.role = this.guild.roles.cache.get(data.role_id);\n\n    if (data.user) {\n      /**\n       * The user for this integration\n       * @type {?User}\n       */\n      this.user = this.client.users.add(data.user);\n    } else {\n      this.user = null;\n    }\n    /**\n     * The account integration information\n     * @type {IntegrationAccount}\n     */\n\n\n    this.account = data.account;\n    /**\n     * The last time this integration was last synced\n     * @type {number}\n     */\n\n    this.syncedAt = data.synced_at;\n\n    this._patch(data);\n  }\n  /**\n   * All roles that are managed by this integration\n   * @type {Collection<Snowflake, Role>}\n   * @readonly\n   */\n\n\n  get roles() {\n    const roles = this.guild.roles.cache;\n    return roles.filter(role => role.tags && role.tags.integrationID === this.id);\n  }\n\n  _patch(data) {\n    /**\n     * The behavior of expiring subscribers\n     * @type {number}\n     */\n    this.expireBehavior = data.expire_behavior;\n    /**\n     * The grace period before expiring subscribers\n     * @type {number}\n     */\n\n    this.expireGracePeriod = data.expire_grace_period;\n\n    if ('application' in data) {\n      if (this.application) {\n        this.application._patch(data.application);\n      } else {\n        /**\n         * The application for this integration\n         * @type {?IntegrationApplication}\n         */\n        this.application = new IntegrationApplication(this.client, data.application);\n      }\n    } else if (!this.application) {\n      this.application = null;\n    }\n  }\n  /**\n   * Sync this integration\n   * @returns {Promise<Integration>}\n   */\n\n\n  sync() {\n    this.syncing = true;\n    return this.client.api.guilds(this.guild.id).integrations(this.id).post().then(() => {\n      this.syncing = false;\n      this.syncedAt = Date.now();\n      return this;\n    });\n  }\n  /**\n   * The data for editing an integration.\n   * @typedef {Object} IntegrationEditData\n   * @property {number} [expireBehavior] The new behaviour of expiring subscribers\n   * @property {number} [expireGracePeriod] The new grace period before expiring subscribers\n   */\n\n  /**\n   * Edits this integration.\n   * @param {IntegrationEditData} data The data to edit this integration with\n   * @param {string} reason Reason for editing this integration\n   * @returns {Promise<Integration>}\n   */\n\n\n  edit(data, reason) {\n    if ('expireBehavior' in data) {\n      data.expire_behavior = data.expireBehavior;\n      data.expireBehavior = null;\n    }\n\n    if ('expireGracePeriod' in data) {\n      data.expire_grace_period = data.expireGracePeriod;\n      data.expireGracePeriod = null;\n    } // The option enable_emoticons is only available for Twitch at this moment\n\n\n    return this.client.api.guilds(this.guild.id).integrations(this.id).patch({\n      data,\n      reason\n    }).then(() => {\n      this._patch(data);\n\n      return this;\n    });\n  }\n  /**\n   * Deletes this integration.\n   * @returns {Promise<Integration>}\n   * @param {string} [reason] Reason for deleting this integration\n   */\n\n\n  delete(reason) {\n    return this.client.api.guilds(this.guild.id).integrations(this.id).delete({\n      reason\n    }).then(() => this);\n  }\n\n  toJSON() {\n    return super.toJSON({\n      role: 'roleID',\n      guild: 'guildID',\n      user: 'userID'\n    });\n  }\n\n}\n\nmodule.exports = Integration;\n\n//# sourceURL=webpack://Fosscord/./src/structures/Integration.js?")},"./src/structures/IntegrationApplication.js":function(module,exports){eval('throw new Error("Module parse failed: Unexpected token (19:70)\\nFile was processed with these loaders:\\n * ./node_modules/babel-loader/lib/index.js\\nYou may need an additional loader to handle the result of these loaders.\\n| \\n| \\n>     this.bot = data.bot ? this.client.users.add(data.bot) : this.bot ?? null;\\n|     /**\\n|      * The url of the application\'s terms of service");\n\n//# sourceURL=webpack://Fosscord/./src/structures/IntegrationApplication.js?')},"./src/structures/Interaction.js":function(module,exports){eval('throw new Error("Module parse failed: Unexpected token (53:38)\\nFile was processed with these loaders:\\n * ./node_modules/babel-loader/lib/index.js\\nYou may need an additional loader to handle the result of these loaders.\\n|      */\\n| \\n>     this.channelID = data.channel_id ?? null;\\n|     /**\\n|      * The ID of the guild this interaction was sent in");\n\n//# sourceURL=webpack://Fosscord/./src/structures/Interaction.js?')},"./src/structures/InteractionWebhook.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nconst Webhook = __webpack_require__(/*! ./Webhook */ \"./src/structures/Webhook.js\");\n/**\n * Represents a webhook for an Interaction\n * @implements {Webhook}\n */\n\n\nclass InteractionWebhook {\n  /**\n   * @param {Client} client The instantiating client\n   * @param {Snowflake} id ID of the application\n   * @param {string} token Token of the interaction\n   */\n  constructor(client, id, token) {\n    /**\n     * The client that instantiated the interaction webhook\n     * @name InteractionWebhook#client\n     * @type {Client}\n     * @readonly\n     */\n    Object.defineProperty(this, 'client', {\n      value: client\n    });\n    this.id = id;\n    Object.defineProperty(this, 'token', {\n      value: token,\n      writable: true,\n      configurable: true\n    });\n  } // These are here only for documentation purposes - they are implemented by Webhook\n\n  /* eslint-disable no-empty-function, valid-jsdoc */\n\n  /**\n   * Sends a message with this webhook.\n   * @param {string|APIMessage|InteractionReplyOptions} options The content for the reply\n   * @returns {Promise<Message|APIMessageRaw>}\n   */\n\n\n  send() {}\n\n  fetchMessage() {}\n\n  editMessage() {}\n\n  deleteMessage() {}\n\n  get url() {}\n\n}\n\nWebhook.applyToClass(InteractionWebhook, ['sendSlackMessage', 'edit', 'delete', 'createdTimestamp', 'createdAt']);\nmodule.exports = InteractionWebhook;\n\n//# sourceURL=webpack://Fosscord/./src/structures/InteractionWebhook.js?")},"./src/structures/Invite.js":function(module,exports){eval('throw new Error("Module parse failed: Unexpected token (172:35)\\nFile was processed with these loaders:\\n * ./node_modules/babel-loader/lib/index.js\\nYou may need an additional loader to handle the result of these loaders.\\n| \\n|   get expiresTimestamp() {\\n>     return this._expiresTimestamp ?? (this.createdTimestamp && this.maxAge ? this.createdTimestamp + this.maxAge * 1000 : null);\\n|   }\\n|   /**");\n\n//# sourceURL=webpack://Fosscord/./src/structures/Invite.js?')},"./src/structures/Message.js":function(module,exports){eval('throw new Error("Module parse failed: Unexpected token (166:40)\\nFile was processed with these loaders:\\n * ./node_modules/babel-loader/lib/index.js\\nYou may need an additional loader to handle the result of these loaders.\\n|      */\\n| \\n>     this.components = (data.components ?? []).map(c => BaseMessageComponent.create(c, this.client));\\n|     /**\\n|      * A collection of attachments in the message - e.g. Pictures - mapped by their ID");\n\n//# sourceURL=webpack://Fosscord/./src/structures/Message.js?')},"./src/structures/MessageActionRow.js":function(module,exports){eval('throw new Error("Module parse failed: Unexpected token (54:40)\\nFile was processed with these loaders:\\n * ./node_modules/babel-loader/lib/index.js\\nYou may need an additional loader to handle the result of these loaders.\\n|      */\\n| \\n>     this.components = (data.components ?? []).map(c => BaseMessageComponent.create(c, null, true));\\n|   }\\n|   /**");\n\n//# sourceURL=webpack://Fosscord/./src/structures/MessageActionRow.js?')},"./src/structures/MessageAttachment.js":function(module,exports){eval('throw new Error("Module parse failed: Unexpected token (91:42)\\nFile was processed with these loaders:\\n * ./node_modules/babel-loader/lib/index.js\\nYou may need an additional loader to handle the result of these loaders.\\n|      */\\n| \\n>     this.contentType = data.content_type ?? null;\\n|   }\\n|   /**");\n\n//# sourceURL=webpack://Fosscord/./src/structures/MessageAttachment.js?')},"./src/structures/MessageButton.js":function(module,exports){eval('throw new Error("Module parse failed: Unexpected token (47:29)\\nFile was processed with these loaders:\\n * ./node_modules/babel-loader/lib/index.js\\nYou may need an additional loader to handle the result of these loaders.\\n|      * @type {?string}\\n|      */\\n>     this.label = data.label ?? null;\\n|     /**\\n|      * A unique string to be sent in the interaction when clicked");\n\n//# sourceURL=webpack://Fosscord/./src/structures/MessageButton.js?')},"./src/structures/MessageCollector.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nconst Collector = __webpack_require__(/*! ./interfaces/Collector */ \"./src/structures/interfaces/Collector.js\");\n\nconst {\n  Events\n} = __webpack_require__(/*! ../util/Constants */ \"./src/util/Constants.js\");\n/**\n * @typedef {CollectorOptions} MessageCollectorOptions\n * @property {number} max The maximum amount of messages to collect\n * @property {number} maxProcessed The maximum amount of messages to process\n */\n\n/**\n * Collects messages on a channel.\n * Will automatically stop if the channel (`'channelDelete'`) or guild (`'guildDelete'`) are deleted.\n * @extends {Collector}\n */\n\n\nclass MessageCollector extends Collector {\n  /**\n   * @param {TextChannel|DMChannel} channel The channel\n   * @param {MessageCollectorOptions} options The options to be applied to this collector\n   * @emits MessageCollector#message\n   */\n  constructor(channel, options = {}) {\n    super(channel.client, options);\n    /**\n     * The channel\n     * @type {TextBasedChannel}\n     */\n\n    this.channel = channel;\n    /**\n     * Total number of messages that were received in the channel during message collection\n     * @type {number}\n     */\n\n    this.received = 0;\n\n    const bulkDeleteListener = messages => {\n      for (const message of messages.values()) this.handleDispose(message);\n    };\n\n    this._handleChannelDeletion = this._handleChannelDeletion.bind(this);\n    this._handleGuildDeletion = this._handleGuildDeletion.bind(this);\n    this.client.incrementMaxListeners();\n    this.client.on(Events.MESSAGE_CREATE, this.handleCollect);\n    this.client.on(Events.MESSAGE_DELETE, this.handleDispose);\n    this.client.on(Events.MESSAGE_BULK_DELETE, bulkDeleteListener);\n    this.client.on(Events.CHANNEL_DELETE, this._handleChannelDeletion);\n    this.client.on(Events.GUILD_DELETE, this._handleGuildDeletion);\n    this.once('end', () => {\n      this.client.removeListener(Events.MESSAGE_CREATE, this.handleCollect);\n      this.client.removeListener(Events.MESSAGE_DELETE, this.handleDispose);\n      this.client.removeListener(Events.MESSAGE_BULK_DELETE, bulkDeleteListener);\n      this.client.removeListener(Events.CHANNEL_DELETE, this._handleChannelDeletion);\n      this.client.removeListener(Events.GUILD_DELETE, this._handleGuildDeletion);\n      this.client.decrementMaxListeners();\n    });\n  }\n  /**\n   * Handles a message for possible collection.\n   * @param {Message} message The message that could be collected\n   * @returns {?Snowflake}\n   * @private\n   */\n\n\n  collect(message) {\n    /**\n     * Emitted whenever a message is collected.\n     * @event MessageCollector#collect\n     * @param {Message} message The message that was collected\n     */\n    if (message.channel.id !== this.channel.id) return null;\n    this.received++;\n    return message.id;\n  }\n  /**\n   * Handles a message for possible disposal.\n   * @param {Message} message The message that could be disposed of\n   * @returns {?Snowflake}\n   */\n\n\n  dispose(message) {\n    /**\n     * Emitted whenever a message is disposed of.\n     * @event MessageCollector#dispose\n     * @param {Message} message The message that was disposed of\n     */\n    return message.channel.id === this.channel.id ? message.id : null;\n  }\n\n  get endReason() {\n    if (this.options.max && this.collected.size >= this.options.max) return 'limit';\n    if (this.options.maxProcessed && this.received === this.options.maxProcessed) return 'processedLimit';\n    return null;\n  }\n  /**\n   * Handles checking if the channel has been deleted, and if so, stops the collector with the reason 'channelDelete'.\n   * @private\n   * @param {GuildChannel} channel The channel that was deleted\n   * @returns {void}\n   */\n\n\n  _handleChannelDeletion(channel) {\n    if (channel.id === this.channel.id) {\n      this.stop('channelDelete');\n    }\n  }\n  /**\n   * Handles checking if the guild has been deleted, and if so, stops the collector with the reason 'guildDelete'.\n   * @private\n   * @param {Guild} guild The guild that was deleted\n   * @returns {void}\n   */\n\n\n  _handleGuildDeletion(guild) {\n    if (this.channel.guild && guild.id === this.channel.guild.id) {\n      this.stop('guildDelete');\n    }\n  }\n\n}\n\nmodule.exports = MessageCollector;\n\n//# sourceURL=webpack://Fosscord/./src/structures/MessageCollector.js?")},"./src/structures/MessageComponentInteraction.js":function(module,exports){eval('throw new Error("Module parse failed: Unexpected token (27:47)\\nFile was processed with these loaders:\\n * ./node_modules/babel-loader/lib/index.js\\nYou may need an additional loader to handle the result of these loaders.\\n|      */\\n| \\n>     this.message = data.message ? this.channel?.messages.add(data.message) ?? data.message : null;\\n|     /**\\n|      * The custom ID of the component which was interacted with");\n\n//# sourceURL=webpack://Fosscord/./src/structures/MessageComponentInteraction.js?')},"./src/structures/MessageComponentInteractionCollector.js":function(module,exports){eval("throw new Error(\"Module parse failed: Unexpected token (148:36)\\nFile was processed with these loaders:\\n * ./node_modules/babel-loader/lib/index.js\\nYou may need an additional loader to handle the result of these loaders.\\n| \\n|   _handleMessageDeletion(message) {\\n>     if (message.id === this.message?.id) {\\n|       this.stop('messageDelete');\\n|     }\");\n\n//# sourceURL=webpack://Fosscord/./src/structures/MessageComponentInteractionCollector.js?")},"./src/structures/MessageEmbed.js":function(module,exports){eval('throw new Error("Module parse failed: Unexpected token (246:23)\\nFile was processed with these loaders:\\n * ./node_modules/babel-loader/lib/index.js\\nYou may need an additional loader to handle the result of these loaders.\\n| \\n|   get length() {\\n>     return (this.title?.length ?? 0) + (this.description?.length ?? 0) + (this.fields.length >= 1 ? this.fields.reduce((prev, curr) => prev + curr.name.length + curr.value.length, 0) : 0) + (this.footer?.text.length ?? 0) + (this.author?.name.length ?? 0);\\n|   }\\n|   /**");\n\n//# sourceURL=webpack://Fosscord/./src/structures/MessageEmbed.js?')},"./src/structures/MessageMentions.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nconst Collection = __webpack_require__(/*! ../util/Collection */ \"./src/util/Collection.js\");\n\nconst {\n  ChannelTypes\n} = __webpack_require__(/*! ../util/Constants */ \"./src/util/Constants.js\");\n\nconst Util = __webpack_require__(/*! ../util/Util */ \"./src/util/Util.js\");\n/**\n * Keeps track of mentions in a {@link Message}.\n */\n\n\nclass MessageMentions {\n  constructor(message, users, roles, everyone, crosspostedChannels, repliedUser) {\n    /**\n     * The client the message is from\n     * @type {Client}\n     * @readonly\n     */\n    Object.defineProperty(this, 'client', {\n      value: message.client\n    });\n    /**\n     * The guild the message is in\n     * @type {?Guild}\n     * @readonly\n     */\n\n    Object.defineProperty(this, 'guild', {\n      value: message.guild\n    });\n    /**\n     * The initial message content\n     * @type {string}\n     * @readonly\n     * @private\n     */\n\n    Object.defineProperty(this, '_content', {\n      value: message.content\n    });\n    /**\n     * Whether `@everyone` or `@here` were mentioned\n     * @type {boolean}\n     */\n\n    this.everyone = Boolean(everyone);\n\n    if (users) {\n      if (users instanceof Collection) {\n        /**\n         * Any users that were mentioned\n         * <info>Order as received from the API, not as they appear in the message content</info>\n         * @type {Collection<Snowflake, User>}\n         */\n        this.users = new Collection(users);\n      } else {\n        this.users = new Collection();\n\n        for (const mention of users) {\n          if (mention.member && message.guild) {\n            message.guild.members.add(Object.assign(mention.member, {\n              user: mention\n            }));\n          }\n\n          const user = message.client.users.add(mention);\n          this.users.set(user.id, user);\n        }\n      }\n    } else {\n      this.users = new Collection();\n    }\n\n    if (roles) {\n      if (roles instanceof Collection) {\n        /**\n         * Any roles that were mentioned\n         * <info>Order as received from the API, not as they appear in the message content</info>\n         * @type {Collection<Snowflake, Role>}\n         */\n        this.roles = new Collection(roles);\n      } else {\n        this.roles = new Collection();\n\n        for (const mention of roles) {\n          const role = message.channel.guild.roles.cache.get(mention);\n          if (role) this.roles.set(role.id, role);\n        }\n      }\n    } else {\n      this.roles = new Collection();\n    }\n    /**\n     * Cached members for {@link MessageMentions#members}\n     * @type {?Collection<Snowflake, GuildMember>}\n     * @private\n     */\n\n\n    this._members = null;\n    /**\n     * Cached channels for {@link MessageMentions#channels}\n     * @type {?Collection<Snowflake, Channel>}\n     * @private\n     */\n\n    this._channels = null;\n    /**\n     * Crossposted channel data.\n     * @typedef {Object} CrosspostedChannel\n     * @property {string} channelID ID of the mentioned channel\n     * @property {string} guildID ID of the guild that has the channel\n     * @property {string} type Type of the channel\n     * @property {string} name The name of the channel\n     */\n\n    if (crosspostedChannels) {\n      if (crosspostedChannels instanceof Collection) {\n        /**\n         * A collection of crossposted channels\n         * <info>Order as received from the API, not as they appear in the message content</info>\n         * @type {Collection<Snowflake, CrosspostedChannel>}\n         */\n        this.crosspostedChannels = new Collection(crosspostedChannels);\n      } else {\n        this.crosspostedChannels = new Collection();\n        const channelTypes = Object.keys(ChannelTypes);\n\n        for (const d of crosspostedChannels) {\n          const type = channelTypes[d.type];\n          this.crosspostedChannels.set(d.id, {\n            channelID: d.id,\n            guildID: d.guild_id,\n            type: type ? type.toLowerCase() : 'unknown',\n            name: d.name\n          });\n        }\n      }\n    } else {\n      this.crosspostedChannels = new Collection();\n    }\n    /**\n     * The author of the message that this message is a reply to\n     * @type {?User}\n     */\n\n\n    this.repliedUser = repliedUser ? this.client.users.add(repliedUser) : null;\n  }\n  /**\n   * Any members that were mentioned (only in {@link TextChannel}s)\n   * <info>Order as received from the API, not as they appear in the message content</info>\n   * @type {?Collection<Snowflake, GuildMember>}\n   * @readonly\n   */\n\n\n  get members() {\n    if (this._members) return this._members;\n    if (!this.guild) return null;\n    this._members = new Collection();\n    this.users.forEach(user => {\n      const member = this.guild.members.resolve(user);\n      if (member) this._members.set(member.user.id, member);\n    });\n    return this._members;\n  }\n  /**\n   * Any channels that were mentioned\n   * <info>Order as they appear first in the message content</info>\n   * @type {Collection<Snowflake, Channel>}\n   * @readonly\n   */\n\n\n  get channels() {\n    if (this._channels) return this._channels;\n    this._channels = new Collection();\n    let matches;\n\n    while ((matches = this.constructor.CHANNELS_PATTERN.exec(this._content)) !== null) {\n      const chan = this.client.channels.cache.get(matches[1]);\n      if (chan) this._channels.set(chan.id, chan);\n    }\n\n    return this._channels;\n  }\n  /**\n   * Options used to check for a mention.\n   * @typedef {Object} MessageMentionsHasOptions\n   * @property {boolean} [ignoreDirect=false] Whether to ignore direct mentions to the item\n   * @property {boolean} [ignoreRoles=false] Whether to ignore role mentions to a guild member\n   * @property {boolean} [ignoreEveryone=false] Whether to ignore everyone/here mentions\n   */\n\n  /**\n   * Checks if a user, guild member, role, or channel is mentioned.\n   * Takes into account user mentions, role mentions, and `@everyone`/`@here` mentions.\n   * @param {UserResolvable|RoleResolvable|ChannelResolvable} data The User/Role/Channel to check for\n   * @param {MessageMentionsHasOptions} [options] The options for the check\n   * @returns {boolean}\n   */\n\n\n  has(data, {\n    ignoreDirect = false,\n    ignoreRoles = false,\n    ignoreEveryone = false\n  } = {}) {\n    if (!ignoreEveryone && this.everyone) return true;\n\n    const GuildMember = __webpack_require__(/*! ./GuildMember */ \"./src/structures/GuildMember.js\");\n\n    if (!ignoreRoles && data instanceof GuildMember) {\n      for (const role of this.roles.values()) if (data.roles.cache.has(role.id)) return true;\n    }\n\n    if (!ignoreDirect) {\n      const id = this.client.users.resolveID(data) || this.guild && this.guild.roles.resolveID(data) || this.client.channels.resolveID(data);\n      return this.users.has(id) || this.channels.has(id) || this.roles.has(id);\n    }\n\n    return false;\n  }\n\n  toJSON() {\n    return Util.flatten(this, {\n      members: true,\n      channels: true\n    });\n  }\n\n}\n/**\n * Regular expression that globally matches `@everyone` and `@here`\n * @type {RegExp}\n */\n\n\nMessageMentions.EVERYONE_PATTERN = /@(everyone|here)/g;\n/**\n * Regular expression that globally matches user mentions like `<@81440962496172032>`\n * @type {RegExp}\n */\n\nMessageMentions.USERS_PATTERN = /<@!?(\\d{17,19})>/g;\n/**\n * Regular expression that globally matches role mentions like `<@&297577916114403338>`\n * @type {RegExp}\n */\n\nMessageMentions.ROLES_PATTERN = /<@&(\\d{17,19})>/g;\n/**\n * Regular expression that globally matches channel mentions like `<#222079895583457280>`\n * @type {RegExp}\n */\n\nMessageMentions.CHANNELS_PATTERN = /<#(\\d{17,19})>/g;\nmodule.exports = MessageMentions;\n\n//# sourceURL=webpack://Fosscord/./src/structures/MessageMentions.js?")},"./src/structures/MessageReaction.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nconst GuildEmoji = __webpack_require__(/*! ./GuildEmoji */ "./src/structures/GuildEmoji.js");\n\nconst ReactionEmoji = __webpack_require__(/*! ./ReactionEmoji */ "./src/structures/ReactionEmoji.js");\n\nconst ReactionUserManager = __webpack_require__(/*! ../managers/ReactionUserManager */ "./src/managers/ReactionUserManager.js");\n\nconst Util = __webpack_require__(/*! ../util/Util */ "./src/util/Util.js");\n/**\n * Represents a reaction to a message.\n */\n\n\nclass MessageReaction {\n  /**\n   * @param {Client} client The instantiating client\n   * @param {APIReaction} data The data for the message reaction\n   * @param {Message} message The message the reaction refers to\n   */\n  constructor(client, data, message) {\n    /**\n     * The client that instantiated this message reaction\n     * @name MessageReaction#client\n     * @type {Client}\n     * @readonly\n     */\n    Object.defineProperty(this, \'client\', {\n      value: client\n    });\n    /**\n     * The message that this reaction refers to\n     * @type {Message}\n     */\n\n    this.message = message;\n    /**\n     * Whether the client has given this reaction\n     * @type {boolean}\n     */\n\n    this.me = data.me;\n    /**\n     * A manager of the users that have given this reaction\n     * @type {ReactionUserManager}\n     */\n\n    this.users = new ReactionUserManager(client, undefined, this);\n    this._emoji = new ReactionEmoji(this, data.emoji);\n\n    this._patch(data);\n  }\n\n  _patch(data) {\n    // eslint-disable-next-line eqeqeq\n    if (this.count == undefined) {\n      /**\n       * The number of people that have given the same reaction\n       * @type {?number}\n       */\n      this.count = data.count;\n    }\n  }\n  /**\n   * Removes all users from this reaction.\n   * @returns {Promise<MessageReaction>}\n   */\n\n\n  async remove() {\n    await this.client.api.channels(this.message.channel.id).messages(this.message.id).reactions(this._emoji.identifier).delete();\n    return this;\n  }\n  /**\n   * The emoji of this reaction, either an GuildEmoji object for known custom emojis, or a ReactionEmoji\n   * object which has fewer properties. Whatever the prototype of the emoji, it will still have\n   * `name`, `id`, `identifier` and `toString()`\n   * @type {GuildEmoji|ReactionEmoji}\n   * @readonly\n   */\n\n\n  get emoji() {\n    if (this._emoji instanceof GuildEmoji) return this._emoji; // Check to see if the emoji has become known to the client\n\n    if (this._emoji.id) {\n      const emojis = this.message.client.emojis.cache;\n\n      if (emojis.has(this._emoji.id)) {\n        const emoji = emojis.get(this._emoji.id);\n        this._emoji = emoji;\n        return emoji;\n      }\n    }\n\n    return this._emoji;\n  }\n  /**\n   * Whether or not this reaction is a partial\n   * @type {boolean}\n   * @readonly\n   */\n\n\n  get partial() {\n    return this.count === null;\n  }\n  /**\n   * Fetch this reaction.\n   * @returns {Promise<MessageReaction>}\n   */\n\n\n  async fetch() {\n    const message = await this.message.fetch();\n    const existing = message.reactions.cache.get(this.emoji.id || this.emoji.name); // The reaction won\'t get set when it has been completely removed\n\n    this._patch(existing || {\n      count: 0\n    });\n\n    return this;\n  }\n\n  toJSON() {\n    return Util.flatten(this, {\n      emoji: \'emojiID\',\n      message: \'messageID\'\n    });\n  }\n\n  _add(user) {\n    if (this.partial) return;\n    this.users.cache.set(user.id, user);\n    if (!this.me || user.id !== this.message.client.user.id || this.count === 0) this.count++;\n    if (!this.me) this.me = user.id === this.message.client.user.id;\n  }\n\n  _remove(user) {\n    if (this.partial) return;\n    this.users.cache.delete(user.id);\n    if (!this.me || user.id !== this.message.client.user.id) this.count--;\n    if (user.id === this.message.client.user.id) this.me = false;\n\n    if (this.count <= 0 && this.users.cache.size === 0) {\n      this.message.reactions.cache.delete(this.emoji.id || this.emoji.name);\n    }\n  }\n\n}\n\nmodule.exports = MessageReaction;\n/**\n * @external APIReaction\n * @see {@link https://discord.com/developers/docs/resources/channel#reaction-object}\n */\n\n//# sourceURL=webpack://Fosscord/./src/structures/MessageReaction.js?')},"./src/structures/MessageSelectMenu.js":function(module,exports){eval('throw new Error("Module parse failed: Unexpected token (60:36)\\nFile was processed with these loaders:\\n * ./node_modules/babel-loader/lib/index.js\\nYou may need an additional loader to handle the result of these loaders.\\n|      * @type {?string}\\n|      */\\n>     this.customID = data.custom_id ?? data.customID ?? null;\\n|     /**\\n|      * Custom placeholder text to display when nothing is selected");\n\n//# sourceURL=webpack://Fosscord/./src/structures/MessageSelectMenu.js?')},"./src/structures/NewsChannel.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nconst TextChannel = __webpack_require__(/*! ./TextChannel */ \"./src/structures/TextChannel.js\");\n\nconst {\n  Error\n} = __webpack_require__(/*! ../errors */ \"./src/errors/index.js\");\n/**\n * Represents a guild news channel on Discord.\n * @extends {TextChannel}\n */\n\n\nclass NewsChannel extends TextChannel {\n  _patch(data) {\n    super._patch(data); // News channels don't have a rate limit per user, remove it\n\n\n    this.rateLimitPerUser = undefined;\n  }\n  /**\n   * Adds the target to this channel's followers.\n   * @param {GuildChannelResolvable} channel The channel where the webhook should be created\n   * @param {string} [reason] Reason for creating the webhook\n   * @returns {Promise<NewsChannel>}\n   * @example\n   * if (channel.type === 'news') {\n   *   channel.addFollower('222197033908436994', 'Important announcements')\n   *     .then(() => console.log('Added follower'))\n   *     .catch(console.error);\n   * }\n   */\n\n\n  async addFollower(channel, reason) {\n    const channelID = this.guild.channels.resolveID(channel);\n    if (!channelID) throw new Error('GUILD_CHANNEL_RESOLVE');\n    await this.client.api.channels(this.id).followers.post({\n      data: {\n        webhook_channel_id: channelID\n      },\n      reason\n    });\n    return this;\n  }\n\n}\n\nmodule.exports = NewsChannel;\n\n//# sourceURL=webpack://Fosscord/./src/structures/NewsChannel.js?")},"./src/structures/OAuth2Guild.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nconst BaseGuild = __webpack_require__(/*! ./BaseGuild */ "./src/structures/BaseGuild.js");\n\nconst Permissions = __webpack_require__(/*! ../util/Permissions */ "./src/util/Permissions.js");\n/**\n * A partial guild received when using {@link GuildManager#fetch} to fetch multiple guilds.\n * @extends {BaseGuild}\n */\n\n\nclass OAuth2Guild extends BaseGuild {\n  constructor(client, data) {\n    super(client, data);\n    /**\n     * Whether the client user is the owner of the guild\n     * @type {boolean}\n     */\n\n    this.owner = data.owner;\n    /**\n     * The permissions that the client user has in this guild\n     * @type {Readonly<Permissions>}\n     */\n\n    this.permissions = new Permissions(BigInt(data.permissions)).freeze();\n  }\n\n}\n\nmodule.exports = OAuth2Guild;\n\n//# sourceURL=webpack://Fosscord/./src/structures/OAuth2Guild.js?')},"./src/structures/PermissionOverwrites.js":function(module,exports){eval('throw new Error("Module parse failed: Unexpected token (200:52)\\nFile was processed with these loaders:\\n * ./node_modules/babel-loader/lib/index.js\\nYou may need an additional loader to handle the result of these loaders.\\n|         id: overwrite.id,\\n|         type: OverwriteTypes[overwrite.type],\\n>         allow: Permissions.resolve(overwrite.allow ?? Permissions.defaultBit).toString(),\\n|         deny: Permissions.resolve(overwrite.deny ?? Permissions.defaultBit).toString()\\n|       };");\n\n//# sourceURL=webpack://Fosscord/./src/structures/PermissionOverwrites.js?')},"./src/structures/Presence.js":function(module,exports){eval('throw new Error("Module parse failed: Unexpected token (219:32)\\nFile was processed with these loaders:\\n * ./node_modules/babel-loader/lib/index.js\\nYou may need an additional loader to handle the result of these loaders.\\n|      */\\n| \\n>     this.syncID = data.sync_id ?? null;\\n|     /**\\n|      * The platform the game is being played on");\n\n//# sourceURL=webpack://Fosscord/./src/structures/Presence.js?')},"./src/structures/ReactionCollector.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nconst Collector = __webpack_require__(/*! ./interfaces/Collector */ \"./src/structures/interfaces/Collector.js\");\n\nconst Collection = __webpack_require__(/*! ../util/Collection */ \"./src/util/Collection.js\");\n\nconst {\n  Events\n} = __webpack_require__(/*! ../util/Constants */ \"./src/util/Constants.js\");\n/**\n * @typedef {CollectorOptions} ReactionCollectorOptions\n * @property {number} max The maximum total amount of reactions to collect\n * @property {number} maxEmojis The maximum number of emojis to collect\n * @property {number} maxUsers The maximum number of users to react\n */\n\n/**\n * Collects reactions on messages.\n * Will automatically stop if the message (`'messageDelete'`),\n * channel (`'channelDelete'`), or guild (`'guildDelete'`) are deleted.\n * @extends {Collector}\n */\n\n\nclass ReactionCollector extends Collector {\n  /**\n   * @param {Message} message The message upon which to collect reactions\n   * @param {ReactionCollectorOptions} [options={}] The options to apply to this collector\n   */\n  constructor(message, options = {}) {\n    super(message.client, options);\n    /**\n     * The message upon which to collect reactions\n     * @type {Message}\n     */\n\n    this.message = message;\n    /**\n     * The users which have reacted to this message\n     * @type {Collection}\n     */\n\n    this.users = new Collection();\n    /**\n     * The total number of reactions collected\n     * @type {number}\n     */\n\n    this.total = 0;\n    this.empty = this.empty.bind(this);\n    this._handleChannelDeletion = this._handleChannelDeletion.bind(this);\n    this._handleGuildDeletion = this._handleGuildDeletion.bind(this);\n    this._handleMessageDeletion = this._handleMessageDeletion.bind(this);\n    this.client.incrementMaxListeners();\n    this.client.on(Events.MESSAGE_REACTION_ADD, this.handleCollect);\n    this.client.on(Events.MESSAGE_REACTION_REMOVE, this.handleDispose);\n    this.client.on(Events.MESSAGE_REACTION_REMOVE_ALL, this.empty);\n    this.client.on(Events.MESSAGE_DELETE, this._handleMessageDeletion);\n    this.client.on(Events.CHANNEL_DELETE, this._handleChannelDeletion);\n    this.client.on(Events.GUILD_DELETE, this._handleGuildDeletion);\n    this.once('end', () => {\n      this.client.removeListener(Events.MESSAGE_REACTION_ADD, this.handleCollect);\n      this.client.removeListener(Events.MESSAGE_REACTION_REMOVE, this.handleDispose);\n      this.client.removeListener(Events.MESSAGE_REACTION_REMOVE_ALL, this.empty);\n      this.client.removeListener(Events.MESSAGE_DELETE, this._handleMessageDeletion);\n      this.client.removeListener(Events.CHANNEL_DELETE, this._handleChannelDeletion);\n      this.client.removeListener(Events.GUILD_DELETE, this._handleGuildDeletion);\n      this.client.decrementMaxListeners();\n    });\n    this.on('collect', (reaction, user) => {\n      this.total++;\n      this.users.set(user.id, user);\n    });\n    this.on('remove', (reaction, user) => {\n      this.total--;\n      if (!this.collected.some(r => r.users.cache.has(user.id))) this.users.delete(user.id);\n    });\n  }\n  /**\n   * Handles an incoming reaction for possible collection.\n   * @param {MessageReaction} reaction The reaction to possibly collect\n   * @param {User} user The user that added the reaction\n   * @returns {Promise<Snowflake|string>}\n   * @private\n   */\n\n\n  async collect(reaction, user) {\n    /**\n     * Emitted whenever a reaction is collected.\n     * @event ReactionCollector#collect\n     * @param {MessageReaction} reaction The reaction that was collected\n     * @param {User} user The user that added the reaction\n     */\n    if (reaction.message.id !== this.message.id) return null;\n    /**\n     * Emitted whenever a reaction is newly created on a message. Will emit only when a new reaction is\n     * added to the message, as opposed to {@link Collector#collect} which which will\n     * be emitted even when a reaction has already been added to the message.\n     * @event ReactionCollector#create\n     * @param {MessageReaction} reaction The reaction that was added\n     * @param {User} user The user that added the reaction\n     */\n\n    if (reaction.count === 1 && (await this.filter(reaction, user, this.collected))) {\n      this.emit('create', reaction, user);\n    }\n\n    return ReactionCollector.key(reaction);\n  }\n  /**\n   * Handles a reaction deletion for possible disposal.\n   * @param {MessageReaction} reaction The reaction to possibly dispose of\n   * @param {User} user The user that removed the reaction\n   * @returns {?(Snowflake|string)}\n   */\n\n\n  dispose(reaction, user) {\n    /**\n     * Emitted when the reaction had all the users removed and the `dispose` option is set to true.\n     * @event ReactionCollector#dispose\n     * @param {MessageReaction} reaction The reaction that was disposed of\n     * @param {User} user The user that removed the reaction\n     */\n    if (reaction.message.id !== this.message.id) return null;\n    /**\n     * Emitted when the reaction had one user removed and the `dispose` option is set to true.\n     * @event ReactionCollector#remove\n     * @param {MessageReaction} reaction The reaction that was removed\n     * @param {User} user The user that removed the reaction\n     */\n\n    if (this.collected.has(ReactionCollector.key(reaction)) && this.users.has(user.id)) {\n      this.emit('remove', reaction, user);\n    }\n\n    return reaction.count ? null : ReactionCollector.key(reaction);\n  }\n  /**\n   * Empties this reaction collector.\n   */\n\n\n  empty() {\n    this.total = 0;\n    this.collected.clear();\n    this.users.clear();\n    this.checkEnd();\n  }\n\n  get endReason() {\n    if (this.options.max && this.total >= this.options.max) return 'limit';\n    if (this.options.maxEmojis && this.collected.size >= this.options.maxEmojis) return 'emojiLimit';\n    if (this.options.maxUsers && this.users.size >= this.options.maxUsers) return 'userLimit';\n    return null;\n  }\n  /**\n   * Handles checking if the message has been deleted, and if so, stops the collector with the reason 'messageDelete'.\n   * @private\n   * @param {Message} message The message that was deleted\n   * @returns {void}\n   */\n\n\n  _handleMessageDeletion(message) {\n    if (message.id === this.message.id) {\n      this.stop('messageDelete');\n    }\n  }\n  /**\n   * Handles checking if the channel has been deleted, and if so, stops the collector with the reason 'channelDelete'.\n   * @private\n   * @param {GuildChannel} channel The channel that was deleted\n   * @returns {void}\n   */\n\n\n  _handleChannelDeletion(channel) {\n    if (channel.id === this.message.channel.id) {\n      this.stop('channelDelete');\n    }\n  }\n  /**\n   * Handles checking if the guild has been deleted, and if so, stops the collector with the reason 'guildDelete'.\n   * @private\n   * @param {Guild} guild The guild that was deleted\n   * @returns {void}\n   */\n\n\n  _handleGuildDeletion(guild) {\n    if (this.message.guild && guild.id === this.message.guild.id) {\n      this.stop('guildDelete');\n    }\n  }\n  /**\n   * Gets the collector key for a reaction.\n   * @param {MessageReaction} reaction The message reaction to get the key for\n   * @returns {Snowflake|string}\n   */\n\n\n  static key(reaction) {\n    return reaction.emoji.id || reaction.emoji.name;\n  }\n\n}\n\nmodule.exports = ReactionCollector;\n\n//# sourceURL=webpack://Fosscord/./src/structures/ReactionCollector.js?")},"./src/structures/ReactionEmoji.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nconst Emoji = __webpack_require__(/*! ./Emoji */ "./src/structures/Emoji.js");\n\nconst Util = __webpack_require__(/*! ../util/Util */ "./src/util/Util.js");\n/**\n * Represents a limited emoji set used for both custom and unicode emojis. Custom emojis\n * will use this class opposed to the Emoji class when the client doesn\'t know enough\n * information about them.\n * @extends {Emoji}\n */\n\n\nclass ReactionEmoji extends Emoji {\n  constructor(reaction, emoji) {\n    super(reaction.message.client, emoji);\n    /**\n     * The message reaction this emoji refers to\n     * @type {MessageReaction}\n     */\n\n    this.reaction = reaction;\n  }\n\n  toJSON() {\n    return Util.flatten(this, {\n      identifier: true\n    });\n  }\n\n  valueOf() {\n    return this.id;\n  }\n\n}\n\nmodule.exports = ReactionEmoji;\n\n//# sourceURL=webpack://Fosscord/./src/structures/ReactionEmoji.js?')},"./src/structures/Role.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nconst Base = __webpack_require__(/*! ./Base */ \"./src/structures/Base.js\");\n\nconst {\n  Error,\n  TypeError\n} = __webpack_require__(/*! ../errors */ \"./src/errors/index.js\");\n\nconst Permissions = __webpack_require__(/*! ../util/Permissions */ \"./src/util/Permissions.js\");\n\nconst SnowflakeUtil = __webpack_require__(/*! ../util/SnowflakeUtil */ \"./src/util/SnowflakeUtil.js\");\n\nconst Util = __webpack_require__(/*! ../util/Util */ \"./src/util/Util.js\");\n/**\n * Represents a role on Discord.\n * @extends {Base}\n */\n\n\nclass Role extends Base {\n  /**\n   * @param {Client} client The instantiating client\n   * @param {APIRole} data The data for the role\n   * @param {Guild} guild The guild the role is part of\n   */\n  constructor(client, data, guild) {\n    super(client);\n    /**\n     * The guild that the role belongs to\n     * @type {Guild}\n     */\n\n    this.guild = guild;\n    if (data) this._patch(data);\n  }\n\n  _patch(data) {\n    /**\n     * The ID of the role (unique to the guild it is part of)\n     * @type {Snowflake}\n     */\n    this.id = data.id;\n    /**\n     * The name of the role\n     * @type {string}\n     */\n\n    this.name = data.name;\n    /**\n     * The base 10 color of the role\n     * @type {number}\n     */\n\n    this.color = data.color;\n    /**\n     * If true, users that are part of this role will appear in a separate category in the users list\n     * @type {boolean}\n     */\n\n    this.hoist = data.hoist;\n    /**\n     * The raw position of the role from the API\n     * @type {number}\n     */\n\n    this.rawPosition = data.position;\n    /**\n     * The permissions of the role\n     * @type {Readonly<Permissions>}\n     */\n\n    this.permissions = new Permissions(BigInt(data.permissions)).freeze();\n    /**\n     * Whether or not the role is managed by an external service\n     * @type {boolean}\n     */\n\n    this.managed = data.managed;\n    /**\n     * Whether or not the role can be mentioned by anyone\n     * @type {boolean}\n     */\n\n    this.mentionable = data.mentionable;\n    /**\n     * Whether the role has been deleted\n     * @type {boolean}\n     */\n\n    this.deleted = false;\n    /**\n     * The tags this role has\n     * @type {?Object}\n     * @property {Snowflake} [botID] The id of the bot this role belongs to\n     * @property {Snowflake} [integrationID] The id of the integration this role belongs to\n     * @property {true} [premiumSubscriberRole] Whether this is the guild's premium subscription role\n     */\n\n    this.tags = data.tags ? {} : null;\n\n    if (data.tags) {\n      if ('bot_id' in data.tags) {\n        this.tags.botID = data.tags.bot_id;\n      }\n\n      if ('integration_id' in data.tags) {\n        this.tags.integrationID = data.tags.integration_id;\n      }\n\n      if ('premium_subscriber' in data.tags) {\n        this.tags.premiumSubscriberRole = true;\n      }\n    }\n  }\n  /**\n   * The timestamp the role was created at\n   * @type {number}\n   * @readonly\n   */\n\n\n  get createdTimestamp() {\n    return SnowflakeUtil.deconstruct(this.id).timestamp;\n  }\n  /**\n   * The time the role was created at\n   * @type {Date}\n   * @readonly\n   */\n\n\n  get createdAt() {\n    return new Date(this.createdTimestamp);\n  }\n  /**\n   * The hexadecimal version of the role color, with a leading hashtag\n   * @type {string}\n   * @readonly\n   */\n\n\n  get hexColor() {\n    return `#${this.color.toString(16).padStart(6, '0')}`;\n  }\n  /**\n   * The cached guild members that have this role\n   * @type {Collection<Snowflake, GuildMember>}\n   * @readonly\n   */\n\n\n  get members() {\n    return this.guild.members.cache.filter(m => m.roles.cache.has(this.id));\n  }\n  /**\n   * Whether the role is editable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n\n\n  get editable() {\n    if (this.managed) return false;\n    const clientMember = this.guild.members.resolve(this.client.user);\n    if (!clientMember.permissions.has(Permissions.FLAGS.MANAGE_ROLES)) return false;\n    return clientMember.roles.highest.comparePositionTo(this) > 0;\n  }\n  /**\n   * The position of the role in the role manager\n   * @type {number}\n   * @readonly\n   */\n\n\n  get position() {\n    const sorted = this.guild._sortedRoles();\n\n    return sorted.array().indexOf(sorted.get(this.id));\n  }\n  /**\n   * Compares this role's position to another role's.\n   * @param {RoleResolvable} role Role to compare to this one\n   * @returns {number} Negative number if this role's position is lower (other role's is higher),\n   * positive number if this one is higher (other's is lower), 0 if equal\n   */\n\n\n  comparePositionTo(role) {\n    role = this.guild.roles.resolve(role);\n    if (!role) throw new TypeError('INVALID_TYPE', 'role', 'Role nor a Snowflake');\n    return this.constructor.comparePositions(this, role);\n  }\n  /**\n   * The data for a role.\n   * @typedef {Object} RoleData\n   * @property {string} [name] The name of the role\n   * @property {ColorResolvable} [color] The color of the role, either a hex string or a base 10 number\n   * @property {boolean} [hoist] Whether or not the role should be hoisted\n   * @property {number} [position] The position of the role\n   * @property {PermissionResolvable} [permissions] The permissions of the role\n   * @property {boolean} [mentionable] Whether or not the role should be mentionable\n   */\n\n  /**\n   * Edits the role.\n   * @param {RoleData} data The new data for the role\n   * @param {string} [reason] Reason for editing this role\n   * @returns {Promise<Role>}\n   * @example\n   * // Edit a role\n   * role.edit({ name: 'new role' })\n   *   .then(updated => console.log(`Edited role name to ${updated.name}`))\n   *   .catch(console.error);\n   */\n\n\n  async edit(data, reason) {\n    if (typeof data.position !== 'undefined') {\n      await Util.setPosition(this, data.position, false, this.guild._sortedRoles(), this.client.api.guilds(this.guild.id).roles, reason).then(updatedRoles => {\n        this.client.actions.GuildRolesPositionUpdate.handle({\n          guild_id: this.guild.id,\n          roles: updatedRoles\n        });\n      });\n    }\n\n    return this.client.api.guilds[this.guild.id].roles[this.id].patch({\n      data: {\n        name: data.name || this.name,\n        color: data.color !== null ? Util.resolveColor(data.color || this.color) : null,\n        hoist: typeof data.hoist !== 'undefined' ? data.hoist : this.hoist,\n        permissions: typeof data.permissions !== 'undefined' ? new Permissions(data.permissions) : this.permissions,\n        mentionable: typeof data.mentionable !== 'undefined' ? data.mentionable : this.mentionable\n      },\n      reason\n    }).then(role => {\n      const clone = this._clone();\n\n      clone._patch(role);\n\n      return clone;\n    });\n  }\n  /**\n   * Returns `channel.permissionsFor(role)`. Returns permissions for a role in a guild channel,\n   * taking into account permission overwrites.\n   * @param {ChannelResolvable} channel The guild channel to use as context\n   * @returns {Readonly<Permissions>}\n   */\n\n\n  permissionsIn(channel) {\n    channel = this.guild.channels.resolve(channel);\n    if (!channel) throw new Error('GUILD_CHANNEL_RESOLVE');\n    return channel.rolePermissions(this);\n  }\n  /**\n   * Sets a new name for the role.\n   * @param {string} name The new name of the role\n   * @param {string} [reason] Reason for changing the role's name\n   * @returns {Promise<Role>}\n   * @example\n   * // Set the name of the role\n   * role.setName('new role')\n   *   .then(updated => console.log(`Updated role name to ${updated.name}`))\n   *   .catch(console.error);\n   */\n\n\n  setName(name, reason) {\n    return this.edit({\n      name\n    }, reason);\n  }\n  /**\n   * Sets a new color for the role.\n   * @param {ColorResolvable} color The color of the role\n   * @param {string} [reason] Reason for changing the role's color\n   * @returns {Promise<Role>}\n   * @example\n   * // Set the color of a role\n   * role.setColor('#FF0000')\n   *   .then(updated => console.log(`Set color of role to ${updated.color}`))\n   *   .catch(console.error);\n   */\n\n\n  setColor(color, reason) {\n    return this.edit({\n      color\n    }, reason);\n  }\n  /**\n   * Sets whether or not the role should be hoisted.\n   * @param {boolean} hoist Whether or not to hoist the role\n   * @param {string} [reason] Reason for setting whether or not the role should be hoisted\n   * @returns {Promise<Role>}\n   * @example\n   * // Set the hoist of the role\n   * role.setHoist(true)\n   *   .then(updated => console.log(`Role hoisted: ${updated.hoist}`))\n   *   .catch(console.error);\n   */\n\n\n  setHoist(hoist, reason) {\n    return this.edit({\n      hoist\n    }, reason);\n  }\n  /**\n   * Sets the permissions of the role.\n   * @param {PermissionResolvable} permissions The permissions of the role\n   * @param {string} [reason] Reason for changing the role's permissions\n   * @returns {Promise<Role>}\n   * @example\n   * // Set the permissions of the role\n   * role.setPermissions([Permissions.FLAGS.KICK_MEMBERS, Permissions.FLAGS.BAN_MEMBERS])\n   *   .then(updated => console.log(`Updated permissions to ${updated.permissions.bitfield}`))\n   *   .catch(console.error);\n   * @example\n   * // Remove all permissions from a role\n   * role.setPermissions(0n)\n   *   .then(updated => console.log(`Updated permissions to ${updated.permissions.bitfield}`))\n   *   .catch(console.error);\n   */\n\n\n  setPermissions(permissions, reason) {\n    return this.edit({\n      permissions\n    }, reason);\n  }\n  /**\n   * Sets whether this role is mentionable.\n   * @param {boolean} mentionable Whether this role should be mentionable\n   * @param {string} [reason] Reason for setting whether or not this role should be mentionable\n   * @returns {Promise<Role>}\n   * @example\n   * // Make the role mentionable\n   * role.setMentionable(true)\n   *   .then(updated => console.log(`Role updated ${updated.name}`))\n   *   .catch(console.error);\n   */\n\n\n  setMentionable(mentionable, reason) {\n    return this.edit({\n      mentionable\n    }, reason);\n  }\n  /**\n   * Options used to set position of a role.\n   * @typedef {Object} SetRolePositionOptions\n   * @property {boolean} [relative=false] Whether to change the position relative to its current value or not\n   * @property {string} [reason] The reason for changing the position\n   */\n\n  /**\n   * Sets the new position of the role.\n   * @param {number} position The new position for the role\n   * @param {SetRolePositionOptions} [options] Options for setting the position\n   * @returns {Promise<Role>}\n   * @example\n   * // Set the position of the role\n   * role.setPosition(1)\n   *   .then(updated => console.log(`Role position: ${updated.position}`))\n   *   .catch(console.error);\n   */\n\n\n  setPosition(position, {\n    relative,\n    reason\n  } = {}) {\n    return Util.setPosition(this, position, relative, this.guild._sortedRoles(), this.client.api.guilds(this.guild.id).roles, reason).then(updatedRoles => {\n      this.client.actions.GuildRolesPositionUpdate.handle({\n        guild_id: this.guild.id,\n        roles: updatedRoles\n      });\n      return this;\n    });\n  }\n  /**\n   * Deletes the role.\n   * @param {string} [reason] Reason for deleting this role\n   * @returns {Promise<Role>}\n   * @example\n   * // Delete a role\n   * role.delete('The role needed to go')\n   *   .then(deleted => console.log(`Deleted role ${deleted.name}`))\n   *   .catch(console.error);\n   */\n\n\n  delete(reason) {\n    return this.client.api.guilds[this.guild.id].roles[this.id].delete({\n      reason\n    }).then(() => {\n      this.client.actions.GuildRoleDelete.handle({\n        guild_id: this.guild.id,\n        role_id: this.id\n      });\n      return this;\n    });\n  }\n  /**\n   * Whether this role equals another role. It compares all properties, so for most operations\n   * it is advisable to just compare `role.id === role2.id` as it is much faster and is often\n   * what most users need.\n   * @param {Role} role Role to compare with\n   * @returns {boolean}\n   */\n\n\n  equals(role) {\n    return role && this.id === role.id && this.name === role.name && this.color === role.color && this.hoist === role.hoist && this.position === role.position && this.permissions.bitfield === role.permissions.bitfield && this.managed === role.managed;\n  }\n  /**\n   * When concatenated with a string, this automatically returns the role's mention instead of the Role object.\n   * @returns {string}\n   * @example\n   * // Logs: Role: <@&123456789012345678>\n   * console.log(`Role: ${role}`);\n   */\n\n\n  toString() {\n    if (this.id === this.guild.id) return '@everyone';\n    return `<@&${this.id}>`;\n  }\n\n  toJSON() {\n    return super.toJSON({\n      createdTimestamp: true\n    });\n  }\n  /**\n   * Compares the positions of two roles.\n   * @param {Role} role1 First role to compare\n   * @param {Role} role2 Second role to compare\n   * @returns {number} Negative number if the first role's position is lower (second role's is higher),\n   * positive number if the first's is higher (second's is lower), 0 if equal\n   */\n\n\n  static comparePositions(role1, role2) {\n    if (role1.position === role2.position) return role2.id - role1.id;\n    return role1.position - role2.position;\n  }\n\n}\n\nmodule.exports = Role;\n/**\n * @external APIRole\n * @see {@link https://discord.com/developers/docs/topics/permissions#role-object}\n */\n\n//# sourceURL=webpack://Fosscord/./src/structures/Role.js?")},"./src/structures/SelectMenuInteraction.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nconst MessageComponentInteraction = __webpack_require__(/*! ./MessageComponentInteraction */ \"./src/structures/MessageComponentInteraction.js\");\n/**\n * Represents a select menu interaction.\n * @extends {MessageComponentInteraction}\n */\n\n\nclass SelectMenuInteraction extends MessageComponentInteraction {\n  constructor(client, data) {\n    super(client, data);\n    /**\n     * The values selected, if the component which was interacted with was a select menu\n     * @type {string[]}\n     */\n\n    this.values = this.componentType === 'SELECT_MENU' ? data.data.values : null;\n  }\n\n}\n\nmodule.exports = SelectMenuInteraction;\n\n//# sourceURL=webpack://Fosscord/./src/structures/SelectMenuInteraction.js?")},"./src/structures/StageChannel.js":function(module,exports){eval('throw new Error("Module parse failed: Unexpected token (30:103)\\nFile was processed with these loaders:\\n * ./node_modules/babel-loader/lib/index.js\\nYou may need an additional loader to handle the result of these loaders.\\n| \\n|   get instance() {\\n>     return this.guild.stageInstances.cache.find(stageInstance => stageInstance.channelID === this.id) ?? null;\\n|   }\\n|   /**");\n\n//# sourceURL=webpack://Fosscord/./src/structures/StageChannel.js?')},"./src/structures/StageInstance.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nconst Base = __webpack_require__(/*! ./Base */ "./src/structures/Base.js");\n\nconst {\n  PrivacyLevels\n} = __webpack_require__(/*! ../util/Constants */ "./src/util/Constants.js");\n\nconst SnowflakeUtil = __webpack_require__(/*! ../util/SnowflakeUtil */ "./src/util/SnowflakeUtil.js");\n/**\n * Represents a stage instance.\n * @extends {Base}\n */\n\n\nclass StageInstance extends Base {\n  constructor(client, data) {\n    super(client);\n    /**\n     * The ID of this stage instance\n     * @type {Snowflake}\n     */\n\n    this.id = data.id;\n    /**\n     * Whether the stage instance has been deleted\n     * @type {boolean}\n     */\n\n    this.deleted = false;\n\n    this._patch(data);\n  }\n\n  _patch(data) {\n    /**\n     * The guild ID of the associated stage channel\n     * @type {Snowflake}\n     */\n    this.guildID = data.guild_id;\n    /**\n     * The ID of the associated stage channel\n     * @type {Snowflake}\n     */\n\n    this.channelID = data.channel_id;\n    /**\n     * The topic of the stage instance\n     * @type {string}\n     */\n\n    this.topic = data.topic;\n    /**\n     * The privacy level of the stage instance\n     * @type {PrivacyLevel}\n     */\n\n    this.privacyLevel = PrivacyLevels[data.privacy_level];\n    /**\n     * Whether or not stage discovery is disabled\n     * @type {boolean}\n     */\n\n    this.discoverableDisabled = data.discoverable_disabled;\n  }\n  /**\n   * The stage channel associated with this instance\n   * @type {?StageChannel}\n   * @readonly\n   */\n\n\n  get channel() {\n    return this.client.channels.resolve(this.channelID);\n  }\n  /**\n   * The guild this stage instance belongs to\n   * @type {?Guild}\n   * @readonly\n   */\n\n\n  get guild() {\n    return this.client.guilds.resolve(this.guildID);\n  }\n  /**\n   * Edits this stage instance.\n   * @param {StageInstanceEditOptions} options The options to edit the stage instance\n   * @returns {Promise<StageInstance>}\n   * @example\n   * // Edit a stage instance\n   * stageInstance.edit({ topic: \'new topic\' })\n   *  .then(stageInstance => console.log(stageInstance))\n   *  .catch(console.error)\n   */\n\n\n  edit(options) {\n    return this.guild.stageInstances.edit(this.channelID, options);\n  }\n  /**\n   * Deletes this stage instance.\n   * @returns {Promise<StageInstance>}\n   * @example\n   * // Delete a stage instance\n   * stageInstance.delete()\n   *  .then(stageInstance => console.log(stageInstance))\n   *  .catch(console.error);\n   */\n\n\n  async delete() {\n    await this.guild.stageInstances.delete(this.channelID);\n\n    const clone = this._clone();\n\n    clone.deleted = true;\n    return clone;\n  }\n  /**\n   * Sets the topic of this stage instance.\n   * @param {string} topic The topic for the stage instance\n   * @returns {Promise<StageInstance>}\n   * @example\n   * // Set topic of a stage instance\n   * stageInstance.setTopic(\'new topic\')\n   *  .then(stageInstance => console.log(`Set the topic to: ${stageInstance.topic}`))\n   *  .catch(console.error);\n   */\n\n\n  setTopic(topic) {\n    return this.guild.stageInstances.edit(this.channelID, {\n      topic\n    });\n  }\n  /**\n   * The timestamp this stage instances was created at\n   * @type {number}\n   * @readonly\n   */\n\n\n  get createdTimestamp() {\n    return SnowflakeUtil.deconstruct(this.id).timestamp;\n  }\n  /**\n   * The time this stage instance was created at\n   * @type {Date}\n   * @readonly\n   */\n\n\n  get createdAt() {\n    return new Date(this.createdTimestamp);\n  }\n\n}\n\nmodule.exports = StageInstance;\n\n//# sourceURL=webpack://Fosscord/./src/structures/StageInstance.js?')},"./src/structures/Sticker.js":function(module,exports){eval("throw new Error(\"Module parse failed: Unexpected token (60:29)\\nFile was processed with these loaders:\\n * ./node_modules/babel-loader/lib/index.js\\nYou may need an additional loader to handle the result of these loaders.\\n|      */\\n| \\n>     this.tags = sticker.tags?.split(', ') ?? [];\\n|   }\\n|   /**\");\n\n//# sourceURL=webpack://Fosscord/./src/structures/Sticker.js?")},"./src/structures/StoreChannel.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nconst GuildChannel = __webpack_require__(/*! ./GuildChannel */ \"./src/structures/GuildChannel.js\");\n/**\n * Represents a guild store channel on Discord.\n * @extends {GuildChannel}\n */\n\n\nclass StoreChannel extends GuildChannel {\n  /**\n   * @param {*} guild The guild the store channel is part of\n   * @param {*} data The data for the store channel\n   */\n  constructor(guild, data) {\n    super(guild, data);\n    /**\n     * If the guild considers this channel NSFW\n     * @type {boolean}\n     */\n\n    this.nsfw = Boolean(data.nsfw);\n  }\n\n  _patch(data) {\n    super._patch(data);\n\n    if ('nsfw' in data) {\n      this.nsfw = Boolean(data.nsfw);\n    }\n  }\n\n}\n\nmodule.exports = StoreChannel;\n\n//# sourceURL=webpack://Fosscord/./src/structures/StoreChannel.js?")},"./src/structures/Team.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nconst Base = __webpack_require__(/*! ./Base */ "./src/structures/Base.js");\n\nconst TeamMember = __webpack_require__(/*! ./TeamMember */ "./src/structures/TeamMember.js");\n\nconst Collection = __webpack_require__(/*! ../util/Collection */ "./src/util/Collection.js");\n\nconst SnowflakeUtil = __webpack_require__(/*! ../util/SnowflakeUtil */ "./src/util/SnowflakeUtil.js");\n/**\n * Represents a Client OAuth2 Application Team.\n * @extends {Base}\n */\n\n\nclass Team extends Base {\n  constructor(client, data) {\n    super(client);\n\n    this._patch(data);\n  }\n\n  _patch(data) {\n    /**\n     * The ID of the Team\n     * @type {Snowflake}\n     */\n    this.id = data.id;\n    /**\n     * The name of the Team\n     * @type {string}\n     */\n\n    this.name = data.name;\n    /**\n     * The Team\'s icon hash\n     * @type {?string}\n     */\n\n    this.icon = data.icon || null;\n    /**\n     * The Team\'s owner id\n     * @type {?string}\n     */\n\n    this.ownerID = data.owner_user_id || null;\n    /**\n     * The Team\'s members\n     * @type {Collection<Snowflake, TeamMember>}\n     */\n\n    this.members = new Collection();\n\n    for (const memberData of data.members) {\n      const member = new TeamMember(this, memberData);\n      this.members.set(member.id, member);\n    }\n  }\n  /**\n   * The owner of this team\n   * @type {?TeamMember}\n   * @readonly\n   */\n\n\n  get owner() {\n    return this.members.get(this.ownerID) || null;\n  }\n  /**\n   * The timestamp the team was created at\n   * @type {number}\n   * @readonly\n   */\n\n\n  get createdTimestamp() {\n    return SnowflakeUtil.deconstruct(this.id).timestamp;\n  }\n  /**\n   * The time the team was created at\n   * @type {Date}\n   * @readonly\n   */\n\n\n  get createdAt() {\n    return new Date(this.createdTimestamp);\n  }\n  /**\n   * A link to the teams\'s icon.\n   * @param {StaticImageURLOptions} [options={}] Options for the Image URL\n   * @returns {?string} URL to the icon\n   */\n\n\n  iconURL({\n    format,\n    size\n  } = {}) {\n    if (!this.icon) return null;\n    return this.client.rest.cdn.TeamIcon(this.id, this.icon, {\n      format,\n      size\n    });\n  }\n  /**\n   * When concatenated with a string, this automatically returns the Team\'s name instead of the\n   * Team object.\n   * @returns {string}\n   * @example\n   * // Logs: Team name: My Team\n   * console.log(`Team name: ${team}`);\n   */\n\n\n  toString() {\n    return this.name;\n  }\n\n  toJSON() {\n    return super.toJSON({\n      createdTimestamp: true\n    });\n  }\n\n}\n\nmodule.exports = Team;\n\n//# sourceURL=webpack://Fosscord/./src/structures/Team.js?')},"./src/structures/TeamMember.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nconst Base = __webpack_require__(/*! ./Base */ "./src/structures/Base.js");\n\nconst {\n  MembershipStates\n} = __webpack_require__(/*! ../util/Constants */ "./src/util/Constants.js");\n/**\n * Represents a Client OAuth2 Application Team Member.\n * @extends {Base}\n */\n\n\nclass TeamMember extends Base {\n  constructor(team, data) {\n    super(team.client);\n    /**\n     * The Team this member is part of\n     * @type {Team}\n     */\n\n    this.team = team;\n\n    this._patch(data);\n  }\n\n  _patch(data) {\n    /**\n     * The permissions this Team Member has with regard to the team\n     * @type {string[]}\n     */\n    this.permissions = data.permissions;\n    /**\n     * The permissions this Team Member has with regard to the team\n     * @type {MembershipState}\n     */\n\n    this.membershipState = MembershipStates[data.membership_state];\n    /**\n     * The user for this Team Member\n     * @type {User}\n     */\n\n    this.user = this.client.users.add(data.user);\n  }\n  /**\n   * The ID of the Team Member\n   * @type {Snowflake}\n   * @readonly\n   */\n\n\n  get id() {\n    return this.user.id;\n  }\n  /**\n   * When concatenated with a string, this automatically returns the team members\'s mention instead of the\n   * TeamMember object.\n   * @returns {string}\n   * @example\n   * // Logs: Team Member\'s mention: <@123456789012345678>\n   * console.log(`Team Member\'s mention: ${teamMember}`);\n   */\n\n\n  toString() {\n    return this.user.toString();\n  }\n\n}\n\nmodule.exports = TeamMember;\n\n//# sourceURL=webpack://Fosscord/./src/structures/TeamMember.js?')},"./src/structures/TextChannel.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nconst GuildChannel = __webpack_require__(/*! ./GuildChannel */ \"./src/structures/GuildChannel.js\");\n\nconst Webhook = __webpack_require__(/*! ./Webhook */ \"./src/structures/Webhook.js\");\n\nconst TextBasedChannel = __webpack_require__(/*! ./interfaces/TextBasedChannel */ \"./src/structures/interfaces/TextBasedChannel.js\");\n\nconst MessageManager = __webpack_require__(/*! ../managers/MessageManager */ \"./src/managers/MessageManager.js\");\n\nconst ThreadManager = __webpack_require__(/*! ../managers/ThreadManager */ \"./src/managers/ThreadManager.js\");\n\nconst Collection = __webpack_require__(/*! ../util/Collection */ \"./src/util/Collection.js\");\n\nconst DataResolver = __webpack_require__(/*! ../util/DataResolver */ \"./src/util/DataResolver.js\");\n/**\n * Represents a guild text channel on Discord.\n * @extends {GuildChannel}\n * @implements {TextBasedChannel}\n */\n\n\nclass TextChannel extends GuildChannel {\n  /**\n   * @param {Guild} guild The guild the text channel is part of\n   * @param {APIChannel} data The data for the text channel\n   */\n  constructor(guild, data) {\n    super(guild, data);\n    /**\n     * A manager of the messages sent to this channel\n     * @type {MessageManager}\n     */\n\n    this.messages = new MessageManager(this);\n    /**\n     * A manager of the threads belonging to this channel\n     * @type {ThreadManager}\n     */\n\n    this.threads = new ThreadManager(this);\n    /**\n     * If the guild considers this channel NSFW\n     * @type {boolean}\n     */\n\n    this.nsfw = Boolean(data.nsfw);\n    this._typing = new Map();\n  }\n\n  _patch(data) {\n    super._patch(data);\n\n    if ('topic' in data) {\n      /**\n       * The topic of the text channel\n       * @type {?string}\n       */\n      this.topic = data.topic;\n    }\n\n    if ('nsfw' in data) {\n      this.nsfw = Boolean(data.nsfw);\n    }\n\n    if ('last_message_id' in data) {\n      /**\n       * The ID of the last message sent in this channel, if one was sent\n       * @type {?Snowflake}\n       */\n      this.lastMessageID = data.last_message_id;\n    }\n\n    if ('rate_limit_per_user' in data) {\n      /**\n       * The ratelimit per user for this channel in seconds\n       * <warn>It is not currently possible to set a rate limit per user on a `NewsChannel`.</warn>\n       * @type {number}\n       */\n      this.rateLimitPerUser = data.rate_limit_per_user;\n    }\n\n    if ('last_pin_timestamp' in data) {\n      /**\n       * The timestamp when the last pinned message was pinned, if there was one\n       * @type {?number}\n       */\n      this.lastPinTimestamp = data.last_pin_timestamp ? new Date(data.last_pin_timestamp).getTime() : null;\n    }\n\n    if ('default_auto_archive_duration' in data) {\n      /**\n       * The default auto archive duration for newly created threads in this channel\n       * @type {?ThreadAutoArchiveDuration}\n       */\n      this.defaultAutoArchiveDuration = data.default_auto_archive_duration;\n    }\n\n    if ('messages' in data) {\n      for (const message of data.messages) this.messages.add(message);\n    }\n  }\n  /**\n   * Sets the default auto archive duration for all newly created threads in this channel.\n   * @param {ThreadAutoArchiveDuration} defaultAutoArchiveDuration The new default auto archive duration\n   * @param {string} [reason] Reason for changing the channel's default auto archive duration\n   * @returns {Promise<TextChannel>}\n   */\n\n\n  setDefaultAutoArchiveDuration(defaultAutoArchiveDuration, reason) {\n    return this.edit({\n      defaultAutoArchiveDuration\n    }, reason);\n  }\n  /**\n   * Sets the rate limit per user for this channel.\n   * <warn>It is not currently possible to set the rate limit per user on a `NewsChannel`.</warn>\n   * @param {number} rateLimitPerUser The new ratelimit in seconds\n   * @param {string} [reason] Reason for changing the channel's ratelimits\n   * @returns {Promise<TextChannel>}\n   */\n\n\n  setRateLimitPerUser(rateLimitPerUser, reason) {\n    return this.edit({\n      rateLimitPerUser\n    }, reason);\n  }\n  /**\n   * Sets whether this channel is flagged as NSFW.\n   * @param {boolean} nsfw Whether the channel should be considered NSFW\n   * @param {string} [reason] Reason for changing the channel's NSFW flag\n   * @returns {Promise<TextChannel>}\n   */\n\n\n  setNSFW(nsfw, reason) {\n    return this.edit({\n      nsfw\n    }, reason);\n  }\n  /**\n   * Sets the type of this channel (only conversion between text and news is supported)\n   * @param {string} type The new channel type\n   * @param {string} [reason] Reason for changing the channel's type\n   * @returns {Promise<GuildChannel>}\n   */\n\n\n  setType(type, reason) {\n    return this.edit({\n      type\n    }, reason);\n  }\n  /**\n   * Fetches all webhooks for the channel.\n   * @returns {Promise<Collection<Snowflake, Webhook>>}\n   * @example\n   * // Fetch webhooks\n   * channel.fetchWebhooks()\n   *   .then(hooks => console.log(`This channel has ${hooks.size} hooks`))\n   *   .catch(console.error);\n   */\n\n\n  fetchWebhooks() {\n    return this.client.api.channels[this.id].webhooks.get().then(data => {\n      const hooks = new Collection();\n\n      for (const hook of data) hooks.set(hook.id, new Webhook(this.client, hook));\n\n      return hooks;\n    });\n  }\n  /**\n   * Options used to create a {@link Webhook} for {@link TextChannel} and {@link NewsChannel}.\n   * @typedef {Object} ChannelWebhookCreateOptions\n   * @property {BufferResolvable|Base64Resolvable} [avatar] Avatar for the webhook\n   * @property {string} [reason] Reason for creating the webhook\n   */\n\n  /**\n   * Creates a webhook for the channel.\n   * @param {string} name The name of the webhook\n   * @param {ChannelWebhookCreateOptions} [options] Options for creating the webhook\n   * @returns {Promise<Webhook>} webhook The created webhook\n   * @example\n   * // Create a webhook for the current channel\n   * channel.createWebhook('Snek', {\n   *   avatar: 'https://i.imgur.com/mI8XcpG.jpg',\n   *   reason: 'Needed a cool new Webhook'\n   * })\n   *   .then(console.log)\n   *   .catch(console.error)\n   */\n\n\n  async createWebhook(name, {\n    avatar,\n    reason\n  } = {}) {\n    if (typeof avatar === 'string' && !avatar.startsWith('data:')) {\n      avatar = await DataResolver.resolveImage(avatar);\n    }\n\n    return this.client.api.channels[this.id].webhooks.post({\n      data: {\n        name,\n        avatar\n      },\n      reason\n    }).then(data => new Webhook(this.client, data));\n  } // These are here only for documentation purposes - they are implemented by TextBasedChannel\n\n  /* eslint-disable no-empty-function */\n\n\n  get lastMessage() {}\n\n  get lastPinAt() {}\n\n  send() {}\n\n  startTyping() {}\n\n  stopTyping() {}\n\n  get typing() {}\n\n  get typingCount() {}\n\n  createMessageCollector() {}\n\n  awaitMessages() {}\n\n  createMessageComponentInteractionCollector() {}\n\n  awaitMessageComponentInteraction() {}\n\n  bulkDelete() {}\n\n}\n\nTextBasedChannel.applyToClass(TextChannel, true);\nmodule.exports = TextChannel;\n\n//# sourceURL=webpack://Fosscord/./src/structures/TextChannel.js?")},"./src/structures/ThreadChannel.js":function(module,exports){eval('throw new Error("Module parse failed: Unexpected token (68:47)\\nFile was processed with these loaders:\\n * ./node_modules/babel-loader/lib/index.js\\nYou may need an additional loader to handle the result of these loaders.\\n|      */\\n| \\n>     this.locked = data.thread_metadata.locked ?? false;\\n|     /**\\n|      * Whether the thread is active (false) or archived (true)");\n\n//# sourceURL=webpack://Fosscord/./src/structures/ThreadChannel.js?')},"./src/structures/ThreadMember.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nconst Base = __webpack_require__(/*! ./Base */ "./src/structures/Base.js");\n\nconst ThreadMemberFlags = __webpack_require__(/*! ../util/ThreadMemberFlags */ "./src/util/ThreadMemberFlags.js");\n/**\n * Represents a Member for a Thread.\n * @extends {Base}\n */\n\n\nclass ThreadMember extends Base {\n  /**\n   * @param {ThreadChannel} thread The thread that this member is associated with\n   * @param {APIThreadMember} data The data for the thread member\n   */\n  constructor(thread, data) {\n    super(thread.client);\n    /**\n     * The thread that this member is a part of\n     * @type {ThreadChannel}\n     */\n\n    this.thread = thread;\n    /**\n     * The timestamp the member last joined the thread at\n     * @type {?number}\n     */\n\n    this.joinedTimestamp = null;\n    /**\n     * The id of the thread member\n     * @type {Snowflake}\n     */\n\n    this.id = data.user_id;\n\n    this._patch(data);\n  }\n\n  _patch(data) {\n    this.joinedTimestamp = new Date(data.join_timestamp).getTime();\n    /**\n     * The flags for this thread member\n     * @type {ThreadMemberFlags}\n     */\n\n    this.flags = new ThreadMemberFlags(data.flags).freeze();\n  }\n  /**\n   * The guild member that this thread member instance represents\n   * @type {?GuildMember}\n   * @readonly\n   */\n\n\n  get guildMember() {\n    return this.thread.guild.members.resolve(this.id);\n  }\n  /**\n   * The last time this member joined the thread\n   * @type {?Date}\n   * @readonly\n   */\n\n\n  get joinedAt() {\n    return this.joinedTimestamp ? new Date(this.joinedTimestamp) : null;\n  }\n  /**\n   * The user that this thread member instance represents\n   * @type {?User}\n   * @readonly\n   */\n\n\n  get user() {\n    return this.client.users.resolve(this.id);\n  }\n  /**\n   * Whether the client user can manage this thread member\n   * @type {boolean}\n   * @readonly\n   */\n\n\n  get manageable() {\n    return !this.thread.archived && this.thread.editable;\n  }\n  /**\n   * Remove this member from the thread.\n   * @param {string} [reason] Reason for removing the member\n   * @returns {ThreadMember}\n   */\n\n\n  remove(reason) {\n    return this.thread.members.remove(this.id, reason).then(() => this);\n  }\n\n}\n\nmodule.exports = ThreadMember;\n/**\n * @external APIThreadMember\n * @see {@link https://discord.com/developers/docs/resources/channel#thread-member-object}\n */\n\n//# sourceURL=webpack://Fosscord/./src/structures/ThreadMember.js?')},"./src/structures/User.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nconst Base = __webpack_require__(/*! ./Base */ \"./src/structures/Base.js\");\n\nconst TextBasedChannel = __webpack_require__(/*! ./interfaces/TextBasedChannel */ \"./src/structures/interfaces/TextBasedChannel.js\");\n\nconst {\n  Error\n} = __webpack_require__(/*! ../errors */ \"./src/errors/index.js\");\n\nconst SnowflakeUtil = __webpack_require__(/*! ../util/SnowflakeUtil */ \"./src/util/SnowflakeUtil.js\");\n\nconst UserFlags = __webpack_require__(/*! ../util/UserFlags */ \"./src/util/UserFlags.js\");\n\nlet Structures;\n/**\n * Represents a user on Discord.\n * @implements {TextBasedChannel}\n * @extends {Base}\n */\n\nclass User extends Base {\n  /**\n   * @param {Client} client The instantiating client\n   * @param {APIUser} data The data for the user\n   */\n  constructor(client, data) {\n    super(client);\n    /**\n     * The ID of the user\n     * @type {Snowflake}\n     */\n\n    this.id = data.id;\n    this.system = null;\n    this.flags = null;\n    /**\n     * The ID of the last message sent by the user, if one was sent\n     * @type {?Snowflake}\n     */\n\n    this.lastMessageID = null;\n    /**\n     * The ID of the channel for the last message sent by the user, if one was sent\n     * @type {?Snowflake}\n     */\n\n    this.lastMessageChannelID = null;\n\n    this._patch(data);\n  }\n\n  _patch(data) {\n    if ('username' in data) {\n      /**\n       * The username of the user\n       * @type {?string}\n       */\n      this.username = data.username;\n    } else if (typeof this.username !== 'string') {\n      this.username = null;\n    }\n\n    if ('bot' in data || typeof this.bot !== 'boolean') {\n      /**\n       * Whether or not the user is a bot\n       * @type {boolean}\n       */\n      this.bot = Boolean(data.bot);\n    }\n\n    if ('discriminator' in data) {\n      /**\n       * A discriminator based on username for the user\n       * @type {?string}\n       */\n      this.discriminator = data.discriminator;\n    } else if (typeof this.discriminator !== 'string') {\n      this.discriminator = null;\n    }\n\n    if ('avatar' in data) {\n      /**\n       * The ID of the user's avatar\n       * @type {?string}\n       */\n      this.avatar = data.avatar;\n    } else if (typeof this.avatar !== 'string') {\n      this.avatar = null;\n    }\n\n    if ('system' in data) {\n      /**\n       * Whether the user is an Official Discord System user (part of the urgent message system)\n       * @type {?boolean}\n       */\n      this.system = Boolean(data.system);\n    }\n\n    if ('public_flags' in data) {\n      /**\n       * The flags for this user\n       * @type {?UserFlags}\n       */\n      this.flags = new UserFlags(data.public_flags);\n    }\n  }\n  /**\n   * Whether this User is a partial\n   * @type {boolean}\n   * @readonly\n   */\n\n\n  get partial() {\n    return typeof this.username !== 'string';\n  }\n  /**\n   * The timestamp the user was created at\n   * @type {number}\n   * @readonly\n   */\n\n\n  get createdTimestamp() {\n    return SnowflakeUtil.deconstruct(this.id).timestamp;\n  }\n  /**\n   * The time the user was created at\n   * @type {Date}\n   * @readonly\n   */\n\n\n  get createdAt() {\n    return new Date(this.createdTimestamp);\n  }\n  /**\n   * The Message object of the last message sent by the user, if one was sent\n   * @type {?Message}\n   * @readonly\n   */\n\n\n  get lastMessage() {\n    const channel = this.client.channels.cache.get(this.lastMessageChannelID);\n    return channel && channel.messages.cache.get(this.lastMessageID) || null;\n  }\n  /**\n   * The presence of this user\n   * @type {Presence}\n   * @readonly\n   */\n\n\n  get presence() {\n    for (const guild of this.client.guilds.cache.values()) {\n      if (guild.presences.cache.has(this.id)) return guild.presences.cache.get(this.id);\n    }\n\n    if (!Structures) Structures = __webpack_require__(/*! ../util/Structures */ \"./src/util/Structures.js\");\n    const Presence = Structures.get('Presence');\n    return new Presence(this.client, {\n      user: {\n        id: this.id\n      }\n    });\n  }\n  /**\n   * A link to the user's avatar.\n   * @param {ImageURLOptions} [options={}] Options for the Image URL\n   * @returns {?string}\n   */\n\n\n  avatarURL({\n    format,\n    size,\n    dynamic\n  } = {}) {\n    if (!this.avatar) return null;\n    return this.client.rest.cdn.Avatar(this.id, this.avatar, format, size, dynamic);\n  }\n  /**\n   * A link to the user's default avatar\n   * @type {string}\n   * @readonly\n   */\n\n\n  get defaultAvatarURL() {\n    return this.client.rest.cdn.DefaultAvatar(this.discriminator % 5);\n  }\n  /**\n   * A link to the user's avatar if they have one.\n   * Otherwise a link to their default avatar will be returned.\n   * @param {ImageURLOptions} [options={}] Options for the Image URL\n   * @returns {string}\n   */\n\n\n  displayAvatarURL(options) {\n    return this.avatarURL(options) || this.defaultAvatarURL;\n  }\n  /**\n   * The Discord \"tag\" (e.g. `hydrabolt#0001`) for this user\n   * @type {?string}\n   * @readonly\n   */\n\n\n  get tag() {\n    return typeof this.username === 'string' ? `${this.username}#${this.discriminator}` : null;\n  }\n  /**\n   * Checks whether the user is typing in a channel.\n   * @param {ChannelResolvable} channel The channel to check in\n   * @returns {boolean}\n   */\n\n\n  typingIn(channel) {\n    channel = this.client.channels.resolve(channel);\n    return channel._typing.has(this.id);\n  }\n  /**\n   * Gets the time that the user started typing.\n   * @param {ChannelResolvable} channel The channel to get the time in\n   * @returns {?Date}\n   */\n\n\n  typingSinceIn(channel) {\n    channel = this.client.channels.resolve(channel);\n    return channel._typing.has(this.id) ? new Date(channel._typing.get(this.id).since) : null;\n  }\n  /**\n   * Gets the amount of time the user has been typing in a channel for (in milliseconds), or -1 if they're not typing.\n   * @param {ChannelResolvable} channel The channel to get the time in\n   * @returns {number}\n   */\n\n\n  typingDurationIn(channel) {\n    channel = this.client.channels.resolve(channel);\n    return channel._typing.has(this.id) ? channel._typing.get(this.id).elapsedTime : -1;\n  }\n  /**\n   * The DM between the client's user and this user\n   * @type {?DMChannel}\n   * @readonly\n   */\n\n\n  get dmChannel() {\n    return this.client.channels.cache.find(c => c.type === 'dm' && c.recipient.id === this.id) || null;\n  }\n  /**\n   * Creates a DM channel between the client and the user.\n   * @param {boolean} [force=false] Whether to skip the cache check and request the API\n   * @returns {Promise<DMChannel>}\n   */\n\n\n  async createDM(force = false) {\n    if (!force) {\n      const {\n        dmChannel\n      } = this;\n      if (dmChannel && !dmChannel.partial) return dmChannel;\n    }\n\n    const data = await this.client.api.users(this.client.user.id).channels.post({\n      data: {\n        recipient_id: this.id\n      }\n    });\n    return this.client.channels.add(data);\n  }\n  /**\n   * Deletes a DM channel (if one exists) between the client and the user. Resolves with the channel if successful.\n   * @returns {Promise<DMChannel>}\n   */\n\n\n  async deleteDM() {\n    const {\n      dmChannel\n    } = this;\n    if (!dmChannel) throw new Error('USER_NO_DMCHANNEL');\n    await this.client.api.channels(dmChannel.id).delete();\n    this.client.channels.remove(dmChannel.id);\n    return dmChannel;\n  }\n  /**\n   * Checks if the user is equal to another. It compares ID, username, discriminator, avatar, and bot flags.\n   * It is recommended to compare equality by using `user.id === user2.id` unless you want to compare all properties.\n   * @param {User} user User to compare with\n   * @returns {boolean}\n   */\n\n\n  equals(user) {\n    let equal = user && this.id === user.id && this.username === user.username && this.discriminator === user.discriminator && this.avatar === user.avatar;\n    return equal;\n  }\n  /**\n   * Fetches this user's flags.\n   * @param {boolean} [force=false] Whether to skip the cache check and request the API\n   * @returns {Promise<UserFlags>}\n   */\n\n\n  async fetchFlags(force = false) {\n    if (this.flags && !force) return this.flags;\n    const data = await this.client.api.users(this.id).get();\n\n    this._patch(data);\n\n    return this.flags;\n  }\n  /**\n   * Fetches this user.\n   * @param {boolean} [force=false] Whether to skip the cache check and request the API\n   * @returns {Promise<User>}\n   */\n\n\n  fetch(force = false) {\n    return this.client.users.fetch(this.id, true, force);\n  }\n  /**\n   * When concatenated with a string, this automatically returns the user's mention instead of the User object.\n   * @returns {string}\n   * @example\n   * // Logs: Hello from <@123456789012345678>!\n   * console.log(`Hello from ${user}!`);\n   */\n\n\n  toString() {\n    return `<@${this.id}>`;\n  }\n\n  toJSON(...props) {\n    const json = super.toJSON({\n      createdTimestamp: true,\n      defaultAvatarURL: true,\n      tag: true,\n      lastMessage: false,\n      lastMessageID: false\n    }, ...props);\n    json.avatarURL = this.avatarURL();\n    json.displayAvatarURL = this.displayAvatarURL();\n    return json;\n  } // These are here only for documentation purposes - they are implemented by TextBasedChannel\n\n  /* eslint-disable no-empty-function */\n\n\n  send() {}\n\n}\n\nTextBasedChannel.applyToClass(User);\nmodule.exports = User;\n/**\n * @external APIUser\n * @see {@link https://discord.com/developers/docs/resources/user#user-object}\n */\n\n//# sourceURL=webpack://Fosscord/./src/structures/User.js?")},"./src/structures/VoiceChannel.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nconst BaseGuildVoiceChannel = __webpack_require__(/*! ./BaseGuildVoiceChannel */ "./src/structures/BaseGuildVoiceChannel.js");\n\nconst Permissions = __webpack_require__(/*! ../util/Permissions */ "./src/util/Permissions.js");\n/**\n * Represents a guild voice channel on Discord.\n * @extends {BaseGuildVoiceChannel}\n */\n\n\nclass VoiceChannel extends BaseGuildVoiceChannel {\n  /**\n   * Whether the channel is deletable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n  get deletable() {\n    return super.deletable && this.permissionsFor(this.client.user).has(Permissions.FLAGS.CONNECT, false);\n  }\n  /**\n   * Whether the channel is editable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n\n\n  get editable() {\n    return this.manageable && this.permissionsFor(this.client.user).has(Permissions.FLAGS.CONNECT, false);\n  }\n  /**\n   * Whether the channel is joinable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n\n\n  get joinable() {\n    if (!super.joinable) return false;\n    if (this.full && !this.permissionsFor(this.client.user).has(Permissions.FLAGS.MOVE_MEMBERS, false)) return false;\n    return true;\n  }\n  /**\n   * Checks if the client has permission to send audio to the voice channel\n   * @type {boolean}\n   * @readonly\n   */\n\n\n  get speakable() {\n    return this.permissionsFor(this.client.user).has(Permissions.FLAGS.SPEAK, false);\n  }\n  /**\n   * Sets the bitrate of the channel.\n   * @param {number} bitrate The new bitrate\n   * @param {string} [reason] Reason for changing the channel\'s bitrate\n   * @returns {Promise<VoiceChannel>}\n   * @example\n   * // Set the bitrate of a voice channel\n   * voiceChannel.setBitrate(48000)\n   *   .then(vc => console.log(`Set bitrate to ${vc.bitrate}bps for ${vc.name}`))\n   *   .catch(console.error);\n   */\n\n\n  setBitrate(bitrate, reason) {\n    return this.edit({\n      bitrate\n    }, reason);\n  }\n  /**\n   * Sets the user limit of the channel.\n   * @param {number} userLimit The new user limit\n   * @param {string} [reason] Reason for changing the user limit\n   * @returns {Promise<VoiceChannel>}\n   * @example\n   * // Set the user limit of a voice channel\n   * voiceChannel.setUserLimit(42)\n   *   .then(vc => console.log(`Set user limit to ${vc.userLimit} for ${vc.name}`))\n   *   .catch(console.error);\n   */\n\n\n  setUserLimit(userLimit, reason) {\n    return this.edit({\n      userLimit\n    }, reason);\n  }\n  /**\n   * Sets the RTC region of the channel.\n   * @name VoiceChannel#setRTCRegion\n   * @param {?string} region The new region of the channel. Set to `null` to remove a specific region for the channel\n   * @returns {Promise<VoiceChannel>}\n   * @example\n   * // Set the RTC region to europe\n   * voiceChannel.setRTCRegion(\'europe\');\n   * @example\n   * // Remove a fixed region for this channel - let Discord decide automatically\n   * voiceChannel.setRTCRegion(null);\n   */\n\n\n}\n\nmodule.exports = VoiceChannel;\n\n//# sourceURL=webpack://Fosscord/./src/structures/VoiceChannel.js?')},"./src/structures/VoiceRegion.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nconst Util = __webpack_require__(/*! ../util/Util */ "./src/util/Util.js");\n/**\n * Represents a Discord voice region for guilds.\n */\n\n\nclass VoiceRegion {\n  constructor(data) {\n    /**\n     * The ID of the region\n     * @type {string}\n     */\n    this.id = data.id;\n    /**\n     * Name of the region\n     * @type {string}\n     */\n\n    this.name = data.name;\n    /**\n     * Whether the region is VIP-only\n     * @type {boolean}\n     */\n\n    this.vip = data.vip;\n    /**\n     * Whether the region is deprecated\n     * @type {boolean}\n     */\n\n    this.deprecated = data.deprecated;\n    /**\n     * Whether the region is optimal\n     * @type {boolean}\n     */\n\n    this.optimal = data.optimal;\n    /**\n     * Whether the region is custom\n     * @type {boolean}\n     */\n\n    this.custom = data.custom;\n  }\n\n  toJSON() {\n    return Util.flatten(this);\n  }\n\n}\n\nmodule.exports = VoiceRegion;\n\n//# sourceURL=webpack://Fosscord/./src/structures/VoiceRegion.js?')},"./src/structures/VoiceState.js":function(module,exports){eval("throw new Error(\"Module parse failed: Unexpected token (205:16)\\nFile was processed with these loaders:\\n * ./node_modules/babel-loader/lib/index.js\\nYou may need an additional loader to handle the result of these loaders.\\n|   async setRequestToSpeak(request) {\\n|     const channel = this.channel;\\n>     if (channel?.type !== 'stage') throw new Error('VOICE_NOT_STAGE_CHANNEL');\\n|     if (this.client.user.id !== this.id) throw new Error('VOICE_STATE_NOT_OWN');\\n|     await this.client.api.guilds(this.guild.id, 'voice-states', '@me').patch({\");\n\n//# sourceURL=webpack://Fosscord/./src/structures/VoiceState.js?")},"./src/structures/Webhook.js":function(module,exports){eval('throw new Error("Module parse failed: Unexpected token (89:47)\\nFile was processed with these loaders:\\n * ./node_modules/babel-loader/lib/index.js\\nYou may need an additional loader to handle the result of these loaders.\\n|      */\\n| \\n>     this.owner = data.user ? this.client.users?.add(data.user) ?? data.user : null;\\n|     /**\\n|      * The source guild of the webhook");\n\n//# sourceURL=webpack://Fosscord/./src/structures/Webhook.js?')},"./src/structures/Widget.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nconst Base = __webpack_require__(/*! ./Base */ "./src/structures/Base.js");\n\nconst WidgetMember = __webpack_require__(/*! ./WidgetMember */ "./src/structures/WidgetMember.js");\n\nconst Collection = __webpack_require__(/*! ../util/Collection */ "./src/util/Collection.js");\n/**\n * Represents a Widget.\n */\n\n\nclass Widget extends Base {\n  /**\n   * @param {Client} client The instantiating client\n   * @param {Object} data The raw data\n   */\n  constructor(client, data) {\n    super(client);\n\n    this._patch(data);\n  }\n  /**\n   * Builds the widget with the provided data.\n   * @param {*} data The raw data of the widget\n   * @private\n   */\n\n\n  _patch(data) {\n    /**\n     * The id of the guild.\n     * @type {Snowflake}\n     */\n    this.id = data.id;\n    /**\n     * The name of the guild.\n     * @type {string}\n     */\n\n    this.name = data.name;\n    /**\n     * The invite of the guild.\n     * @type {?string}\n     */\n\n    this.instantInvite = data.instant_invite;\n    /**\n     * The list of channels in the guild.\n     * @type {Collection<Snowflake, WidgetChannel>}\n     */\n\n    this.channels = new Collection();\n\n    for (const channel of data.channels) {\n      this.channels.set(channel.id, channel);\n    }\n    /**\n     * The list of members in the guild.\n     * These strings are just arbitrary numbers, they aren\'t Snowflakes.\n     * @type {Collection<string, WidgetMember>}\n     */\n\n\n    this.members = new Collection();\n\n    for (const member of data.members) {\n      this.members.set(member.id, new WidgetMember(this.client, member));\n    }\n    /**\n     * The number of the members online.\n     * @type {number}\n     */\n\n\n    this.presenceCount = data.presence_count;\n  }\n  /**\n   * Update the Widget.\n   * @returns {Promise<Widget>}\n   */\n\n\n  async fetch() {\n    const data = await this.client.api.guilds(this.id, \'widget.json\').get();\n\n    this._patch(data);\n\n    return this;\n  }\n\n}\n\nmodule.exports = Widget;\n\n//# sourceURL=webpack://Fosscord/./src/structures/Widget.js?')},"./src/structures/WidgetMember.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nconst Base = __webpack_require__(/*! ./Base */ "./src/structures/Base.js");\n/**\n * Represents a WidgetMember.\n */\n\n\nclass WidgetMember extends Base {\n  /**\n   * Activity sent in a {@link WidgetMember}.\n   * @typedef {Object} WidgetActivity\n   * @property {string} name The name of the activity\n   */\n\n  /**\n   * @param {Client} client The instantiating client\n   * @param {Object} data The raw data\n   */\n  constructor(client, data) {\n    super(client);\n    /**\n     * The id of the user. It\'s an arbitrary number.\n     * @type {string}\n     */\n\n    this.id = data.id;\n    /**\n     * The username of the member.\n     * @type {string}\n     */\n\n    this.username = data.username;\n    /**\n     * The discriminator of the member.\n     * @type {string}\n     */\n\n    this.discriminator = data.discriminator;\n    /**\n     * The avatar of the member.\n     * @type {?string}\n     */\n\n    this.avatar = data.avatar;\n    /**\n     * The status of the member.\n     * @type {PresenceStatus}\n     */\n\n    this.status = data.status;\n    /**\n     * IIf the member is server deafened\n     * @type {?boolean}\n     */\n\n    this.deaf = data.deaf;\n    /**\n     * If the member is server muted\n     * @type {?boolean}\n     */\n\n    this.mute = data.mute;\n    /**\n     * If the member is self deafened\n     * @type {?boolean}\n     */\n\n    this.selfDeaf = data.self_deaf;\n    /**\n     * If the member is self muted\n     * @type {?boolean}\n     */\n\n    this.selfMute = data.self_mute;\n    /**\n     * If the member is suppressed\n     * @type {?boolean}\n     */\n\n    this.suppress = data.suppress;\n    /**\n     * The id of the voice channel the member is in, if any\n     * @type {?Snowflake}\n     */\n\n    this.channelID = data.channel_id;\n    /**\n     * The avatar URL of the member.\n     * @type {string}\n     */\n\n    this.avatarURL = data.avatar_url;\n    /**\n     * The activity of the member.\n     * @type {?WidgetActivity}\n     */\n\n    this.activity = data.activity;\n  }\n\n}\n\nmodule.exports = WidgetMember;\n\n//# sourceURL=webpack://Fosscord/./src/structures/WidgetMember.js?')},"./src/structures/interfaces/Application.js":function(module,exports){eval('throw new Error("Module parse failed: Unexpected token (36:27)\\nFile was processed with these loaders:\\n * ./node_modules/babel-loader/lib/index.js\\nYou may need an additional loader to handle the result of these loaders.\\n|      */\\n| \\n>     this.name = data.name ?? this.name ?? null;\\n|     /**\\n|      * The application\'s description");\n\n//# sourceURL=webpack://Fosscord/./src/structures/interfaces/Application.js?')},"./src/structures/interfaces/Collector.js":function(module,exports){eval('throw new Error("Module parse failed: Unexpected token (54:34)\\nFile was processed with these loaders:\\n * ./node_modules/babel-loader/lib/index.js\\nYou may need an additional loader to handle the result of these loaders.\\n|      */\\n| \\n>     this.filter = options.filter ?? (() => true);\\n|     /**\\n|      * The options of this collector");\n\n//# sourceURL=webpack://Fosscord/./src/structures/interfaces/Collector.js?')},"./src/structures/interfaces/TextBasedChannel.js":function(module,exports,__webpack_require__){"use strict";eval("\n/* eslint-disable import/order */\n\nconst MessageCollector = __webpack_require__(/*! ../MessageCollector */ \"./src/structures/MessageCollector.js\");\n\nconst APIMessage = __webpack_require__(/*! ../APIMessage */ \"./src/structures/APIMessage.js\");\n\nconst SnowflakeUtil = __webpack_require__(/*! ../../util/SnowflakeUtil */ \"./src/util/SnowflakeUtil.js\");\n\nconst Collection = __webpack_require__(/*! ../../util/Collection */ \"./src/util/Collection.js\");\n\nconst {\n  RangeError,\n  TypeError,\n  Error\n} = __webpack_require__(/*! ../../errors */ \"./src/errors/index.js\");\n\nconst MessageComponentInteractionCollector = __webpack_require__(/*! ../MessageComponentInteractionCollector */ \"./src/structures/MessageComponentInteractionCollector.js\");\n/**\n * Interface for classes that have text-channel-like features.\n * @interface\n */\n\n\nclass TextBasedChannel {\n  constructor() {\n    /**\n     * A manager of the messages sent to this channel\n     * @type {MessageManager}\n     */\n    this.messages = new MessageManager(this);\n    /**\n     * The ID of the last message in the channel, if one was sent\n     * @type {?Snowflake}\n     */\n\n    this.lastMessageID = null;\n    /**\n     * The timestamp when the last pinned message was pinned, if there was one\n     * @type {?number}\n     */\n\n    this.lastPinTimestamp = null;\n  }\n  /**\n   * The Message object of the last message in the channel, if one was sent\n   * @type {?Message}\n   * @readonly\n   */\n\n\n  get lastMessage() {\n    return this.messages.cache.get(this.lastMessageID) || null;\n  }\n  /**\n   * The date when the last pinned message was pinned, if there was one\n   * @type {?Date}\n   * @readonly\n   */\n\n\n  get lastPinAt() {\n    return this.lastPinTimestamp ? new Date(this.lastPinTimestamp) : null;\n  }\n  /**\n   * Base options provided when sending.\n   * @typedef {Object} BaseMessageOptions\n   * @property {boolean} [tts=false] Whether or not the message should be spoken aloud\n   * @property {string} [nonce=''] The nonce for the message\n   * @property {string} [content=''] The content for the message\n   * @property {MessageEmbed[]|APIEmbed[]} [embeds] The embeds for the message\n   * (see [here](https://discord.com/developers/docs/resources/channel#embed-object) for more details)\n   * @property {MessageMentionOptions} [allowedMentions] Which mentions should be parsed from the message content\n   * (see [here](https://discord.com/developers/docs/resources/channel#allowed-mentions-object) for more details)\n   * @property {FileOptions[]|BufferResolvable[]|MessageAttachment[]} [files] Files to send with the message\n   * @property {string|boolean} [code] Language for optional codeblock formatting to apply\n   * @property {boolean|SplitOptions} [split=false] Whether or not the message should be split into multiple messages if\n   * it exceeds the character limit. If an object is provided, these are the options for splitting the message\n   * @property {MessageActionRow[]|MessageActionRowOptions[]|MessageActionRowComponentResolvable[][]} [components]\n   * Action rows containing interactive components for the message (buttons, select menus)\n   */\n\n  /**\n   * Options provided when sending or editing a message.\n   * @typedef {BaseMessageOptions} MessageOptions\n   * @property {ReplyOptions} [reply] The options for replying to a message\n   */\n\n  /**\n   * Options provided to control parsing of mentions by Discord\n   * @typedef {Object} MessageMentionOptions\n   * @property {MessageMentionTypes[]} [parse] Types of mentions to be parsed\n   * @property {Snowflake[]} [users] Snowflakes of Users to be parsed as mentions\n   * @property {Snowflake[]} [roles] Snowflakes of Roles to be parsed as mentions\n   * @property {boolean} [repliedUser=true] Whether the author of the Message being replied to should be pinged\n   */\n\n  /**\n   * Types of mentions to enable in MessageMentionOptions.\n   * - `roles`\n   * - `users`\n   * - `everyone`\n   * @typedef {string} MessageMentionTypes\n   */\n\n  /**\n   * @typedef {Object} FileOptions\n   * @property {BufferResolvable} attachment File to attach\n   * @property {string} [name='file.jpg'] Filename of the attachment\n   */\n\n  /**\n   * Options for splitting a message.\n   * @typedef {Object} SplitOptions\n   * @property {number} [maxLength=2000] Maximum character length per message piece\n   * @property {string|string[]|RegExp|RegExp[]} [char='\\n'] Character(s) or Regex(s) to split the message with,\n   * an array can be used to split multiple times\n   * @property {string} [prepend=''] Text to prepend to every piece except the first\n   * @property {string} [append=''] Text to append to every piece except the last\n   */\n\n  /**\n   * Options for sending a message with a reply.\n   * @typedef {Object} ReplyOptions\n   * @param {MessageResolvable} messageReference The message to reply to (must be in the same channel and not system)\n   * @param {boolean} [failIfNotExists=true] Whether to error if the referenced message\n   * does not exist (creates a standard message in this case when false)\n   */\n\n  /**\n   * Sends a message to this channel.\n   * @param {string|APIMessage|MessageOptions} options The options to provide\n   * @returns {Promise<Message|Message[]>}\n   * @example\n   * // Send a basic message\n   * channel.send('hello!')\n   *   .then(message => console.log(`Sent message: ${message.content}`))\n   *   .catch(console.error);\n   * @example\n   * // Send a remote file\n   * channel.send({\n   *   files: ['https://cdn.discordapp.com/icons/222078108977594368/6e1019b3179d71046e463a75915e7244.png?size=2048']\n   * })\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // Send a local file\n   * channel.send({\n   *   files: [{\n   *     attachment: 'entire/path/to/file.jpg',\n   *     name: 'file.jpg'\n   *   }]\n   * })\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // Send an embed with a local image inside\n   * channel.send({\n   *   content: 'This is an embed',\n   *   embeds: [\n   *     {\n   *       thumbnail: {\n   *         url: 'attachment://file.jpg'\n   *       }\n   *     }\n   *   ],\n   *   files: [{\n   *     attachment: 'entire/path/to/file.jpg',\n   *     name: 'file.jpg'\n   *   }]\n   * })\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n\n\n  async send(options) {\n    const User = __webpack_require__(/*! ../User */ \"./src/structures/User.js\");\n\n    const GuildMember = __webpack_require__(/*! ../GuildMember */ \"./src/structures/GuildMember.js\");\n\n    if (this instanceof User || this instanceof GuildMember) {\n      return this.createDM().then(dm => dm.send(options));\n    }\n\n    let apiMessage;\n\n    if (options instanceof APIMessage) {\n      apiMessage = options.resolveData();\n    } else {\n      apiMessage = APIMessage.create(this, options).resolveData();\n    }\n\n    if (Array.isArray(apiMessage.data.content)) {\n      return Promise.all(apiMessage.split().map(this.send.bind(this)));\n    }\n\n    const {\n      data,\n      files\n    } = await apiMessage.resolveFiles();\n    return this.client.api.channels[this.id].messages.post({\n      data,\n      files\n    }).then(d => this.client.actions.MessageCreate.handle(d).message);\n  }\n  /**\n   * Starts a typing indicator in the channel.\n   * @param {number} [count=1] The number of times startTyping should be considered to have been called\n   * @returns {Promise} Resolves once the bot stops typing gracefully, or rejects when an error occurs\n   * @example\n   * // Start typing in a channel, or increase the typing count by one\n   * channel.startTyping();\n   * @example\n   * // Start typing in a channel with a typing count of five, or set it to five\n   * channel.startTyping(5);\n   */\n\n\n  startTyping(count) {\n    if (typeof count !== 'undefined' && count < 1) throw new RangeError('TYPING_COUNT');\n\n    if (this.client.user._typing.has(this.id)) {\n      const entry = this.client.user._typing.get(this.id);\n\n      entry.count = count || entry.count + 1;\n      return entry.promise;\n    }\n\n    const entry = {};\n    entry.promise = new Promise((resolve, reject) => {\n      const endpoint = this.client.api.channels[this.id].typing;\n      Object.assign(entry, {\n        count: count || 1,\n        interval: this.client.setInterval(() => {\n          endpoint.post().catch(error => {\n            this.client.clearInterval(entry.interval);\n\n            this.client.user._typing.delete(this.id);\n\n            reject(error);\n          });\n        }, 9000),\n        resolve\n      });\n      endpoint.post().catch(error => {\n        this.client.clearInterval(entry.interval);\n\n        this.client.user._typing.delete(this.id);\n\n        reject(error);\n      });\n\n      this.client.user._typing.set(this.id, entry);\n    });\n    return entry.promise;\n  }\n  /**\n   * Stops the typing indicator in the channel.\n   * The indicator will only stop if this is called as many times as startTyping().\n   * <info>It can take a few seconds for the client user to stop typing.</info>\n   * @param {boolean} [force=false] Whether or not to reset the call count and force the indicator to stop\n   * @example\n   * // Reduce the typing count by one and stop typing if it reached 0\n   * channel.stopTyping();\n   * @example\n   * // Force typing to fully stop regardless of typing count\n   * channel.stopTyping(true);\n   */\n\n\n  stopTyping(force = false) {\n    if (this.client.user._typing.has(this.id)) {\n      const entry = this.client.user._typing.get(this.id);\n\n      entry.count--;\n\n      if (entry.count <= 0 || force) {\n        this.client.clearInterval(entry.interval);\n\n        this.client.user._typing.delete(this.id);\n\n        entry.resolve();\n      }\n    }\n  }\n  /**\n   * Whether or not the typing indicator is being shown in the channel\n   * @type {boolean}\n   * @readonly\n   */\n\n\n  get typing() {\n    return this.client.user._typing.has(this.id);\n  }\n  /**\n   * Number of times `startTyping` has been called\n   * @type {number}\n   * @readonly\n   */\n\n\n  get typingCount() {\n    if (this.client.user._typing.has(this.id)) return this.client.user._typing.get(this.id).count;\n    return 0;\n  }\n  /**\n   * Creates a Message Collector.\n   * @param {MessageCollectorOptions} [options={}] The options to pass to the collector\n   * @returns {MessageCollector}\n   * @example\n   * // Create a message collector\n   * const filter = m => m.content.includes('discord');\n   * const collector = channel.createMessageCollector({ filter, time: 15000 });\n   * collector.on('collect', m => console.log(`Collected ${m.content}`));\n   * collector.on('end', collected => console.log(`Collected ${collected.size} items`));\n   */\n\n\n  createMessageCollector(options = {}) {\n    return new MessageCollector(this, options);\n  }\n  /**\n   * An object containing the same properties as CollectorOptions, but a few more:\n   * @typedef {MessageCollectorOptions} AwaitMessagesOptions\n   * @property {string[]} [errors] Stop/end reasons that cause the promise to reject\n   */\n\n  /**\n   * Similar to createMessageCollector but in promise form.\n   * Resolves with a collection of messages that pass the specified filter.\n   * @param {AwaitMessagesOptions} [options={}] Optional options to pass to the internal collector\n   * @returns {Promise<Collection<Snowflake, Message>>}\n   * @example\n   * // Await !vote messages\n   * const filter = m => m.content.startsWith('!vote');\n   * // Errors: ['time'] treats ending because of the time limit as an error\n   * channel.awaitMessages({ filter, max: 4, time: 60000, errors: ['time'] })\n   *   .then(collected => console.log(collected.size))\n   *   .catch(collected => console.log(`After a minute, only ${collected.size} out of 4 voted.`));\n   */\n\n\n  awaitMessages(options = {}) {\n    return new Promise((resolve, reject) => {\n      const collector = this.createMessageCollector(options);\n      collector.once('end', (collection, reason) => {\n        if (options.errors && options.errors.includes(reason)) {\n          reject(collection);\n        } else {\n          resolve(collection);\n        }\n      });\n    });\n  }\n  /**\n   * Creates a button interaction collector.\n   * @param {MessageComponentInteractionCollectorOptions} [options={}] Options to send to the collector\n   * @returns {MessageComponentInteractionCollector}\n   * @example\n   * // Create a button interaction collector\n   * const filter = (interaction) => interaction.customID === 'button' && interaction.user.id === 'someID';\n   * const collector = channel.createMessageComponentInteractionCollector({ filter, time: 15000 });\n   * collector.on('collect', i => console.log(`Collected ${i.customID}`));\n   * collector.on('end', collected => console.log(`Collected ${collected.size} items`));\n   */\n\n\n  createMessageComponentInteractionCollector(options = {}) {\n    return new MessageComponentInteractionCollector(this, options);\n  }\n  /**\n   * Collects a single component interaction that passes the filter.\n   * The Promise will reject if the time expires.\n   * @param {AwaitMessageComponentInteractionOptions} [options={}] Options to pass to the internal collector\n   * @returns {Promise<MessageComponentInteraction>}\n   * @example\n   * // Collect a message component interaction\n   * const filter = (interaction) => interaction.customID === 'button' && interaction.user.id === 'someID';\n   * channel.awaitMessageComponentInteraction({ filter, time: 15000 })\n   *   .then(interaction => console.log(`${interaction.customID} was clicked!`))\n   *   .catch(console.error);\n   */\n\n\n  awaitMessageComponentInteraction(options = {}) {\n    return new Promise((resolve, reject) => {\n      const collector = this.createMessageComponentInteractionCollector({ ...options,\n        max: 1\n      });\n      collector.once('end', (interactions, reason) => {\n        const interaction = interactions.first();\n        if (interaction) resolve(interaction);else reject(new Error('INTERACTION_COLLECTOR_ERROR', reason));\n      });\n    });\n  }\n  /**\n   * Bulk deletes given messages that are newer than two weeks.\n   * @param {Collection<Snowflake, Message>|MessageResolvable[]|number} messages\n   * Messages or number of messages to delete\n   * @param {boolean} [filterOld=false] Filter messages to remove those which are older than two weeks automatically\n   * @returns {Promise<Collection<Snowflake, Message>>} Deleted messages\n   * @example\n   * // Bulk delete messages\n   * channel.bulkDelete(5)\n   *   .then(messages => console.log(`Bulk deleted ${messages.size} messages`))\n   *   .catch(console.error);\n   */\n\n\n  async bulkDelete(messages, filterOld = false) {\n    if (Array.isArray(messages) || messages instanceof Collection) {\n      let messageIDs = messages instanceof Collection ? messages.keyArray() : messages.map(m => m.id || m);\n\n      if (filterOld) {\n        messageIDs = messageIDs.filter(id => Date.now() - SnowflakeUtil.deconstruct(id).timestamp < 1209600000);\n      }\n\n      if (messageIDs.length === 0) return new Collection();\n\n      if (messageIDs.length === 1) {\n        await this.client.api.channels(this.id).messages(messageIDs[0]).delete();\n        const message = this.client.actions.MessageDelete.getMessage({\n          message_id: messageIDs[0]\n        }, this);\n        return message ? new Collection([[message.id, message]]) : new Collection();\n      }\n\n      await this.client.api.channels[this.id].messages['bulk-delete'].post({\n        data: {\n          messages: messageIDs\n        }\n      });\n      return messageIDs.reduce((col, id) => col.set(id, this.client.actions.MessageDeleteBulk.getMessage({\n        message_id: id\n      }, this)), new Collection());\n    }\n\n    if (!isNaN(messages)) {\n      const msgs = await this.messages.fetch({\n        limit: messages\n      });\n      return this.bulkDelete(msgs, filterOld);\n    }\n\n    throw new TypeError('MESSAGE_BULK_DELETE_TYPE');\n  }\n\n  static applyToClass(structure, full = false, ignore = []) {\n    const props = ['send'];\n\n    if (full) {\n      props.push('lastMessage', 'lastPinAt', 'bulkDelete', 'startTyping', 'stopTyping', 'typing', 'typingCount', 'createMessageCollector', 'awaitMessages', 'createMessageComponentInteractionCollector', 'awaitMessageComponentInteraction');\n    }\n\n    for (const prop of props) {\n      if (ignore.includes(prop)) continue;\n      Object.defineProperty(structure.prototype, prop, Object.getOwnPropertyDescriptor(TextBasedChannel.prototype, prop));\n    }\n  }\n\n}\n\nmodule.exports = TextBasedChannel; // Fixes Circular\n\nconst MessageManager = __webpack_require__(/*! ../../managers/MessageManager */ \"./src/managers/MessageManager.js\");\n\n//# sourceURL=webpack://Fosscord/./src/structures/interfaces/TextBasedChannel.js?")},"./src/util/ActivityFlags.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nconst BitField = __webpack_require__(/*! ./BitField */ "./src/util/BitField.js");\n/**\n * Data structure that makes it easy to interact with an {@link Activity#flags} bitfield.\n * @extends {BitField}\n */\n\n\nclass ActivityFlags extends BitField {}\n/**\n * @name ActivityFlags\n * @kind constructor\n * @memberof ActivityFlags\n * @param {BitFieldResolvable} [bits=0] Bit(s) to read from\n */\n\n/**\n * Numeric activity flags. All available properties:\n * * `INSTANCE`\n * * `JOIN`\n * * `SPECTATE`\n * * `JOIN_REQUEST`\n * * `SYNC`\n * * `PLAY`\n * @type {Object}\n * @see {@link https://discord.com/developers/docs/topics/gateway#activity-object-activity-flags}\n */\n\n\nActivityFlags.FLAGS = {\n  INSTANCE: 1 << 0,\n  JOIN: 1 << 1,\n  SPECTATE: 1 << 2,\n  JOIN_REQUEST: 1 << 3,\n  SYNC: 1 << 4,\n  PLAY: 1 << 5\n};\nmodule.exports = ActivityFlags;\n\n//# sourceURL=webpack://Fosscord/./src/util/ActivityFlags.js?')},"./src/util/ApplicationFlags.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nconst BitField = __webpack_require__(/*! ./BitField */ "./src/util/BitField.js");\n/**\n * Data structure that makes it easy to interact with a {@link ClientApplication#flags} bitfield.\n * @extends {BitField}\n */\n\n\nclass ApplicationFlags extends BitField {}\n/**\n * @name ApplicationFlags\n * @kind constructor\n * @memberof ApplicationFlags\n * @param {BitFieldResolvable} [bits=0] Bit(s) to read from\n */\n\n/**\n * Bitfield of the packed bits\n * @type {number}\n * @name ApplicationFlags#bitfield\n */\n\n/**\n * Numeric application flags. All available properties:\n * * `MANAGED_EMOJI`\n * * `GROUP_DM_CREATE`\n * * `RPC_HAS_CONNECTED`\n * * `GATEWAY_PRESENCE`\n * * `FATEWAY_PRESENCE_LIMITED`\n * * `GATEWAY_GUILD_MEMBERS`\n * * `GATEWAY_GUILD_MEMBERS_LIMITED`\n * * `VERIFICATION_PENDING_GUILD_LIMIT`\n * * `EMBEDDED`\n * @type {Object}\n */\n\n\nApplicationFlags.FLAGS = {\n  MANAGED_EMOJI: 1 << 2,\n  GROUP_DM_CREATE: 1 << 4,\n  RPC_HAS_CONNECTED: 1 << 11,\n  GATEWAY_PRESENCE: 1 << 12,\n  GATEWAY_PRESENCE_LIMITED: 1 << 13,\n  GATEWAY_GUILD_MEMBERS: 1 << 14,\n  GATEWAY_GUILD_MEMBERS_LIMITED: 1 << 15,\n  VERIFICATION_PENDING_GUILD_LIMIT: 1 << 16,\n  EMBEDDED: 1 << 17\n};\nmodule.exports = ApplicationFlags;\n\n//# sourceURL=webpack://Fosscord/./src/util/ApplicationFlags.js?')},"./src/util/BitField.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nconst {\n  RangeError\n} = __webpack_require__(/*! ../errors */ \"./src/errors/index.js\");\n/**\n * Data structure that makes it easy to interact with a bitfield.\n */\n\n\nclass BitField {\n  /**\n   * @param {BitFieldResolvable} [bits=this.constructor.defaultBit] Bit(s) to read from\n   */\n  constructor(bits = this.constructor.defaultBit) {\n    /**\n     * Bitfield of the packed bits\n     * @type {number|bigint}\n     */\n    this.bitfield = this.constructor.resolve(bits);\n  }\n  /**\n   * Checks whether the bitfield has a bit, or any of multiple bits.\n   * @param {BitFieldResolvable} bit Bit(s) to check for\n   * @returns {boolean}\n   */\n\n\n  any(bit) {\n    return (this.bitfield & this.constructor.resolve(bit)) !== this.constructor.defaultBit;\n  }\n  /**\n   * Checks if this bitfield equals another\n   * @param {BitFieldResolvable} bit Bit(s) to check for\n   * @returns {boolean}\n   */\n\n\n  equals(bit) {\n    return this.bitfield === this.constructor.resolve(bit);\n  }\n  /**\n   * Checks whether the bitfield has a bit, or multiple bits.\n   * @param {BitFieldResolvable} bit Bit(s) to check for\n   * @returns {boolean}\n   */\n\n\n  has(bit) {\n    bit = this.constructor.resolve(bit);\n    return (this.bitfield & bit) === bit;\n  }\n  /**\n   * Gets all given bits that are missing from the bitfield.\n   * @param {BitFieldResolvable} bits Bit(s) to check for\n   * @param {...*} hasParams Additional parameters for the has method, if any\n   * @returns {string[]}\n   */\n\n\n  missing(bits, ...hasParams) {\n    return new this.constructor(bits).remove(this).toArray(...hasParams);\n  }\n  /**\n   * Freezes these bits, making them immutable.\n   * @returns {Readonly<BitField>} These bits\n   */\n\n\n  freeze() {\n    return Object.freeze(this);\n  }\n  /**\n   * Adds bits to these ones.\n   * @param {...BitFieldResolvable} [bits] Bits to add\n   * @returns {BitField} These bits or new BitField if the instance is frozen.\n   */\n\n\n  add(...bits) {\n    let total = this.constructor.defaultBit;\n\n    for (const bit of bits) {\n      total |= this.constructor.resolve(bit);\n    }\n\n    if (Object.isFrozen(this)) return new this.constructor(this.bitfield | total);\n    this.bitfield |= total;\n    return this;\n  }\n  /**\n   * Removes bits from these.\n   * @param {...BitFieldResolvable} [bits] Bits to remove\n   * @returns {BitField} These bits or new BitField if the instance is frozen.\n   */\n\n\n  remove(...bits) {\n    let total = this.constructor.defaultBit;\n\n    for (const bit of bits) {\n      total |= this.constructor.resolve(bit);\n    }\n\n    if (Object.isFrozen(this)) return new this.constructor(this.bitfield & ~total);\n    this.bitfield &= ~total;\n    return this;\n  }\n  /**\n   * Gets an object mapping field names to a {@link boolean} indicating whether the\n   * bit is available.\n   * @param {...*} hasParams Additional parameters for the has method, if any\n   * @returns {Object}\n   */\n\n\n  serialize(...hasParams) {\n    const serialized = {};\n\n    for (const [flag, bit] of Object.entries(this.constructor.FLAGS)) serialized[flag] = this.has(bit, ...hasParams);\n\n    return serialized;\n  }\n  /**\n   * Gets an {@link Array} of bitfield names based on the bits available.\n   * @param {...*} hasParams Additional parameters for the has method, if any\n   * @returns {string[]}\n   */\n\n\n  toArray(...hasParams) {\n    return Object.keys(this.constructor.FLAGS).filter(bit => this.has(bit, ...hasParams));\n  }\n\n  toJSON() {\n    return typeof this.bitfield === 'number' ? this.bitfield : this.bitfield.toString();\n  }\n\n  valueOf() {\n    return this.bitfield;\n  }\n\n  *[Symbol.iterator]() {\n    yield* this.toArray();\n  }\n  /**\n   * Data that can be resolved to give a bitfield. This can be:\n   * * A bit number (this can be a number literal or a value taken from {@link BitField.FLAGS})\n   * * An instance of BitField\n   * * An Array of BitFieldResolvable\n   * @typedef {number|bigint|BitField|BitFieldResolvable[]} BitFieldResolvable\n   */\n\n  /**\n   * Resolves bitfields to their numeric form.\n   * @param {BitFieldResolvable} [bit] - bit(s) to resolve\n   * @returns {number|bigint}\n   */\n\n\n  static resolve(bit) {\n    const {\n      defaultBit\n    } = this;\n    if (typeof defaultBit === typeof bit && bit >= defaultBit) return bit;\n    if (bit instanceof BitField) return bit.bitfield;\n    if (Array.isArray(bit)) return bit.map(p => this.resolve(p)).reduce((prev, p) => prev | p, defaultBit);\n    if (typeof bit === 'string' && typeof this.FLAGS[bit] !== 'undefined') return this.FLAGS[bit];\n    throw new RangeError('BITFIELD_INVALID', bit);\n  }\n\n}\n/**\n * Numeric bitfield flags.\n * <info>Defined in extension classes</info>\n * @type {Object}\n * @abstract\n */\n\n\nBitField.FLAGS = {};\n/**\n * @type {number|bigint}\n * @private\n */\n\nBitField.defaultBit = 0;\nmodule.exports = BitField;\n\n//# sourceURL=webpack://Fosscord/./src/util/BitField.js?")},"./src/util/Collection.js":function(module,exports){eval("throw new Error(\"Module parse failed: Unexpected token (9:34)\\nFile was processed with these loaders:\\n * ./node_modules/babel-loader/lib/index.js\\nYou may need an additional loader to handle the result of these loaders.\\n| class Collection extends BaseCollection {\\n|   toJSON() {\\n>     return this.map(e => typeof e?.toJSON === 'function' ? e.toJSON() : Util.flatten(e));\\n|   }\\n| \");\n\n//# sourceURL=webpack://Fosscord/./src/util/Collection.js?")},"./src/util/Constants.js":function(module,exports,__webpack_require__){"use strict";eval("/* WEBPACK VAR INJECTION */(function(process) {\n\nconst Package = exports.Package = __webpack_require__(/*! ../../package.json */ \"./package.json\");\n\nconst {\n  Error,\n  RangeError\n} = __webpack_require__(/*! ../errors */ \"./src/errors/index.js\");\n\nexports.browser = typeof window !== 'undefined';\n/**\n * Rate limit data\n * @typedef {Object} RateLimitData\n * @property {number} timeout Time until this rate limit ends, in ms\n * @property {number} limit The maximum amount of requests of this endpoint\n * @property {string} method The http method of this request\n * @property {string} path The path of the request relative to the HTTP endpoint\n * @property {string} route The route of the request relative to the HTTP endpoint\n * @property {boolean} global Whether this is a global rate limit\n */\n\n/**\n * Whether this rate limit should throw an Error\n * @typedef {Function} RateLimitQueueFilter\n * @param {RateLimitData} rateLimitData The data of this rate limit\n * @returns {boolean|Promise<boolean>}\n */\n\n/**\n * Options for a client.\n * @typedef {Object} ClientOptions\n * @property {number|number[]|string} [shards] ID of the shard to run, or an array of shard IDs. If not specified,\n * the client will spawn {@link ClientOptions#shardCount} shards. If set to `auto`, it will fetch the\n * recommended amount of shards from Discord and spawn that amount\n * @property {number} [shardCount=1] The total amount of shards used by all processes of this bot\n * (e.g. recommended shard count, shard count of the ShardingManager)\n * @property {number} [messageCacheMaxSize=200] Maximum number of messages to cache per channel\n * (-1 or Infinity for unlimited - don't do this without message sweeping, otherwise memory usage will climb\n * indefinitely)\n * @property {number} [messageCacheLifetime=0] How long a message should stay in the cache until it is considered\n * sweepable (in seconds, 0 for forever)\n * @property {number} [messageSweepInterval=0] How frequently to remove messages from the cache that are older than\n * the message cache lifetime (in seconds, 0 for never)\n * @property {MessageMentionOptions} [allowedMentions] Default value for {@link MessageOptions#allowedMentions}\n * @property {number} [invalidRequestWarningInterval=0] The number of invalid REST requests (those that return\n * 401, 403, or 429) in a 10 minute window between emitted warnings (0 for no warnings). That is, if set to 500,\n * warnings will be emitted at invalid request number 500, 1000, 1500, and so on.\n * @property {PartialType[]} [partials] Structures allowed to be partial. This means events can be emitted even when\n * they're missing all the data for a particular structure. See the \"Partials\" topic listed in the sidebar for some\n * important usage information, as partials require you to put checks in place when handling data.\n * @property {number} [restWsBridgeTimeout=5000] Maximum time permitted between REST responses and their\n * corresponding websocket events\n * @property {number} [restTimeOffset=500] Extra time in milliseconds to wait before continuing to make REST\n * requests (higher values will reduce rate-limiting errors on bad connections)\n * @property {number} [restRequestTimeout=15000] Time to wait before cancelling a REST request, in milliseconds\n * @property {number} [restSweepInterval=60] How frequently to delete inactive request buckets, in seconds\n * (or 0 for never)\n * @property {number} [restGlobalRateLimit=0] How many requests to allow sending per second (0 for unlimited, 50 for\n * the standard global limit used by Discord)\n * @property {string[]|RateLimitQueueFilter} [rejectOnRateLimit] Decides how rate limits and pre-emptive throttles\n * should be handled. If this option is an array containing the prefix of the request route (e.g. /channels to match any\n * route starting with /channels, such as /channels/222197033908436994/messages) or a function returning true, a\n * {@link RateLimitError} will be thrown. Otherwise the request will be queued for later\n * @property {number} [retryLimit=1] How many times to retry on 5XX errors (Infinity for indefinite amount of retries)\n * @property {PresenceData} [presence={}] Presence data to use upon login\n * @property {IntentsResolvable} intents Intents to enable for this connection\n * @property {WebsocketOptions} [ws] Options for the WebSocket\n * @property {HTTPOptions} [http] HTTP options\n */\n\nexports.DefaultOptions = {\n  shardCount: 1,\n  messageCacheMaxSize: 200,\n  messageCacheLifetime: 0,\n  messageSweepInterval: 0,\n  invalidRequestWarningInterval: 0,\n  partials: [],\n  restWsBridgeTimeout: 5000,\n  restRequestTimeout: 15000,\n  restGlobalRateLimit: 0,\n  retryLimit: 1,\n  restTimeOffset: 500,\n  restSweepInterval: 60,\n  presence: {},\n\n  /**\n   * WebSocket options (these are left as snake_case to match the API)\n   * @typedef {Object} WebsocketOptions\n   * @property {number} [large_threshold=50] Number of members in a guild after which offline users will no longer be\n   * sent in the initial guild member list, must be between 50 and 250\n   */\n  ws: {\n    large_threshold: 50,\n    compress: false,\n    properties: {\n      $os: process.platform,\n      $browser: 'discord.js',\n      $device: 'discord.js'\n    },\n    version: 9\n  },\n\n  /**\n   * HTTP options\n   * @typedef {Object} HTTPOptions\n   * @property {number} [version=9] API version to use\n   * @property {string} [api='https://discord.com/api'] Base url of the API\n   * @property {string} [cdn='https://cdn.discordapp.com'] Base url of the CDN\n   * @property {string} [invite='https://discord.gg'] Base url of invites\n   * @property {string} [template='https://discord.new'] Base url of templates\n   * @property {Object} [headers] Additional headers to send for all API requests\n   */\n  http: {\n    version: 9,\n    api: 'https://discord.com/api',\n    cdn: 'https://cdn.discordapp.com',\n    invite: 'https://discord.gg',\n    template: 'https://discord.new'\n  }\n};\nexports.UserAgent = `DiscordBot (${Package.homepage.split('#')[0]}, ${Package.version}) Node.js/${process.version}`;\nexports.WSCodes = {\n  1000: 'WS_CLOSE_REQUESTED',\n  4004: 'TOKEN_INVALID',\n  4010: 'SHARDING_INVALID',\n  4011: 'SHARDING_REQUIRED',\n  4013: 'INVALID_INTENTS',\n  4014: 'DISALLOWED_INTENTS'\n};\nconst AllowedImageFormats = ['webp', 'png', 'jpg', 'jpeg', 'gif'];\nconst AllowedImageSizes = Array.from({\n  length: 9\n}, (e, i) => 2 ** (i + 4));\n\nfunction makeImageUrl(root, {\n  format = 'webp',\n  size\n} = {}) {\n  if (format && !AllowedImageFormats.includes(format)) throw new Error('IMAGE_FORMAT', format);\n  if (size && !AllowedImageSizes.includes(size)) throw new RangeError('IMAGE_SIZE', size);\n  return `${root}.${format}${size ? `?size=${size}` : ''}`;\n}\n/**\n * Options for Image URLs.\n * @typedef {StaticImageURLOptions} ImageURLOptions\n * @property {boolean} [dynamic] If true, the format will dynamically change to `gif` for\n * animated avatars; the default is false\n */\n\n/**\n * Options for static Image URLs.\n * @typedef {Object} StaticImageURLOptions\n * @property {string} [format] One of `webp`, `png`, `jpg`, `jpeg`, `gif`. If no format is provided,\n * defaults to `webp`\n * @property {number} [size] One of `16`, `32`, `64`, `128`, `256`, `512`, `1024`, `2048`, `4096`\n */\n\n\nexports.Endpoints = {\n  CDN(root) {\n    return {\n      Emoji: (emojiID, format = 'png') => `${root}/emojis/${emojiID}.${format}`,\n      Asset: name => `${root}/assets/${name}`,\n      DefaultAvatar: discriminator => `${root}/embed/avatars/${discriminator}.png`,\n      Avatar: (userID, hash, format = 'webp', size, dynamic = false) => {\n        if (dynamic) format = hash.startsWith('a_') ? 'gif' : format;\n        return makeImageUrl(`${root}/avatars/${userID}/${hash}`, {\n          format,\n          size\n        });\n      },\n      Banner: (guildID, hash, format = 'webp', size) => makeImageUrl(`${root}/banners/${guildID}/${hash}`, {\n        format,\n        size\n      }),\n      Icon: (guildID, hash, format = 'webp', size, dynamic = false) => {\n        if (dynamic) format = hash.startsWith('a_') ? 'gif' : format;\n        return makeImageUrl(`${root}/icons/${guildID}/${hash}`, {\n          format,\n          size\n        });\n      },\n      AppIcon: (clientID, hash, {\n        format = 'webp',\n        size\n      } = {}) => makeImageUrl(`${root}/app-icons/${clientID}/${hash}`, {\n        size,\n        format\n      }),\n      AppAsset: (clientID, hash, {\n        format = 'webp',\n        size\n      } = {}) => makeImageUrl(`${root}/app-assets/${clientID}/${hash}`, {\n        size,\n        format\n      }),\n      GDMIcon: (channelID, hash, format = 'webp', size) => makeImageUrl(`${root}/channel-icons/${channelID}/${hash}`, {\n        size,\n        format\n      }),\n      Splash: (guildID, hash, format = 'webp', size) => makeImageUrl(`${root}/splashes/${guildID}/${hash}`, {\n        size,\n        format\n      }),\n      DiscoverySplash: (guildID, hash, format = 'webp', size) => makeImageUrl(`${root}/discovery-splashes/${guildID}/${hash}`, {\n        size,\n        format\n      }),\n      TeamIcon: (teamID, hash, {\n        format = 'webp',\n        size\n      } = {}) => makeImageUrl(`${root}/team-icons/${teamID}/${hash}`, {\n        size,\n        format\n      })\n    };\n  },\n\n  invite: (root, code) => `${root}/${code}`,\n  botGateway: '/gateway/bot'\n};\n/**\n * The current status of the client. Here are the available statuses:\n * * READY: 0\n * * CONNECTING: 1\n * * RECONNECTING: 2\n * * IDLE: 3\n * * NEARLY: 4\n * * DISCONNECTED: 5\n * * WAITING_FOR_GUILDS: 6\n * * IDENTIFYING: 7\n * * RESUMING: 8\n * @typedef {number} Status\n */\n\nexports.Status = {\n  READY: 0,\n  CONNECTING: 1,\n  RECONNECTING: 2,\n  IDLE: 3,\n  NEARLY: 4,\n  DISCONNECTED: 5,\n  WAITING_FOR_GUILDS: 6,\n  IDENTIFYING: 7,\n  RESUMING: 8\n};\nexports.OPCodes = {\n  DISPATCH: 0,\n  HEARTBEAT: 1,\n  IDENTIFY: 2,\n  STATUS_UPDATE: 3,\n  VOICE_STATE_UPDATE: 4,\n  VOICE_GUILD_PING: 5,\n  RESUME: 6,\n  RECONNECT: 7,\n  REQUEST_GUILD_MEMBERS: 8,\n  INVALID_SESSION: 9,\n  HELLO: 10,\n  HEARTBEAT_ACK: 11\n};\nexports.Events = {\n  RATE_LIMIT: 'rateLimit',\n  INVALID_REQUEST_WARNING: 'invalidRequestWarning',\n  CLIENT_READY: 'ready',\n  APPLICATION_COMMAND_CREATE: 'applicationCommandCreate',\n  APPLICATION_COMMAND_DELETE: 'applicationCommandDelete',\n  APPLICATION_COMMAND_UPDATE: 'applicationCommandUpdate',\n  GUILD_CREATE: 'guildCreate',\n  GUILD_DELETE: 'guildDelete',\n  GUILD_UPDATE: 'guildUpdate',\n  GUILD_UNAVAILABLE: 'guildUnavailable',\n  GUILD_MEMBER_ADD: 'guildMemberAdd',\n  GUILD_MEMBER_REMOVE: 'guildMemberRemove',\n  GUILD_MEMBER_UPDATE: 'guildMemberUpdate',\n  GUILD_MEMBER_AVAILABLE: 'guildMemberAvailable',\n  GUILD_MEMBERS_CHUNK: 'guildMembersChunk',\n  GUILD_INTEGRATIONS_UPDATE: 'guildIntegrationsUpdate',\n  GUILD_ROLE_CREATE: 'roleCreate',\n  GUILD_ROLE_DELETE: 'roleDelete',\n  INVITE_CREATE: 'inviteCreate',\n  INVITE_DELETE: 'inviteDelete',\n  GUILD_ROLE_UPDATE: 'roleUpdate',\n  GUILD_EMOJI_CREATE: 'emojiCreate',\n  GUILD_EMOJI_DELETE: 'emojiDelete',\n  GUILD_EMOJI_UPDATE: 'emojiUpdate',\n  GUILD_BAN_ADD: 'guildBanAdd',\n  GUILD_BAN_REMOVE: 'guildBanRemove',\n  CHANNEL_CREATE: 'channelCreate',\n  CHANNEL_DELETE: 'channelDelete',\n  CHANNEL_UPDATE: 'channelUpdate',\n  CHANNEL_PINS_UPDATE: 'channelPinsUpdate',\n  MESSAGE_CREATE: 'message',\n  MESSAGE_DELETE: 'messageDelete',\n  MESSAGE_UPDATE: 'messageUpdate',\n  MESSAGE_BULK_DELETE: 'messageDeleteBulk',\n  MESSAGE_REACTION_ADD: 'messageReactionAdd',\n  MESSAGE_REACTION_REMOVE: 'messageReactionRemove',\n  MESSAGE_REACTION_REMOVE_ALL: 'messageReactionRemoveAll',\n  MESSAGE_REACTION_REMOVE_EMOJI: 'messageReactionRemoveEmoji',\n  THREAD_CREATE: 'threadCreate',\n  THREAD_DELETE: 'threadDelete',\n  THREAD_UPDATE: 'threadUpdate',\n  THREAD_LIST_SYNC: 'threadListSync',\n  THREAD_MEMBER_UPDATE: 'threadMemberUpdate',\n  THREAD_MEMBERS_UPDATE: 'threadMembersUpdate',\n  USER_UPDATE: 'userUpdate',\n  PRESENCE_UPDATE: 'presenceUpdate',\n  VOICE_SERVER_UPDATE: 'voiceServerUpdate',\n  VOICE_STATE_UPDATE: 'voiceStateUpdate',\n  TYPING_START: 'typingStart',\n  WEBHOOKS_UPDATE: 'webhookUpdate',\n  INTERACTION_CREATE: 'interaction',\n  ERROR: 'error',\n  WARN: 'warn',\n  DEBUG: 'debug',\n  SHARD_DISCONNECT: 'shardDisconnect',\n  SHARD_ERROR: 'shardError',\n  SHARD_RECONNECTING: 'shardReconnecting',\n  SHARD_READY: 'shardReady',\n  SHARD_RESUME: 'shardResume',\n  INVALIDATED: 'invalidated',\n  RAW: 'raw',\n  STAGE_INSTANCE_CREATE: 'stageInstanceCreate',\n  STAGE_INSTANCE_UPDATE: 'stageInstanceUpdate',\n  STAGE_INSTANCE_DELETE: 'stageInstanceDelete'\n};\nexports.ShardEvents = {\n  CLOSE: 'close',\n  DESTROYED: 'destroyed',\n  INVALID_SESSION: 'invalidSession',\n  READY: 'ready',\n  RESUMED: 'resumed',\n  ALL_READY: 'allReady'\n};\n/**\n * The type of Structure allowed to be a partial:\n * * USER\n * * CHANNEL (only affects DMChannels)\n * * GUILD_MEMBER\n * * MESSAGE\n * * REACTION\n * <warn>Partials require you to put checks in place when handling data, read the Partials topic listed in the\n * sidebar for more information.</warn>\n * @typedef {string} PartialType\n */\n\nexports.PartialTypes = keyMirror(['USER', 'CHANNEL', 'GUILD_MEMBER', 'MESSAGE', 'REACTION']);\n/**\n * The type of a websocket message event, e.g. `MESSAGE_CREATE`. Here are the available events:\n * * READY\n * * RESUMED\n * * APPLICATION_COMMAND_CREATE\n * * APPLICATION_COMMAND_DELETE\n * * APPLICATION_COMMAND_UPDATE\n * * GUILD_CREATE\n * * GUILD_DELETE\n * * GUILD_UPDATE\n * * INVITE_CREATE\n * * INVITE_DELETE\n * * GUILD_MEMBER_ADD\n * * GUILD_MEMBER_REMOVE\n * * GUILD_MEMBER_UPDATE\n * * GUILD_MEMBERS_CHUNK\n * * GUILD_INTEGRATIONS_UPDATE\n * * GUILD_ROLE_CREATE\n * * GUILD_ROLE_DELETE\n * * GUILD_ROLE_UPDATE\n * * GUILD_BAN_ADD\n * * GUILD_BAN_REMOVE\n * * GUILD_EMOJIS_UPDATE\n * * CHANNEL_CREATE\n * * CHANNEL_DELETE\n * * CHANNEL_UPDATE\n * * CHANNEL_PINS_UPDATE\n * * MESSAGE_CREATE\n * * MESSAGE_DELETE\n * * MESSAGE_UPDATE\n * * MESSAGE_DELETE_BULK\n * * MESSAGE_REACTION_ADD\n * * MESSAGE_REACTION_REMOVE\n * * MESSAGE_REACTION_REMOVE_ALL\n * * MESSAGE_REACTION_REMOVE_EMOJI\n * * THREAD_CREATE\n * * THREAD_UPDATE\n * * THREAD_DELETE\n * * THREAD_LIST_SYNC\n * * THREAD_MEMBER_UPDATE\n * * THREAD_MEMBERS_UPDATE\n * * USER_UPDATE\n * * PRESENCE_UPDATE\n * * TYPING_START\n * * VOICE_STATE_UPDATE\n * * VOICE_SERVER_UPDATE\n * * WEBHOOKS_UPDATE\n * * INTERACTION_CREATE\n * * STAGE_INSTANCE_CREATE\n * * STAGE_INSTANCE_UPDATE\n * * STAGE_INSTANCE_DELETE\n * @typedef {string} WSEventType\n */\n\nexports.WSEvents = keyMirror(['READY', 'RESUMED', 'APPLICATION_COMMAND_CREATE', 'APPLICATION_COMMAND_DELETE', 'APPLICATION_COMMAND_UPDATE', 'GUILD_CREATE', 'GUILD_DELETE', 'GUILD_UPDATE', 'INVITE_CREATE', 'INVITE_DELETE', 'GUILD_MEMBER_ADD', 'GUILD_MEMBER_REMOVE', 'GUILD_MEMBER_UPDATE', 'GUILD_MEMBERS_CHUNK', 'GUILD_INTEGRATIONS_UPDATE', 'GUILD_ROLE_CREATE', 'GUILD_ROLE_DELETE', 'GUILD_ROLE_UPDATE', 'GUILD_BAN_ADD', 'GUILD_BAN_REMOVE', 'GUILD_EMOJIS_UPDATE', 'CHANNEL_CREATE', 'CHANNEL_DELETE', 'CHANNEL_UPDATE', 'CHANNEL_PINS_UPDATE', 'MESSAGE_CREATE', 'MESSAGE_DELETE', 'MESSAGE_UPDATE', 'MESSAGE_DELETE_BULK', 'MESSAGE_REACTION_ADD', 'MESSAGE_REACTION_REMOVE', 'MESSAGE_REACTION_REMOVE_ALL', 'MESSAGE_REACTION_REMOVE_EMOJI', 'THREAD_CREATE', 'THREAD_UPDATE', 'THREAD_DELETE', 'THREAD_LIST_SYNC', 'THREAD_MEMBER_UPDATE', 'THREAD_MEMBERS_UPDATE', 'USER_UPDATE', 'PRESENCE_UPDATE', 'TYPING_START', 'VOICE_STATE_UPDATE', 'VOICE_SERVER_UPDATE', 'WEBHOOKS_UPDATE', 'INTERACTION_CREATE', 'STAGE_INSTANCE_CREATE', 'STAGE_INSTANCE_UPDATE', 'STAGE_INSTANCE_DELETE']);\n/**\n * A valid scope to request when generating an invite link.\n * <warn>Scopes that require whitelist are not considered valid for this generator</warn>\n * * `applications.builds.read`: allows reading build data for a users applications\n * * `applications.commands`: allows this bot to create commands in the server\n * * `applications.entitlements`: allows reading entitlements for a users applications\n * * `applications.store.update`: allows reading and updating of store data for a users applications\n * * `connections`: makes the endpoint for getting a users connections available\n * * `email`: allows the `/users/@me` endpoint return with an email\n * * `identify`: allows the `/users/@me` endpoint without an email\n * * `guilds`: makes the `/users/@me/guilds` endpoint available for a user\n * * `guilds.join`: allows the bot to join the user to any guild it is in using Guild#addMember\n * * `gdm.join`: allows joining the user to a group dm\n * * `webhook.incoming`: generates a webhook to a channel\n * @typedef {string} InviteScope\n */\n\nexports.InviteScopes = ['applications.builds.read', 'applications.commands', 'applications.entitlements', 'applications.store.update', 'connections', 'email', 'identity', 'guilds', 'guilds.join', 'gdm.join', 'webhook.incoming'];\n/**\n * The type of a message, e.g. `DEFAULT`. Here are the available types:\n * * DEFAULT\n * * RECIPIENT_ADD\n * * RECIPIENT_REMOVE\n * * CALL\n * * CHANNEL_NAME_CHANGE\n * * CHANNEL_ICON_CHANGE\n * * PINS_ADD\n * * GUILD_MEMBER_JOIN\n * * USER_PREMIUM_GUILD_SUBSCRIPTION\n * * USER_PREMIUM_GUILD_SUBSCRIPTION_TIER_1\n * * USER_PREMIUM_GUILD_SUBSCRIPTION_TIER_2\n * * USER_PREMIUM_GUILD_SUBSCRIPTION_TIER_3\n * * CHANNEL_FOLLOW_ADD\n * * GUILD_DISCOVERY_DISQUALIFIED\n * * GUILD_DISCOVERY_REQUALIFIED\n * * GUILD_DISCOVERY_GRACE_PERIOD_INITIAL_WARNING\n * * GUILD_DISCOVERY_GRACE_PERIOD_FINAL_WARNING\n * * THREAD_CREATED\n * * REPLY\n * * APPLICATION_COMMAND\n * * THREAD_STARTER_MESSAGE\n * * GUILD_INVITE_REMINDER\n * @typedef {string} MessageType\n */\n\nexports.MessageTypes = ['DEFAULT', 'RECIPIENT_ADD', 'RECIPIENT_REMOVE', 'CALL', 'CHANNEL_NAME_CHANGE', 'CHANNEL_ICON_CHANGE', 'PINS_ADD', 'GUILD_MEMBER_JOIN', 'USER_PREMIUM_GUILD_SUBSCRIPTION', 'USER_PREMIUM_GUILD_SUBSCRIPTION_TIER_1', 'USER_PREMIUM_GUILD_SUBSCRIPTION_TIER_2', 'USER_PREMIUM_GUILD_SUBSCRIPTION_TIER_3', 'CHANNEL_FOLLOW_ADD', null, 'GUILD_DISCOVERY_DISQUALIFIED', 'GUILD_DISCOVERY_REQUALIFIED', 'GUILD_DISCOVERY_GRACE_PERIOD_INITIAL_WARNING', 'GUILD_DISCOVERY_GRACE_PERIOD_FINAL_WARNING', 'THREAD_CREATED', 'REPLY', 'APPLICATION_COMMAND', 'THREAD_STARTER_MESSAGE', 'GUILD_INVITE_REMINDER'];\n/**\n * The types of messages that are `System`. The available types are `MessageTypes` excluding:\n * * DEFAULT\n * * REPLY\n * * APPLICATION_COMMAND\n * @typedef {string} SystemMessageType\n */\n\nexports.SystemMessageTypes = exports.MessageTypes.filter(type => type && !['DEFAULT', 'REPLY', 'APPLICATION_COMMAND'].includes(type));\n/**\n * <info>Bots cannot set a `CUSTOM` activity type, it is only for custom statuses received from users</info>\n * The type of an activity of a users presence, e.g. `PLAYING`. Here are the available types:\n * * PLAYING\n * * STREAMING\n * * LISTENING\n * * WATCHING\n * * CUSTOM\n * * COMPETING\n * @typedef {string} ActivityType\n */\n\nexports.ActivityTypes = createEnum(['PLAYING', 'STREAMING', 'LISTENING', 'WATCHING', 'CUSTOM', 'COMPETING']);\nexports.ChannelTypes = createEnum(['TEXT', 'DM', 'VOICE', 'GROUP', 'CATEGORY', 'NEWS', // 6\n'STORE', ...Array(3).fill(null), // 10\n'NEWS_THREAD', 'PUBLIC_THREAD', 'PRIVATE_THREAD', 'STAGE']);\n/**\n * The types of channels that are threads. The available types are:\n * * news_thread\n * * public_thread\n * * private_thread\n * @typedef {string} ThreadChannelType\n */\n\nexports.ThreadChannelTypes = ['news_thread', 'public_thread', 'private_thread'];\nexports.ClientApplicationAssetTypes = {\n  SMALL: 1,\n  BIG: 2\n};\nexports.Colors = {\n  DEFAULT: 0x000000,\n  WHITE: 0xffffff,\n  AQUA: 0x1abc9c,\n  GREEN: 0x57f287,\n  BLUE: 0x3498db,\n  YELLOW: 0xfee75c,\n  PURPLE: 0x9b59b6,\n  LUMINOUS_VIVID_PINK: 0xe91e63,\n  FUCHSIA: 0xeb459e,\n  GOLD: 0xf1c40f,\n  ORANGE: 0xe67e22,\n  RED: 0xed4245,\n  GREY: 0x95a5a6,\n  NAVY: 0x34495e,\n  DARK_AQUA: 0x11806a,\n  DARK_GREEN: 0x1f8b4c,\n  DARK_BLUE: 0x206694,\n  DARK_PURPLE: 0x71368a,\n  DARK_VIVID_PINK: 0xad1457,\n  DARK_GOLD: 0xc27c0e,\n  DARK_ORANGE: 0xa84300,\n  DARK_RED: 0x992d22,\n  DARK_GREY: 0x979c9f,\n  DARKER_GREY: 0x7f8c8d,\n  LIGHT_GREY: 0xbcc0c0,\n  DARK_NAVY: 0x2c3e50,\n  BLURPLE: 0x5865f2,\n  GREYPLE: 0x99aab5,\n  DARK_BUT_NOT_BLACK: 0x2c2f33,\n  NOT_QUITE_BLACK: 0x23272a\n};\n/**\n * The value set for the explicit content filter levels for a guild:\n * * DISABLED\n * * MEMBERS_WITHOUT_ROLES\n * * ALL_MEMBERS\n * @typedef {string} ExplicitContentFilterLevel\n */\n\nexports.ExplicitContentFilterLevels = createEnum(['DISABLED', 'MEMBERS_WITHOUT_ROLES', 'ALL_MEMBERS']);\n/**\n * The value set for the verification levels for a guild:\n * * NONE\n * * LOW\n * * MEDIUM\n * * HIGH\n * * VERY_HIGH\n * @typedef {string} VerificationLevel\n */\n\nexports.VerificationLevels = createEnum(['NONE', 'LOW', 'MEDIUM', 'HIGH', 'VERY_HIGH']);\n/**\n * An error encountered while performing an API request. Here are the potential errors:\n * * UNKNOWN_ACCOUNT\n * * UNKNOWN_APPLICATION\n * * UNKNOWN_CHANNEL\n * * UNKNOWN_GUILD\n * * UNKNOWN_INTEGRATION\n * * UNKNOWN_INVITE\n * * UNKNOWN_MEMBER\n * * UNKNOWN_MESSAGE\n * * UNKNOWN_OVERWRITE\n * * UNKNOWN_PROVIDER\n * * UNKNOWN_ROLE\n * * UNKNOWN_TOKEN\n * * UNKNOWN_USER\n * * UNKNOWN_EMOJI\n * * UNKNOWN_WEBHOOK\n * * UNKNOWN_WEBHOOK_SERVICE\n * * UNKNOWN_SESSION\n * * UNKNOWN_BAN\n * * UNKNOWN_SKU\n * * UNKNOWN_STORE_LISTING\n * * UNKNOWN_ENTITLEMENT\n * * UNKNOWN_BUILD\n * * UNKNOWN_LOBBY\n * * UNKNOWN_BRANCH\n * * UNKNOWN_STORE_DIRECTORY_LAYOUT\n * * UNKNOWN_REDISTRIBUTABLE\n * * UNKNOWN_GIFT_CODE\n * * UNKNOWN_GUILD_TEMPLATE\n * * UNKNOWN_INTERACTION\n * * UNKNOWN_APPLICATION_COMMAND\n * * UNKNOWN_APPLICATION_COMMAND_PERMISSIONS\n * * UNKNOWN_STAGE_INSTANCE\n * * BOT_PROHIBITED_ENDPOINT\n * * BOT_ONLY_ENDPOINT\n * * CANNOT_SEND_EXPLICIT_CONTENT\n * * NOT_AUTHORIZED\n * * SLOWMODE_RATE_LIMIT\n * * ACCOUNT_OWNER_ONLY\n * * ANNOUNCEMENT_EDIT_LIMIT_EXCEEDED\n * * CHANNEL_HIT_WRITE_RATELIMIT\n * * CONTENT_NOT_ALLOWED\n * * MAXIMUM_GUILDS\n * * MAXIMUM_FRIENDS\n * * MAXIMUM_PINS\n * * MAXIMUM_RECIPIENTS\n * * MAXIMUM_ROLES\n * * MAXIMUM_WEBHOOKS\n * * MAXIMUM_EMOJIS\n * * MAXIMUM_REACTIONS\n * * MAXIMUM_CHANNELS\n * * MAXIMUM_ATTACHMENTS\n * * MAXIMUM_INVITES\n * * MAXIMUM_ANIMATED_EMOJIS\n * * MAXIMUM_SERVER_MEMBERS\n * * GUILD_ALREADY_HAS_TEMPLATE\n * * MAXIMUM_THREAD_PARTICIPANTS\n * * MAXIMUM_NON_GUILD_MEMBERS_BANS\n * * MAXIMUM_BAN_FETCHES\n * * UNAUTHORIZED\n * * ACCOUNT_VERIFICATION_REQUIRED\n * * DIRECT_MESSAGES_TOO_FAST\n * * REQUEST_ENTITY_TOO_LARGE\n * * FEATURE_TEMPORARILY_DISABLED\n * * USER_BANNED\n * * TARGET_USER_NOT_CONNECTED_TO_VOICE\n * * ALREADY_CROSSPOSTED\n * * MISSING_ACCESS\n * * INVALID_ACCOUNT_TYPE\n * * CANNOT_EXECUTE_ON_DM\n * * EMBED_DISABLED\n * * CANNOT_EDIT_MESSAGE_BY_OTHER\n * * CANNOT_SEND_EMPTY_MESSAGE\n * * CANNOT_MESSAGE_USER\n * * CANNOT_SEND_MESSAGES_IN_VOICE_CHANNEL\n * * CHANNEL_VERIFICATION_LEVEL_TOO_HIGH\n * * OAUTH2_APPLICATION_BOT_ABSENT\n * * MAXIMUM_OAUTH2_APPLICATIONS\n * * INVALID_OAUTH_STATE\n * * MISSING_PERMISSIONS\n * * INVALID_AUTHENTICATION_TOKEN\n * * NOTE_TOO_LONG\n * * INVALID_BULK_DELETE_QUANTITY\n * * CANNOT_PIN_MESSAGE_IN_OTHER_CHANNEL\n * * INVALID_OR_TAKEN_INVITE_CODE\n * * CANNOT_EXECUTE_ON_SYSTEM_MESSAGE\n * * CANNOT_EXECUTE_ON_CHANNEL_TYPE\n * * INVALID_OAUTH_TOKEN\n * * MISSING_OAUTH_SCOPE\n * * INVALID_WEBHOOK_TOKEN\n * * INVALID_ROLE\n * * INVALID_RECIPIENTS\n * * BULK_DELETE_MESSAGE_TOO_OLD\n * * INVALID_FORM_BODY\n * * INVITE_ACCEPTED_TO_GUILD_NOT_CONTAINING_BOT\n * * INVALID_API_VERSION\n * * CANNOT_SELF_REDEEM_GIFT\n * * PAYMENT_SOURCE_REQUIRED\n * * CANNOT_DELETE_COMMUNITY_REQUIRED_CHANNEL\n * * INVALID_STICKER_SENT\n * * INVALID_OPERATION_ON_ARCHIVED_THREAD\n * * INVALID_THREAD_NOTIFICATION_SETTINGS\n * * PARAMETER_EARLIER_THAN_CREATION\n * * TWO_FACTOR_REQUIRED\n * * NO_USERS_WITH_DISCORDTAG_EXIST\n * * REACTION_BLOCKED\n * * RESOURCE_OVERLOADED\n * * STAGE_ALREADY_OPEN\n * * MESSAGE_ALREADY_HAS_THREAD\n * * THREAD_LOCKED\n * * MAXIMUM_ACTIVE_THREADS\n * * MAXIMUM_ACTIVE_ANNOUCEMENT_THREAD\n * @typedef {string} APIError\n */\n\nexports.APIErrors = {\n  UNKNOWN_ACCOUNT: 10001,\n  UNKNOWN_APPLICATION: 10002,\n  UNKNOWN_CHANNEL: 10003,\n  UNKNOWN_GUILD: 10004,\n  UNKNOWN_INTEGRATION: 10005,\n  UNKNOWN_INVITE: 10006,\n  UNKNOWN_MEMBER: 10007,\n  UNKNOWN_MESSAGE: 10008,\n  UNKNOWN_OVERWRITE: 10009,\n  UNKNOWN_PROVIDER: 10010,\n  UNKNOWN_ROLE: 10011,\n  UNKNOWN_TOKEN: 10012,\n  UNKNOWN_USER: 10013,\n  UNKNOWN_EMOJI: 10014,\n  UNKNOWN_WEBHOOK: 10015,\n  UNKNOWN_WEBHOOK_SERVICE: 10016,\n  UNKNOWN_SESSION: 10020,\n  UNKNOWN_BAN: 10026,\n  UNKNOWN_SKU: 10027,\n  UNKNOWN_STORE_LISTING: 10028,\n  UNKNOWN_ENTITLEMENT: 10029,\n  UNKNOWN_BUILD: 10030,\n  UNKNOWN_LOBBY: 10031,\n  UNKNOWN_BRANCH: 10032,\n  UNKNOWN_STORE_DIRECTORY_LAYOUT: 10033,\n  UNKNOWN_REDISTRIBUTABLE: 10036,\n  UNKNOWN_GIFT_CODE: 10038,\n  UNKNOWN_GUILD_TEMPLATE: 10057,\n  UNKNOWN_INTERACTION: 10062,\n  UNKNOWN_APPLICATION_COMMAND: 10063,\n  UNKNOWN_APPLICATION_COMMAND_PERMISSIONS: 10066,\n  UNKNOWN_STAGE_INSTANCE: 10067,\n  BOT_PROHIBITED_ENDPOINT: 20001,\n  BOT_ONLY_ENDPOINT: 20002,\n  CANNOT_SEND_EXPLICIT_CONTENT: 20009,\n  NOT_AUTHORIZED: 20012,\n  SLOWMODE_RATE_LIMIT: 20016,\n  ACCOUNT_OWNER_ONLY: 20018,\n  ANNOUNCEMENT_EDIT_LIMIT_EXCEEDED: 20022,\n  CHANNEL_HIT_WRITE_RATELIMIT: 20028,\n  CONTENT_NOT_ALLOWED: 20031,\n  MAXIMUM_GUILDS: 30001,\n  MAXIMUM_FRIENDS: 30002,\n  MAXIMUM_PINS: 30003,\n  MAXIMUM_RECIPIENTS: 30004,\n  MAXIMUM_ROLES: 30005,\n  MAXIMUM_WEBHOOKS: 30007,\n  MAXIMUM_EMOJIS: 30008,\n  MAXIMUM_REACTIONS: 30010,\n  MAXIMUM_CHANNELS: 30013,\n  MAXIMUM_ATTACHMENTS: 30015,\n  MAXIMUM_INVITES: 30016,\n  MAXIMUM_ANIMATED_EMOJIS: 30018,\n  MAXIMUM_SERVER_MEMBERS: 30019,\n  GUILD_ALREADY_HAS_TEMPLATE: 30031,\n  MAXIMUM_THREAD_PARTICIPANTS: 30033,\n  MAXIMUM_NON_GUILD_MEMBERS_BANS: 30035,\n  MAXIMUM_BAN_FETCHES: 30037,\n  UNAUTHORIZED: 40001,\n  ACCOUNT_VERIFICATION_REQUIRED: 40002,\n  DIRECT_MESSAGES_TOO_FAST: 40003,\n  REQUEST_ENTITY_TOO_LARGE: 40005,\n  FEATURE_TEMPORARILY_DISABLED: 40006,\n  USER_BANNED: 40007,\n  TARGET_USER_NOT_CONNECTED_TO_VOICE: 40032,\n  ALREADY_CROSSPOSTED: 40033,\n  MISSING_ACCESS: 50001,\n  INVALID_ACCOUNT_TYPE: 50002,\n  CANNOT_EXECUTE_ON_DM: 50003,\n  EMBED_DISABLED: 50004,\n  CANNOT_EDIT_MESSAGE_BY_OTHER: 50005,\n  CANNOT_SEND_EMPTY_MESSAGE: 50006,\n  CANNOT_MESSAGE_USER: 50007,\n  CANNOT_SEND_MESSAGES_IN_VOICE_CHANNEL: 50008,\n  CHANNEL_VERIFICATION_LEVEL_TOO_HIGH: 50009,\n  OAUTH2_APPLICATION_BOT_ABSENT: 50010,\n  MAXIMUM_OAUTH2_APPLICATIONS: 50011,\n  INVALID_OAUTH_STATE: 50012,\n  MISSING_PERMISSIONS: 50013,\n  INVALID_AUTHENTICATION_TOKEN: 50014,\n  NOTE_TOO_LONG: 50015,\n  INVALID_BULK_DELETE_QUANTITY: 50016,\n  CANNOT_PIN_MESSAGE_IN_OTHER_CHANNEL: 50019,\n  INVALID_OR_TAKEN_INVITE_CODE: 50020,\n  CANNOT_EXECUTE_ON_SYSTEM_MESSAGE: 50021,\n  CANNOT_EXECUTE_ON_CHANNEL_TYPE: 50024,\n  INVALID_OAUTH_TOKEN: 50025,\n  MISSING_OAUTH_SCOPE: 50026,\n  INVALID_WEBHOOK_TOKEN: 50027,\n  INVALID_ROLE: 50028,\n  INVALID_RECIPIENTS: 50033,\n  BULK_DELETE_MESSAGE_TOO_OLD: 50034,\n  INVALID_FORM_BODY: 50035,\n  INVITE_ACCEPTED_TO_GUILD_NOT_CONTAINING_BOT: 50036,\n  INVALID_API_VERSION: 50041,\n  CANNOT_SELF_REDEEM_GIFT: 50054,\n  PAYMENT_SOURCE_REQUIRED: 50070,\n  CANNOT_DELETE_COMMUNITY_REQUIRED_CHANNEL: 50074,\n  INVALID_STICKER_SENT: 50081,\n  INVALID_OPERATION_ON_ARCHIVED_THREAD: 50083,\n  INVALID_THREAD_NOTIFICATION_SETTINGS: 50084,\n  PARAMETER_EARLIER_THAN_CREATION: 50085,\n  TWO_FACTOR_REQUIRED: 60003,\n  NO_USERS_WITH_DISCORDTAG_EXIST: 80004,\n  REACTION_BLOCKED: 90001,\n  RESOURCE_OVERLOADED: 130000,\n  STAGE_ALREADY_OPEN: 150006,\n  MESSAGE_ALREADY_HAS_THREAD: 160004,\n  THREAD_LOCKED: 160005,\n  MAXIMUM_ACTIVE_THREADS: 160006,\n  MAXIMUM_ACTIVE_ANNOUCEMENT_THREAD: 160007\n};\n/**\n * The value set for a guild's default message notifications, e.g. `ALL_MESSAGES`. Here are the available types:\n * * ALL_MESSAGES\n * * ONLY_MENTIONS\n * @typedef {string} DefaultMessageNotificationLevel\n */\n\nexports.DefaultMessageNotificationLevels = createEnum(['ALL_MESSAGES', 'ONLY_MENTIONS']);\n/**\n * The value set for a team members's membership state:\n * * INVITED\n * * ACCEPTED\n * @typedef {string} MembershipState\n */\n\nexports.MembershipStates = createEnum([null, 'INVITED', 'ACCEPTED']);\n/**\n * The value set for a webhook's type:\n * * Incoming\n * * Channel Follower\n * @typedef {string} WebhookType\n */\n\nexports.WebhookTypes = createEnum([null, 'Incoming', 'Channel Follower']);\n/**\n * The value set for a sticker's type:\n * * PNG\n * * APNG\n * * LOTTIE\n * @typedef {string} StickerFormatType\n */\n\nexports.StickerFormatTypes = createEnum([null, 'PNG', 'APNG', 'LOTTIE']);\n/**\n * An overwrite type:\n * * role\n * * member\n * @typedef {string} OverwriteType\n */\n\nexports.OverwriteTypes = createEnum(['role', 'member']);\n/**\n * The type of an {@link ApplicationCommandOption} object:\n * * SUB_COMMAND\n * * SUB_COMMAND_GROUP\n * * STRING\n * * INTEGER\n * * BOOLEAN\n * * USER\n * * CHANNEL\n * * ROLE\n * * MENTIONABLE\n * @typedef {string} ApplicationCommandOptionType\n */\n\nexports.ApplicationCommandOptionTypes = createEnum([null, 'SUB_COMMAND', 'SUB_COMMAND_GROUP', 'STRING', 'INTEGER', 'BOOLEAN', 'USER', 'CHANNEL', 'ROLE', 'MENTIONABLE']);\n/**\n * The type of an {@link ApplicationCommandPermissions} object:\n * * ROLE\n * * USER\n * @typedef {string} ApplicationCommandPermissionType\n */\n\nexports.ApplicationCommandPermissionTypes = createEnum([null, 'ROLE', 'USER']);\n/**\n * The type of an {@link Interaction} object:\n * * PING\n * * APPLICATION_COMMAND\n * * MESSAGE_COMPONENT\n * @typedef {string} InteractionType\n */\n\nexports.InteractionTypes = createEnum([null, 'PING', 'APPLICATION_COMMAND', 'MESSAGE_COMPONENT']);\n/**\n * The type of an interaction response:\n * * PONG\n * * CHANNEL_MESSAGE_WITH_SOURCE\n * * DEFERRED_CHANNEL_MESSAGE_WITH_SOURCE\n * * DEFERRED_MESSAGE_UPDATE\n * * UPDATE_MESSAGE\n * @typedef {string} InteractionResponseType\n */\n\nexports.InteractionResponseTypes = createEnum([null, 'PONG', null, null, 'CHANNEL_MESSAGE_WITH_SOURCE', 'DEFERRED_CHANNEL_MESSAGE_WITH_SOURCE', 'DEFERRED_MESSAGE_UPDATE', 'UPDATE_MESSAGE']);\n/**\n * The type of a message component\n * * ACTION_ROW\n * * BUTTON\n * * SELECT_MENU\n * @typedef {string} MessageComponentType\n */\n\nexports.MessageComponentTypes = createEnum([null, 'ACTION_ROW', 'BUTTON', 'SELECT_MENU']);\n/**\n * The style of a message button\n * * PRIMARY\n * * SECONDARY\n * * SUCCESS\n * * DANGER\n * * LINK\n * @typedef {string} MessageButtonStyle\n */\n\nexports.MessageButtonStyles = createEnum([null, 'PRIMARY', 'SECONDARY', 'SUCCESS', 'DANGER', 'LINK']);\n/**\n * The required MFA level for a guild\n * * NONE\n * * ELEVATED\n * @typedef {string} MFALevel\n */\n\nexports.MFALevels = createEnum(['NONE', 'ELEVATED']);\n/**\n * NSFW level of a Guild:\n * * DEFAULT\n * * EXPLICIT\n * * SAFE\n * * AGE_RESTRICTED\n * @typedef {string} NSFWLevel\n */\n\nexports.NSFWLevels = createEnum(['DEFAULT', 'EXPLICIT', 'SAFE', 'AGE_RESTRICTED']);\n/**\n * Privacy level of a {@link StageInstance} object:\n * * PUBLIC\n * * GUILD_ONLY\n * @typedef {string} PrivacyLevel\n */\n\nexports.PrivacyLevels = createEnum([null, 'PUBLIC', 'GUILD_ONLY']);\n/**\n * The premium tier (Server Boost level) of a guild:\n * * NONE\n * * TIER_1\n * * TIER_2\n * * TIER_3\n * @typedef {string} PremiumTier\n */\n\nexports.PremiumTiers = createEnum(['NONE', 'TIER_1', 'TIER_2', 'TIER_3']);\n\nfunction keyMirror(arr) {\n  let tmp = Object.create(null);\n\n  for (const value of arr) tmp[value] = value;\n\n  return tmp;\n}\n\nfunction createEnum(keys) {\n  const obj = {};\n\n  for (const [index, key] of keys.entries()) {\n    if (key === null) continue;\n    obj[key] = index;\n    obj[index] = key;\n  }\n\n  return obj;\n}\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack://Fosscord/./src/util/Constants.js?")},"./src/util/DataResolver.js":function(module,exports){eval('throw new Error("Module parse failed: Unexpected token (56:45)\\nFile was processed with these loaders:\\n * ./node_modules/babel-loader/lib/index.js\\nYou may need an additional loader to handle the result of these loaders.\\n| \\n|   static resolveCode(data, regex) {\\n>     return data.matchAll(regex).next().value?.[1] ?? data;\\n|   }\\n|   /**");\n\n//# sourceURL=webpack://Fosscord/./src/util/DataResolver.js?')},"./src/util/Intents.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nconst BitField = __webpack_require__(/*! ./BitField */ "./src/util/BitField.js");\n/**\n * Data structure that makes it easy to calculate intents.\n * @extends {BitField}\n */\n\n\nclass Intents extends BitField {}\n/**\n * @name Intents\n * @kind constructor\n * @memberof Intents\n * @param {IntentsResolvable} [bits=0] Bit(s) to read from\n */\n\n/**\n * Data that can be resolved to give a permission number. This can be:\n * * A string (see {@link Intents.FLAGS})\n * * An intents flag\n * * An instance of Intents\n * * An array of IntentsResolvable\n * @typedef {string|number|Intents|IntentsResolvable[]} IntentsResolvable\n */\n\n/**\n * Numeric websocket intents. All available properties:\n * * `GUILDS`\n * * `GUILD_MEMBERS`\n * * `GUILD_BANS`\n * * `GUILD_EMOJIS`\n * * `GUILD_INTEGRATIONS`\n * * `GUILD_WEBHOOKS`\n * * `GUILD_INVITES`\n * * `GUILD_VOICE_STATES`\n * * `GUILD_PRESENCES`\n * * `GUILD_MESSAGES`\n * * `GUILD_MESSAGE_REACTIONS`\n * * `GUILD_MESSAGE_TYPING`\n * * `DIRECT_MESSAGES`\n * * `DIRECT_MESSAGE_REACTIONS`\n * * `DIRECT_MESSAGE_TYPING`\n * @type {Object}\n * @see {@link https://discord.com/developers/docs/topics/gateway#list-of-intents}\n */\n\n\nIntents.FLAGS = {\n  GUILDS: 1 << 0,\n  GUILD_MEMBERS: 1 << 1,\n  GUILD_BANS: 1 << 2,\n  GUILD_EMOJIS: 1 << 3,\n  GUILD_INTEGRATIONS: 1 << 4,\n  GUILD_WEBHOOKS: 1 << 5,\n  GUILD_INVITES: 1 << 6,\n  GUILD_VOICE_STATES: 1 << 7,\n  GUILD_PRESENCES: 1 << 8,\n  GUILD_MESSAGES: 1 << 9,\n  GUILD_MESSAGE_REACTIONS: 1 << 10,\n  GUILD_MESSAGE_TYPING: 1 << 11,\n  DIRECT_MESSAGES: 1 << 12,\n  DIRECT_MESSAGE_REACTIONS: 1 << 13,\n  DIRECT_MESSAGE_TYPING: 1 << 14\n};\n/**\n * Bitfield representing all privileged intents\n * @type {number}\n * @see {@link https://discord.com/developers/docs/topics/gateway#privileged-intents}\n */\n\nIntents.PRIVILEGED = Intents.FLAGS.GUILD_MEMBERS | Intents.FLAGS.GUILD_PRESENCES;\n/**\n * Bitfield representing all intents combined\n * @type {number}\n */\n\nIntents.ALL = Object.values(Intents.FLAGS).reduce((acc, p) => acc | p, 0);\n/**\n * Bitfield representing all non-privileged intents\n * @type {number}\n */\n\nIntents.NON_PRIVILEGED = Intents.ALL & ~Intents.PRIVILEGED;\nmodule.exports = Intents;\n\n//# sourceURL=webpack://Fosscord/./src/util/Intents.js?')},"./src/util/LimitedCollection.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nconst Collection = __webpack_require__(/*! ./Collection.js */ "./src/util/Collection.js");\n/**\n * A Collection which holds a max amount of entries. The first key is deleted if the Collection has\n * reached max size.\n * @extends {Collection}\n * @param {number} [maxSize=0] The maximum size of the Collection\n * @param {Iterable} [iterable=null] Optional entries passed to the Map constructor.\n * @private\n */\n\n\nclass LimitedCollection extends Collection {\n  constructor(maxSize = 0, iterable = null) {\n    super(iterable);\n    /**\n     * The max size of the Collection.\n     * @type {number}\n     */\n\n    this.maxSize = maxSize;\n  }\n\n  set(key, value) {\n    if (this.maxSize === 0) return this;\n    if (this.size >= this.maxSize && !this.has(key)) this.delete(this.firstKey());\n    return super.set(key, value);\n  }\n\n  static get [Symbol.species]() {\n    return Collection;\n  }\n\n}\n\nmodule.exports = LimitedCollection;\n\n//# sourceURL=webpack://Fosscord/./src/util/LimitedCollection.js?')},"./src/util/MessageFlags.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nconst BitField = __webpack_require__(/*! ./BitField */ "./src/util/BitField.js");\n/**\n * Data structure that makes it easy to interact with a {@link Message#flags} bitfield.\n * @extends {BitField}\n */\n\n\nclass MessageFlags extends BitField {}\n/**\n * @name MessageFlags\n * @kind constructor\n * @memberof MessageFlags\n * @param {BitFieldResolvable} [bits=0] Bit(s) to read from\n */\n\n/**\n * Bitfield of the packed bits\n * @type {number}\n * @name MessageFlags#bitfield\n */\n\n/**\n * Numeric message flags. All available properties:\n * * `CROSSPOSTED`\n * * `IS_CROSSPOST`\n * * `SUPPRESS_EMBEDS`\n * * `SOURCE_MESSAGE_DELETED`\n * * `URGENT`\n * * `HAS_THREAD`\n * * `EPHEMERAL`\n * * `LOADING`\n * @type {Object}\n * @see {@link https://discord.com/developers/docs/resources/channel#message-object-message-flags}\n */\n\n\nMessageFlags.FLAGS = {\n  CROSSPOSTED: 1 << 0,\n  IS_CROSSPOST: 1 << 1,\n  SUPPRESS_EMBEDS: 1 << 2,\n  SOURCE_MESSAGE_DELETED: 1 << 3,\n  URGENT: 1 << 4,\n  HAS_THREAD: 1 << 5,\n  EPHEMERAL: 1 << 6,\n  LOADING: 1 << 7\n};\nmodule.exports = MessageFlags;\n\n//# sourceURL=webpack://Fosscord/./src/util/MessageFlags.js?')},"./src/util/Permissions.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nconst BitField = __webpack_require__(/*! ./BitField */ "./src/util/BitField.js");\n/**\n * Data structure that makes it easy to interact with a permission bitfield. All {@link GuildMember}s have a set of\n * permissions in their guild, and each channel in the guild may also have {@link PermissionOverwrites} for the member\n * that override their default permissions.\n * @extends {BitField}\n */\n\n\nclass Permissions extends BitField {\n  /**\n   * Bitfield of the packed bits\n   * @type {bigint}\n   * @name Permissions#bitfield\n   */\n\n  /**\n   * Data that can be resolved to give a permission number. This can be:\n   * * A string (see {@link Permissions.FLAGS})\n   * * A permission number\n   * * An instance of Permissions\n   * * An Array of PermissionResolvable\n   * @typedef {string|bigint|Permissions|PermissionResolvable[]} PermissionResolvable\n   */\n\n  /**\n   * Gets all given bits that are missing from the bitfield.\n   * @param {BitFieldResolvable} bits Bit(s) to check for\n   * @param {boolean} [checkAdmin=true] Whether to allow the administrator permission to override\n   * @returns {string[]}\n   */\n  missing(bits, checkAdmin = true) {\n    return checkAdmin && this.has(this.constructor.FLAGS.ADMINISTRATOR) ? [] : super.missing(bits, checkAdmin);\n  }\n  /**\n   * Checks whether the bitfield has a permission, or any of multiple permissions.\n   * @param {PermissionResolvable} permission Permission(s) to check for\n   * @param {boolean} [checkAdmin=true] Whether to allow the administrator permission to override\n   * @returns {boolean}\n   */\n\n\n  any(permission, checkAdmin = true) {\n    return checkAdmin && super.has(this.constructor.FLAGS.ADMINISTRATOR) || super.any(permission);\n  }\n  /**\n   * Checks whether the bitfield has a permission, or multiple permissions.\n   * @param {PermissionResolvable} permission Permission(s) to check for\n   * @param {boolean} [checkAdmin=true] Whether to allow the administrator permission to override\n   * @returns {boolean}\n   */\n\n\n  has(permission, checkAdmin = true) {\n    return checkAdmin && super.has(this.constructor.FLAGS.ADMINISTRATOR) || super.has(permission);\n  }\n\n}\n/**\n * Numeric permission flags. All available properties:\n * * `ADMINISTRATOR` (implicitly has *all* permissions, and bypasses all channel overwrites)\n * * `CREATE_INSTANT_INVITE` (create invitations to the guild)\n * * `KICK_MEMBERS`\n * * `BAN_MEMBERS`\n * * `MANAGE_CHANNELS` (edit and reorder channels)\n * * `MANAGE_GUILD` (edit the guild information, region, etc.)\n * * `ADD_REACTIONS` (add new reactions to messages)\n * * `VIEW_AUDIT_LOG`\n * * `PRIORITY_SPEAKER`\n * * `STREAM`\n * * `VIEW_CHANNEL`\n * * `SEND_MESSAGES`\n * * `SEND_TTS_MESSAGES`\n * * `MANAGE_MESSAGES` (delete messages and reactions)\n * * `EMBED_LINKS` (links posted will have a preview embedded)\n * * `ATTACH_FILES`\n * * `READ_MESSAGE_HISTORY` (view messages that were posted prior to opening Discord)\n * * `MENTION_EVERYONE`\n * * `USE_EXTERNAL_EMOJIS` (use emojis from different guilds)\n * * `VIEW_GUILD_INSIGHTS`\n * * `CONNECT` (connect to a voice channel)\n * * `SPEAK` (speak in a voice channel)\n * * `MUTE_MEMBERS` (mute members across all voice channels)\n * * `DEAFEN_MEMBERS` (deafen members across all voice channels)\n * * `MOVE_MEMBERS` (move members between voice channels)\n * * `USE_VAD` (use voice activity detection)\n * * `CHANGE_NICKNAME`\n * * `MANAGE_NICKNAMES` (change other members\' nicknames)\n * * `MANAGE_ROLES`\n * * `MANAGE_WEBHOOKS`\n * * `MANAGE_EMOJIS`\n * * `USE_APPLICATION_COMMANDS`\n * * `REQUEST_TO_SPEAK`\n * * `MANAGE_THREADS`\n * * `USE_PUBLIC_THREADS`\n * * `USE_PRIVATE_THREADS`\n * @type {Object<string, bigint>}\n * @see {@link https://discord.com/developers/docs/topics/permissions}\n */\n\n\nPermissions.FLAGS = {\n  CREATE_INSTANT_INVITE: 1n << 0n,\n  KICK_MEMBERS: 1n << 1n,\n  BAN_MEMBERS: 1n << 2n,\n  ADMINISTRATOR: 1n << 3n,\n  MANAGE_CHANNELS: 1n << 4n,\n  MANAGE_GUILD: 1n << 5n,\n  ADD_REACTIONS: 1n << 6n,\n  VIEW_AUDIT_LOG: 1n << 7n,\n  PRIORITY_SPEAKER: 1n << 8n,\n  STREAM: 1n << 9n,\n  VIEW_CHANNEL: 1n << 10n,\n  SEND_MESSAGES: 1n << 11n,\n  SEND_TTS_MESSAGES: 1n << 12n,\n  MANAGE_MESSAGES: 1n << 13n,\n  EMBED_LINKS: 1n << 14n,\n  ATTACH_FILES: 1n << 15n,\n  READ_MESSAGE_HISTORY: 1n << 16n,\n  MENTION_EVERYONE: 1n << 17n,\n  USE_EXTERNAL_EMOJIS: 1n << 18n,\n  VIEW_GUILD_INSIGHTS: 1n << 19n,\n  CONNECT: 1n << 20n,\n  SPEAK: 1n << 21n,\n  MUTE_MEMBERS: 1n << 22n,\n  DEAFEN_MEMBERS: 1n << 23n,\n  MOVE_MEMBERS: 1n << 24n,\n  USE_VAD: 1n << 25n,\n  CHANGE_NICKNAME: 1n << 26n,\n  MANAGE_NICKNAMES: 1n << 27n,\n  MANAGE_ROLES: 1n << 28n,\n  MANAGE_WEBHOOKS: 1n << 29n,\n  MANAGE_EMOJIS: 1n << 30n,\n  USE_APPLICATION_COMMANDS: 1n << 31n,\n  REQUEST_TO_SPEAK: 1n << 32n,\n  MANAGE_THREADS: 1n << 34n,\n  USE_PUBLIC_THREADS: 1n << 35n,\n  USE_PRIVATE_THREADS: 1n << 36n\n};\n/**\n * Bitfield representing every permission combined\n * @type {bigint}\n */\n\nPermissions.ALL = Object.values(Permissions.FLAGS).reduce((all, p) => all | p, 0n);\n/**\n * Bitfield representing the default permissions for users\n * @type {bigint}\n */\n\nPermissions.DEFAULT = BigInt(104324673);\n/**\n * Bitfield representing the permissions required for moderators of stage channels\n * @type {bigint}\n */\n\nPermissions.STAGE_MODERATOR = Permissions.FLAGS.MANAGE_CHANNELS | Permissions.FLAGS.MUTE_MEMBERS | Permissions.FLAGS.MOVE_MEMBERS;\nPermissions.defaultBit = BigInt(0);\nmodule.exports = Permissions;\n\n//# sourceURL=webpack://Fosscord/./src/util/Permissions.js?')},"./src/util/SnowflakeUtil.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nconst Util = __webpack_require__(/*! ./Util */ \"./src/util/Util.js\"); // Discord epoch (2015-01-01T00:00:00.000Z)\n\n\nconst EPOCH = 1420070400000;\nlet INCREMENT = 0;\n/**\n * A container for useful snowflake-related methods.\n */\n\nclass SnowflakeUtil {\n  constructor() {\n    throw new Error(`The ${this.constructor.name} class may not be instantiated.`);\n  }\n  /**\n   * A Twitter snowflake, except the epoch is 2015-01-01T00:00:00.000Z\n   * ```\n   * If we have a snowflake '266241948824764416' we can represent it as binary:\n   *\n   * 64                                          22     17     12          0\n   *  000000111011000111100001101001000101000000  00001  00000  000000000000\n   *       number of ms since Discord epoch       worker  pid    increment\n   * ```\n   * @typedef {string} Snowflake\n   */\n\n  /**\n   * Generates a Discord snowflake.\n   * <info>This hardcodes the worker ID as 1 and the process ID as 0.</info>\n   * @param {number|Date} [timestamp=Date.now()] Timestamp or date of the snowflake to generate\n   * @returns {Snowflake} The generated snowflake\n   */\n\n\n  static generate(timestamp = Date.now()) {\n    if (timestamp instanceof Date) timestamp = timestamp.getTime();\n\n    if (typeof timestamp !== 'number' || isNaN(timestamp)) {\n      throw new TypeError(`\"timestamp\" argument must be a number (received ${isNaN(timestamp) ? 'NaN' : typeof timestamp})`);\n    }\n\n    if (INCREMENT >= 4095) INCREMENT = 0;\n    const BINARY = `${(timestamp - EPOCH).toString(2).padStart(42, '0')}0000100000${(INCREMENT++).toString(2).padStart(12, '0')}`;\n    return Util.binaryToID(BINARY);\n  }\n  /**\n   * A deconstructed snowflake.\n   * @typedef {Object} DeconstructedSnowflake\n   * @property {number} timestamp Timestamp the snowflake was created\n   * @property {Date} date Date the snowflake was created\n   * @property {number} workerID Worker ID in the snowflake\n   * @property {number} processID Process ID in the snowflake\n   * @property {number} increment Increment in the snowflake\n   * @property {string} binary Binary representation of the snowflake\n   */\n\n  /**\n   * Deconstructs a Discord snowflake.\n   * @param {Snowflake} snowflake Snowflake to deconstruct\n   * @returns {DeconstructedSnowflake} Deconstructed snowflake\n   */\n\n\n  static deconstruct(snowflake) {\n    const BINARY = Util.idToBinary(snowflake).toString(2).padStart(64, '0');\n    return {\n      timestamp: parseInt(BINARY.substring(0, 42), 2) + EPOCH,\n\n      get date() {\n        return new Date(this.timestamp);\n      },\n\n      workerID: parseInt(BINARY.substring(42, 47), 2),\n      processID: parseInt(BINARY.substring(47, 52), 2),\n      increment: parseInt(BINARY.substring(52, 64), 2),\n      binary: BINARY\n    };\n  }\n  /**\n   * Discord's epoch value (2015-01-01T00:00:00.000Z).\n   * @type {number}\n   * @readonly\n   */\n\n\n  static get EPOCH() {\n    return EPOCH;\n  }\n\n}\n\nmodule.exports = SnowflakeUtil;\n\n//# sourceURL=webpack://Fosscord/./src/util/SnowflakeUtil.js?")},"./src/util/Structures.js":function(module,exports,__webpack_require__){"use strict";eval('\n/**\n * An extendable structure:\n * * **`GuildEmoji`**\n * * **`DMChannel`**\n * * **`TextChannel`**\n * * **`VoiceChannel`**\n * * **`CategoryChannel`**\n * * **`NewsChannel`**\n * * **`StoreChannel`**\n * * **`StageChannel`**\n * * **`ThreadChannel`**\n * * **`GuildMember`**\n * * **`ThreadMember`**\n * * **`Guild`**\n * * **`Message`**\n * * **`MessageReaction`**\n * * **`Presence`**\n * * **`ClientPresence`**\n * * **`VoiceState`**\n * * **`Role`**\n * * **`User`**\n * * **`CommandInteraction`**\n * * **`ButtonInteraction`**\n * * **`StageInstance`**\n * * **`SelectMenuInteraction`**\n * @typedef {string} ExtendableStructure\n */\n\n/**\n * Allows for the extension of built-in Discord.js structures that are instantiated by {@link BaseManager Managers}.\n */\n\nclass Structures {\n  constructor() {\n    throw new Error(`The ${this.constructor.name} class may not be instantiated.`);\n  }\n  /**\n   * Retrieves a structure class.\n   * @param {string} structure Name of the structure to retrieve\n   * @returns {Function}\n   */\n\n\n  static get(structure) {\n    if (typeof structure === \'string\') return structures[structure];\n    throw new TypeError(`"structure" argument must be a string (received ${typeof structure})`);\n  }\n  /**\n   * Extends a structure.\n   * <warn> Make sure to extend all structures before instantiating your client.\n   * Extending after doing so may not work as expected. </warn>\n   * @param {ExtendableStructure} structure Name of the structure class to extend\n   * @param {Function} extender Function that takes the base class to extend as its only parameter and returns the\n   * extended class/prototype\n   * @returns {Function} Extended class/prototype returned from the extender\n   * @example\n   * const { Structures } = require(\'discord.js\');\n   *\n   * Structures.extend(\'Guild\', Guild => {\n   *   class CoolGuild extends Guild {\n   *     constructor(client, data) {\n   *       super(client, data);\n   *       this.cool = true;\n   *     }\n   *   }\n   *\n   *   return CoolGuild;\n   * });\n   */\n\n\n  static extend(structure, extender) {\n    if (!structures[structure]) throw new RangeError(`"${structure}" is not a valid extensible structure.`);\n\n    if (typeof extender !== \'function\') {\n      const received = `(received ${typeof extender})`;\n      throw new TypeError(`"extender" argument must be a function that returns the extended structure class/prototype ${received}.`);\n    }\n\n    const extended = extender(structures[structure]);\n\n    if (typeof extended !== \'function\') {\n      const received = `(received ${typeof extended})`;\n      throw new TypeError(`The extender function must return the extended structure class/prototype ${received}.`);\n    }\n\n    if (!(extended.prototype instanceof structures[structure])) {\n      const prototype = Object.getPrototypeOf(extended);\n      const received = `${extended.name || \'unnamed\'}${prototype.name ? ` extends ${prototype.name}` : \'\'}`;\n      throw new Error(\'The class/prototype returned from the extender function must extend the existing structure class/prototype\' + ` (received function ${received}; expected extension of ${structures[structure].name}).`);\n    }\n\n    structures[structure] = extended;\n    return extended;\n  }\n\n}\n\nconst structures = {\n  GuildEmoji: __webpack_require__(/*! ../structures/GuildEmoji */ "./src/structures/GuildEmoji.js"),\n  DMChannel: __webpack_require__(/*! ../structures/DMChannel */ "./src/structures/DMChannel.js"),\n  TextChannel: __webpack_require__(/*! ../structures/TextChannel */ "./src/structures/TextChannel.js"),\n  VoiceChannel: __webpack_require__(/*! ../structures/VoiceChannel */ "./src/structures/VoiceChannel.js"),\n  CategoryChannel: __webpack_require__(/*! ../structures/CategoryChannel */ "./src/structures/CategoryChannel.js"),\n  NewsChannel: __webpack_require__(/*! ../structures/NewsChannel */ "./src/structures/NewsChannel.js"),\n  StoreChannel: __webpack_require__(/*! ../structures/StoreChannel */ "./src/structures/StoreChannel.js"),\n  StageChannel: __webpack_require__(/*! ../structures/StageChannel */ "./src/structures/StageChannel.js"),\n  ThreadChannel: __webpack_require__(/*! ../structures/ThreadChannel */ "./src/structures/ThreadChannel.js"),\n  GuildMember: __webpack_require__(/*! ../structures/GuildMember */ "./src/structures/GuildMember.js"),\n  ThreadMember: __webpack_require__(/*! ../structures/ThreadMember */ "./src/structures/ThreadMember.js"),\n  Guild: __webpack_require__(/*! ../structures/Guild */ "./src/structures/Guild.js"),\n  Message: __webpack_require__(/*! ../structures/Message */ "./src/structures/Message.js"),\n  MessageReaction: __webpack_require__(/*! ../structures/MessageReaction */ "./src/structures/MessageReaction.js"),\n  Presence: __webpack_require__(/*! ../structures/Presence */ "./src/structures/Presence.js").Presence,\n  ClientPresence: __webpack_require__(/*! ../structures/ClientPresence */ "./src/structures/ClientPresence.js"),\n  VoiceState: __webpack_require__(/*! ../structures/VoiceState */ "./src/structures/VoiceState.js"),\n  Role: __webpack_require__(/*! ../structures/Role */ "./src/structures/Role.js"),\n  User: __webpack_require__(/*! ../structures/User */ "./src/structures/User.js"),\n  CommandInteraction: __webpack_require__(/*! ../structures/CommandInteraction */ "./src/structures/CommandInteraction.js"),\n  ButtonInteraction: __webpack_require__(/*! ../structures/ButtonInteraction */ "./src/structures/ButtonInteraction.js"),\n  SelectMenuInteraction: __webpack_require__(/*! ../structures/SelectMenuInteraction */ "./src/structures/SelectMenuInteraction.js"),\n  StageInstance: __webpack_require__(/*! ../structures/StageInstance */ "./src/structures/StageInstance.js")\n};\nmodule.exports = Structures;\n\n//# sourceURL=webpack://Fosscord/./src/util/Structures.js?')},"./src/util/SystemChannelFlags.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nconst BitField = __webpack_require__(/*! ./BitField */ "./src/util/BitField.js");\n/**\n * Data structure that makes it easy to interact with a {@link Guild#systemChannelFlags} bitfield.\n * <info>Note that all event message types are enabled by default,\n * and by setting their corresponding flags you are disabling them</info>\n * @extends {BitField}\n */\n\n\nclass SystemChannelFlags extends BitField {}\n/**\n * @name SystemChannelFlags\n * @kind constructor\n * @memberof SystemChannelFlags\n * @param {SystemChannelFlagsResolvable} [bits=0] Bit(s) to read from\n */\n\n/**\n * Bitfield of the packed bits\n * @type {number}\n * @name SystemChannelFlags#bitfield\n */\n\n/**\n * Data that can be resolved to give a sytem channel flag bitfield. This can be:\n * * A string (see {@link SystemChannelFlags.FLAGS})\n * * A sytem channel flag\n * * An instance of SystemChannelFlags\n * * An Array of SystemChannelFlagsResolvable\n * @typedef {string|number|SystemChannelFlags|SystemChannelFlagsResolvable[]} SystemChannelFlagsResolvable\n */\n\n/**\n * Numeric system channel flags. All available properties:\n * * `SUPPRESS_JOIN_NOTIFICATIONS` (Suppress member join notifications)\n * * `SUPPRESS_PREMIUM_SUBSCRIPTIONS` (Suppress server boost notifications)\n * * `SUPPRESS_GUILD_REMINDER_NOTIFICATIONS` (Suppress server setup tips)\n * @type {Object}\n */\n\n\nSystemChannelFlags.FLAGS = {\n  SUPPRESS_JOIN_NOTIFICATIONS: 1 << 0,\n  SUPPRESS_PREMIUM_SUBSCRIPTIONS: 1 << 1,\n  SUPPRESS_GUILD_REMINDER_NOTIFICATIONS: 1 << 2\n};\nmodule.exports = SystemChannelFlags;\n\n//# sourceURL=webpack://Fosscord/./src/util/SystemChannelFlags.js?')},"./src/util/ThreadMemberFlags.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nconst BitField = __webpack_require__(/*! ./BitField */ "./src/util/BitField.js");\n/**\n * Data structure that makes it easy to interact with a {@link ThreadMember#flags} bitfield.\n * @extends {BitField}\n */\n\n\nclass ThreadMemberFlags extends BitField {}\n/**\n * @name ThreadMemberFlags\n * @kind constructor\n * @memberof ThreadMemberFlags\n * @param {BitFieldResolvable} [bits=0] Bit(s) to read from\n */\n\n/**\n * Bitfield of the packed bits\n * @type {number}\n * @name ThreadMemberFlags#bitfield\n */\n\n/**\n * Numeric thread member flags. There are currently no bitflags relevant to bots for this.\n * @type {Object<string, number>}\n */\n\n\nThreadMemberFlags.FLAGS = {};\nmodule.exports = ThreadMemberFlags;\n\n//# sourceURL=webpack://Fosscord/./src/util/ThreadMemberFlags.js?')},"./src/util/UserFlags.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nconst BitField = __webpack_require__(/*! ./BitField */ "./src/util/BitField.js");\n/**\n * Data structure that makes it easy to interact with a {@link User#flags} bitfield.\n * @extends {BitField}\n */\n\n\nclass UserFlags extends BitField {}\n/**\n * @name UserFlags\n * @kind constructor\n * @memberof UserFlags\n * @param {BitFieldResolvable} [bits=0] Bit(s) to read from\n */\n\n/**\n * Bitfield of the packed bits\n * @type {number}\n * @name UserFlags#bitfield\n */\n\n/**\n * Numeric user flags. All available properties:\n * * `DISCORD_EMPLOYEE`\n * * `PARTNERED_SERVER_OWNER`\n * * `HYPESQUAD_EVENTS`\n * * `BUGHUNTER_LEVEL_1`\n * * `HOUSE_BRAVERY`\n * * `HOUSE_BRILLIANCE`\n * * `HOUSE_BALANCE`\n * * `EARLY_SUPPORTER`\n * * `TEAM_USER`\n * * `BUGHUNTER_LEVEL_2`\n * * `VERIFIED_BOT`\n * * `EARLY_VERIFIED_BOT_DEVELOPER`\n * * `DISCORD_CERTIFIED_MODERATOR`\n * @type {Object}\n * @see {@link https://discord.com/developers/docs/resources/user#user-object-user-flags}\n */\n\n\nUserFlags.FLAGS = {\n  DISCORD_EMPLOYEE: 1 << 0,\n  PARTNERED_SERVER_OWNER: 1 << 1,\n  HYPESQUAD_EVENTS: 1 << 2,\n  BUGHUNTER_LEVEL_1: 1 << 3,\n  HOUSE_BRAVERY: 1 << 6,\n  HOUSE_BRILLIANCE: 1 << 7,\n  HOUSE_BALANCE: 1 << 8,\n  EARLY_SUPPORTER: 1 << 9,\n  TEAM_USER: 1 << 10,\n  BUGHUNTER_LEVEL_2: 1 << 14,\n  VERIFIED_BOT: 1 << 16,\n  EARLY_VERIFIED_BOT_DEVELOPER: 1 << 17,\n  DISCORD_CERTIFIED_MODERATOR: 1 << 18\n};\nmodule.exports = UserFlags;\n\n//# sourceURL=webpack://Fosscord/./src/util/UserFlags.js?')},"./src/util/Util.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nconst {\n  parse\n} = __webpack_require__(/*! path */ \"./node_modules/node-libs-browser/mock/empty.js\");\n\nconst fetch = __webpack_require__(/*! node-fetch */ \"./node_modules/node-fetch/browser.js\");\n\nconst {\n  Colors,\n  DefaultOptions,\n  Endpoints\n} = __webpack_require__(/*! ./Constants */ \"./src/util/Constants.js\");\n\nconst {\n  Error: DiscordError,\n  RangeError,\n  TypeError\n} = __webpack_require__(/*! ../errors */ \"./src/errors/index.js\");\n\nconst has = (o, k) => Object.prototype.hasOwnProperty.call(o, k);\n\nconst isObject = d => typeof d === 'object' && d !== null;\n/**\n * Contains various general-purpose utility methods. These functions are also available on the base `Discord` object.\n */\n\n\nclass Util {\n  constructor() {\n    throw new Error(`The ${this.constructor.name} class may not be instantiated.`);\n  }\n  /**\n   * Flatten an object. Any properties that are collections will get converted to an array of keys.\n   * @param {Object} obj The object to flatten.\n   * @param {...Object<string, boolean|string>} [props] Specific properties to include/exclude.\n   * @returns {Object}\n   */\n\n\n  static flatten(obj, ...props) {\n    if (!isObject(obj)) return obj;\n    const objProps = Object.keys(obj).filter(k => !k.startsWith('_')).map(k => ({\n      [k]: true\n    }));\n    props = objProps.length ? Object.assign(...objProps, ...props) : Object.assign({}, ...props);\n    const out = {};\n\n    for (let [prop, newProp] of Object.entries(props)) {\n      if (!newProp) continue;\n      newProp = newProp === true ? prop : newProp;\n      const element = obj[prop];\n      const elemIsObj = isObject(element);\n      const valueOf = elemIsObj && typeof element.valueOf === 'function' ? element.valueOf() : null; // If it's a Collection, make the array of keys\n\n      if (element instanceof __webpack_require__(/*! ./Collection */ \"./src/util/Collection.js\")) out[newProp] = Array.from(element.keys()); // If the valueOf is a Collection, use its array of keys\n      else if (valueOf instanceof __webpack_require__(/*! ./Collection */ \"./src/util/Collection.js\")) out[newProp] = Array.from(valueOf.keys()); // If it's an array, flatten each element\n        else if (Array.isArray(element)) out[newProp] = element.map(e => Util.flatten(e)); // If it's an object with a primitive `valueOf`, use that value\n          else if (typeof valueOf !== 'object') out[newProp] = valueOf; // If it's a primitive\n            else if (!elemIsObj) out[newProp] = element;\n    }\n\n    return out;\n  }\n  /**\n   * Splits a string into multiple chunks at a designated character that do not exceed a specific length.\n   * @param {string} text Content to split\n   * @param {SplitOptions} [options] Options controlling the behavior of the split\n   * @returns {string[]}\n   */\n\n\n  static splitMessage(text, {\n    maxLength = 2000,\n    char = '\\n',\n    prepend = '',\n    append = ''\n  } = {}) {\n    text = Util.verifyString(text, RangeError, 'MESSAGE_CONTENT_TYPE', false);\n    if (text.length <= maxLength) return [text];\n    let splitText = [text];\n\n    if (Array.isArray(char)) {\n      while (char.length > 0 && splitText.some(elem => elem.length > maxLength)) {\n        const currentChar = char.shift();\n\n        if (currentChar instanceof RegExp) {\n          splitText = splitText.map(chunk => chunk.match(currentChar));\n        } else {\n          splitText = splitText.map(chunk => chunk.split(currentChar));\n        }\n      }\n    } else {\n      splitText = text.split(char);\n    }\n\n    if (splitText.some(elem => elem.length > maxLength)) throw new RangeError('SPLIT_MAX_LEN');\n    const messages = [];\n    let msg = '';\n\n    for (const chunk of splitText) {\n      if (msg && (msg + char + chunk + append).length > maxLength) {\n        messages.push(msg + append);\n        msg = prepend;\n      }\n\n      msg += (msg && msg !== prepend ? char : '') + chunk;\n    }\n\n    return messages.concat(msg).filter(m => m);\n  }\n  /**\n   * Options used to escape markdown.\n   * @typedef {Object} EscapeMarkdownOptions\n   * @property {boolean} [codeBlock=true] Whether to escape code blocks or not\n   * @property {boolean} [inlineCode=true] Whether to escape inline code or not\n   * @property {boolean} [bold=true] Whether to escape bolds or not\n   * @property {boolean} [italic=true] Whether to escape italics or not\n   * @property {boolean} [underline=true] Whether to escape underlines or not\n   * @property {boolean} [strikethrough=true] Whether to escape strikethroughs or not\n   * @property {boolean} [spoiler=true] Whether to escape spoilers or not\n   * @property {boolean} [codeBlockContent=true] Whether to escape text inside code blocks or not\n   * @property {boolean} [inlineCodeContent=true] Whether to escape text inside inline code or not\n   */\n\n  /**\n   * Escapes any Discord-flavour markdown in a string.\n   * @param {string} text Content to escape\n   * @param {EscapeMarkdownOptions} [options={}] Options for escaping the markdown\n   * @returns {string}\n   */\n\n\n  static escapeMarkdown(text, {\n    codeBlock = true,\n    inlineCode = true,\n    bold = true,\n    italic = true,\n    underline = true,\n    strikethrough = true,\n    spoiler = true,\n    codeBlockContent = true,\n    inlineCodeContent = true\n  } = {}) {\n    if (!codeBlockContent) {\n      return text.split('```').map((subString, index, array) => {\n        if (index % 2 && index !== array.length - 1) return subString;\n        return Util.escapeMarkdown(subString, {\n          inlineCode,\n          bold,\n          italic,\n          underline,\n          strikethrough,\n          spoiler,\n          inlineCodeContent\n        });\n      }).join(codeBlock ? '\\\\`\\\\`\\\\`' : '```');\n    }\n\n    if (!inlineCodeContent) {\n      return text.split(/(?<=^|[^`])`(?=[^`]|$)/g).map((subString, index, array) => {\n        if (index % 2 && index !== array.length - 1) return subString;\n        return Util.escapeMarkdown(subString, {\n          codeBlock,\n          bold,\n          italic,\n          underline,\n          strikethrough,\n          spoiler\n        });\n      }).join(inlineCode ? '\\\\`' : '`');\n    }\n\n    if (inlineCode) text = Util.escapeInlineCode(text);\n    if (codeBlock) text = Util.escapeCodeBlock(text);\n    if (italic) text = Util.escapeItalic(text);\n    if (bold) text = Util.escapeBold(text);\n    if (underline) text = Util.escapeUnderline(text);\n    if (strikethrough) text = Util.escapeStrikethrough(text);\n    if (spoiler) text = Util.escapeSpoiler(text);\n    return text;\n  }\n  /**\n   * Escapes code block markdown in a string.\n   * @param {string} text Content to escape\n   * @returns {string}\n   */\n\n\n  static escapeCodeBlock(text) {\n    return text.replace(/```/g, '\\\\`\\\\`\\\\`');\n  }\n  /**\n   * Escapes inline code markdown in a string.\n   * @param {string} text Content to escape\n   * @returns {string}\n   */\n\n\n  static escapeInlineCode(text) {\n    return text.replace(/(?<=^|[^`])`(?=[^`]|$)/g, '\\\\`');\n  }\n  /**\n   * Escapes italic markdown in a string.\n   * @param {string} text Content to escape\n   * @returns {string}\n   */\n\n\n  static escapeItalic(text) {\n    let i = 0;\n    text = text.replace(/(?<=^|[^*])\\*([^*]|\\*\\*|$)/g, (_, match) => {\n      if (match === '**') return ++i % 2 ? `\\\\*${match}` : `${match}\\\\*`;\n      return `\\\\*${match}`;\n    });\n    i = 0;\n    return text.replace(/(?<=^|[^_])_([^_]|__|$)/g, (_, match) => {\n      if (match === '__') return ++i % 2 ? `\\\\_${match}` : `${match}\\\\_`;\n      return `\\\\_${match}`;\n    });\n  }\n  /**\n   * Escapes bold markdown in a string.\n   * @param {string} text Content to escape\n   * @returns {string}\n   */\n\n\n  static escapeBold(text) {\n    let i = 0;\n    return text.replace(/\\*\\*(\\*)?/g, (_, match) => {\n      if (match) return ++i % 2 ? `${match}\\\\*\\\\*` : `\\\\*\\\\*${match}`;\n      return '\\\\*\\\\*';\n    });\n  }\n  /**\n   * Escapes underline markdown in a string.\n   * @param {string} text Content to escape\n   * @returns {string}\n   */\n\n\n  static escapeUnderline(text) {\n    let i = 0;\n    return text.replace(/__(_)?/g, (_, match) => {\n      if (match) return ++i % 2 ? `${match}\\\\_\\\\_` : `\\\\_\\\\_${match}`;\n      return '\\\\_\\\\_';\n    });\n  }\n  /**\n   * Escapes strikethrough markdown in a string.\n   * @param {string} text Content to escape\n   * @returns {string}\n   */\n\n\n  static escapeStrikethrough(text) {\n    return text.replace(/~~/g, '\\\\~\\\\~');\n  }\n  /**\n   * Escapes spoiler markdown in a string.\n   * @param {string} text Content to escape\n   * @returns {string}\n   */\n\n\n  static escapeSpoiler(text) {\n    return text.replace(/\\|\\|/g, '\\\\|\\\\|');\n  }\n  /**\n   * Gets the recommended shard count from Discord.\n   * @param {string} token Discord auth token\n   * @param {number} [guildsPerShard=1000] Number of guilds per shard\n   * @returns {Promise<number>} The recommended number of shards\n   */\n\n\n  static fetchRecommendedShards(token, guildsPerShard = 1000) {\n    if (!token) throw new DiscordError('TOKEN_MISSING');\n    return fetch(`${DefaultOptions.http.api}/v${DefaultOptions.http.version}${Endpoints.botGateway}`, {\n      method: 'GET',\n      headers: {\n        Authorization: `Bot ${token.replace(/^Bot\\s*/i, '')}`\n      }\n    }).then(res => {\n      if (res.ok) return res.json();\n      if (res.status === 401) throw new DiscordError('TOKEN_INVALID');\n      throw res;\n    }).then(data => data.shards * (1000 / guildsPerShard));\n  }\n  /**\n   * Parses emoji info out of a string. The string must be one of:\n   * * A UTF-8 emoji (no ID)\n   * * A URL-encoded UTF-8 emoji (no ID)\n   * * A Discord custom emoji (`<:name:id>` or `<a:name:id>`)\n   * @param {string} text Emoji string to parse\n   * @returns {APIEmoji} Object with `animated`, `name`, and `id` properties\n   * @private\n   */\n\n\n  static parseEmoji(text) {\n    if (text.includes('%')) text = decodeURIComponent(text);\n    if (!text.includes(':')) return {\n      animated: false,\n      name: text,\n      id: null\n    };\n    const m = text.match(/<?(?:(a):)?(\\w{2,32}):(\\d{17,19})?>?/);\n    if (!m) return null;\n    return {\n      animated: Boolean(m[1]),\n      name: m[2],\n      id: m[3] || null\n    };\n  }\n  /**\n   * Resolves a partial emoji object from an {@link EmojiIdentifierResolvable}, without checking a Client.\n   * @param {EmojiIdentifierResolvable} emoji Emoji identifier to resolve\n   * @returns {?RawEmoji}\n   * @private\n   */\n\n\n  static resolvePartialEmoji(emoji) {\n    if (!emoji) return null;\n    if (typeof emoji === 'string') return /^\\d{17,19}$/.test(emoji) ? {\n      id: emoji\n    } : Util.parseEmoji(emoji);\n    const {\n      id,\n      name,\n      animated\n    } = emoji;\n    if (!id && !name) return null;\n    return {\n      id,\n      name,\n      animated\n    };\n  }\n  /**\n   * Shallow-copies an object with its class/prototype intact.\n   * @param {Object} obj Object to clone\n   * @returns {Object}\n   * @private\n   */\n\n\n  static cloneObject(obj) {\n    return Object.assign(Object.create(obj), obj);\n  }\n  /**\n   * Sets default properties on an object that aren't already specified.\n   * @param {Object} def Default properties\n   * @param {Object} given Object to assign defaults to\n   * @returns {Object}\n   * @private\n   */\n\n\n  static mergeDefault(def, given) {\n    if (!given) return def;\n\n    for (const key in def) {\n      if (!has(given, key) || given[key] === undefined) {\n        given[key] = def[key];\n      } else if (given[key] === Object(given[key])) {\n        given[key] = Util.mergeDefault(def[key], given[key]);\n      }\n    }\n\n    return given;\n  }\n  /**\n   * Options used to make an error object.\n   * @typedef {Object} MakeErrorOptions\n   * @property {string} name Error type\n   * @property {string} message Message for the error\n   * @property {string} stack Stack for the error\n   */\n\n  /**\n   * Makes an Error from a plain info object.\n   * @param {MakeErrorOptions} obj Error info\n   * @returns {Error}\n   * @private\n   */\n\n\n  static makeError(obj) {\n    const err = new Error(obj.message);\n    err.name = obj.name;\n    err.stack = obj.stack;\n    return err;\n  }\n  /**\n   * Makes a plain error info object from an Error.\n   * @param {Error} err Error to get info from\n   * @returns {MakeErrorOptions}\n   * @private\n   */\n\n\n  static makePlainError(err) {\n    return {\n      name: err.name,\n      message: err.message,\n      stack: err.stack\n    };\n  }\n  /**\n   * Moves an element in an array *in place*.\n   * @param {Array<*>} array Array to modify\n   * @param {*} element Element to move\n   * @param {number} newIndex Index or offset to move the element to\n   * @param {boolean} [offset=false] Move the element by an offset amount rather than to a set index\n   * @returns {number}\n   * @private\n   */\n\n\n  static moveElementInArray(array, element, newIndex, offset = false) {\n    const index = array.indexOf(element);\n    newIndex = (offset ? index : 0) + newIndex;\n\n    if (newIndex > -1 && newIndex < array.length) {\n      const removedElement = array.splice(index, 1)[0];\n      array.splice(newIndex, 0, removedElement);\n    }\n\n    return array.indexOf(element);\n  }\n  /**\n   * Verifies the provided data is a string, otherwise throws provided error.\n   * @param {string} data The string resolvable to resolve\n   * @param {Function} [error] The Error constructor to instantiate. Defaults to Error\n   * @param {string} [errorMessage] The error message to throw with. Defaults to \"Expected string, got <data> instead.\"\n   * @param {boolean} [allowEmpty=true] Whether an empty string should be allowed\n   * @returns {string}\n   */\n\n\n  static verifyString(data, error = Error, errorMessage = `Expected a string, got ${data} instead.`, allowEmpty = true) {\n    if (typeof data !== 'string') throw new error(errorMessage);\n    if (!allowEmpty && data.length === 0) throw new error(errorMessage);\n    return data;\n  }\n  /**\n   * Can be a number, hex string, an RGB array like:\n   * ```js\n   * [255, 0, 255] // purple\n   * ```\n   * or one of the following strings:\n   * - `DEFAULT`\n   * - `WHITE`\n   * - `AQUA`\n   * - `GREEN`\n   * - `BLUE`\n   * - `YELLOW`\n   * - `PURPLE`\n   * - `LUMINOUS_VIVID_PINK`\n   * - `FUCHSIA`\n   * - `GOLD`\n   * - `ORANGE`\n   * - `RED`\n   * - `GREY`\n   * - `NAVY`\n   * - `DARK_AQUA`\n   * - `DARK_GREEN`\n   * - `DARK_BLUE`\n   * - `DARK_PURPLE`\n   * - `DARK_VIVID_PINK`\n   * - `DARK_GOLD`\n   * - `DARK_ORANGE`\n   * - `DARK_RED`\n   * - `DARK_GREY`\n   * - `DARKER_GREY`\n   * - `LIGHT_GREY`\n   * - `DARK_NAVY`\n   * - `BLURPLE`\n   * - `GREYPLE`\n   * - `DARK_BUT_NOT_BLACK`\n   * - `NOT_QUITE_BLACK`\n   * - `RANDOM`\n   * @typedef {string|number|number[]} ColorResolvable\n   */\n\n  /**\n   * Resolves a ColorResolvable into a color number.\n   * @param {ColorResolvable} color Color to resolve\n   * @returns {number} A color\n   */\n\n\n  static resolveColor(color) {\n    if (typeof color === 'string') {\n      if (color === 'RANDOM') return Math.floor(Math.random() * (0xffffff + 1));\n      if (color === 'DEFAULT') return 0;\n      color = Colors[color] || parseInt(color.replace('#', ''), 16);\n    } else if (Array.isArray(color)) {\n      color = (color[0] << 16) + (color[1] << 8) + color[2];\n    }\n\n    if (color < 0 || color > 0xffffff) throw new RangeError('COLOR_RANGE');else if (color && isNaN(color)) throw new TypeError('COLOR_CONVERT');\n    return color;\n  }\n  /**\n   * Sorts by Discord's position and ID.\n   * @param  {Collection} collection Collection of objects to sort\n   * @returns {Collection}\n   */\n\n\n  static discordSort(collection) {\n    return collection.sorted((a, b) => a.rawPosition - b.rawPosition || parseInt(b.id.slice(0, -10)) - parseInt(a.id.slice(0, -10)) || parseInt(b.id.slice(10)) - parseInt(a.id.slice(10)));\n  }\n  /**\n   * Sets the position of a Channel or Role.\n   * @param {Channel|Role} item Object to set the position of\n   * @param {number} position New position for the object\n   * @param {boolean} relative Whether `position` is relative to its current position\n   * @param {Collection<string, Channel|Role>} sorted A collection of the objects sorted properly\n   * @param {APIRouter} route Route to call PATCH on\n   * @param {string} [reason] Reason for the change\n   * @returns {Promise<Channel[]|Role[]>} Updated item list, with `id` and `position` properties\n   * @private\n   */\n\n\n  static setPosition(item, position, relative, sorted, route, reason) {\n    let updatedItems = sorted.array();\n    Util.moveElementInArray(updatedItems, item, position, relative);\n    updatedItems = updatedItems.map((r, i) => ({\n      id: r.id,\n      position: i\n    }));\n    return route.patch({\n      data: updatedItems,\n      reason\n    }).then(() => updatedItems);\n  }\n  /**\n   * Alternative to Node's `path.basename`, removing query string after the extension if it exists.\n   * @param {string} path Path to get the basename of\n   * @param {string} [ext] File extension to remove\n   * @returns {string} Basename of the path\n   * @private\n   */\n\n\n  static basename(path, ext) {\n    let res = parse(path);\n    return ext && res.ext.startsWith(ext) ? res.name : res.base.split('?')[0];\n  }\n  /**\n   * Transforms a snowflake from a decimal string to a bit string.\n   * @param  {Snowflake} num Snowflake to be transformed\n   * @returns {string}\n   * @private\n   */\n\n\n  static idToBinary(num) {\n    let bin = '';\n    let high = parseInt(num.slice(0, -10)) || 0;\n    let low = parseInt(num.slice(-10));\n\n    while (low > 0 || high > 0) {\n      bin = String(low & 1) + bin;\n      low = Math.floor(low / 2);\n\n      if (high > 0) {\n        low += 5000000000 * (high % 2);\n        high = Math.floor(high / 2);\n      }\n    }\n\n    return bin;\n  }\n  /**\n   * Transforms a snowflake from a bit string to a decimal string.\n   * @param  {string} num Bit string to be transformed\n   * @returns {Snowflake}\n   * @private\n   */\n\n\n  static binaryToID(num) {\n    let dec = '';\n\n    while (num.length > 50) {\n      const high = parseInt(num.slice(0, -32), 2);\n      const low = parseInt((high % 10).toString(2) + num.slice(-32), 2);\n      dec = (low % 10).toString() + dec;\n      num = Math.floor(high / 10).toString(2) + Math.floor(low / 10).toString(2).padStart(32, '0');\n    }\n\n    num = parseInt(num, 2);\n\n    while (num > 0) {\n      dec = (num % 10).toString() + dec;\n      num = Math.floor(num / 10);\n    }\n\n    return dec;\n  }\n  /**\n   * Breaks user, role and everyone/here mentions by adding a zero width space after every @ character\n   * @param {string} str The string to sanitize\n   * @returns {string}\n   */\n\n\n  static removeMentions(str) {\n    return str.replace(/@/g, '@\\u200b');\n  }\n  /**\n   * The content to have all mentions replaced by the equivalent text.\n   * @param {string} str The string to be converted\n   * @param {Channel} channel The channel the string was sent in\n   * @returns {string}\n   */\n\n\n  static cleanContent(str, channel) {\n    str = str.replace(/<@!?[0-9]+>/g, input => {\n      const id = input.replace(/<|!|>|@/g, '');\n\n      if (channel.type === 'dm') {\n        const user = channel.client.users.cache.get(id);\n        return user ? Util.removeMentions(`@${user.username}`) : input;\n      }\n\n      const member = channel.guild.members.cache.get(id);\n\n      if (member) {\n        return Util.removeMentions(`@${member.displayName}`);\n      } else {\n        const user = channel.client.users.cache.get(id);\n        return user ? Util.removeMentions(`@${user.username}`) : input;\n      }\n    }).replace(/<#[0-9]+>/g, input => {\n      const mentionedChannel = channel.client.channels.cache.get(input.replace(/<|#|>/g, ''));\n      return mentionedChannel ? `#${mentionedChannel.name}` : input;\n    }).replace(/<@&[0-9]+>/g, input => {\n      if (channel.type === 'dm') return input;\n      const role = channel.guild.roles.cache.get(input.replace(/<|@|>|&/g, ''));\n      return role ? `@${role.name}` : input;\n    });\n    return str;\n  }\n  /**\n   * The content to put in a codeblock with all codeblock fences replaced by the equivalent backticks.\n   * @param {string} text The string to be converted\n   * @returns {string}\n   */\n\n\n  static cleanCodeBlockContent(text) {\n    return text.replace(/```/g, '`\\u200b``');\n  }\n  /**\n   * Creates a Promise that resolves after a specified duration.\n   * @param {number} ms How long to wait before resolving (in milliseconds)\n   * @returns {Promise<void>}\n   * @private\n   */\n\n\n  static delayFor(ms) {\n    return new Promise(resolve => {\n      setTimeout(resolve, ms);\n    });\n  }\n\n}\n\nmodule.exports = Util;\n\n//# sourceURL=webpack://Fosscord/./src/util/Util.js?")},0:function(module,exports){eval("/* (ignored) */\n\n//# sourceURL=webpack://Fosscord/https_(ignored)?")},1:function(module,exports){eval("/* (ignored) */\n\n//# sourceURL=webpack://Fosscord/./voice/ClientVoiceManager_(ignored)?")},2:function(module,exports){eval("/* (ignored) */\n\n//# sourceURL=webpack://Fosscord/erlpack_(ignored)?")},3:function(module,exports){eval("/* (ignored) */\n\n//# sourceURL=webpack://Fosscord/ws_(ignored)?")},4:function(module,exports){eval("/* (ignored) */\n\n//# sourceURL=webpack://Fosscord/zlib-sync_(ignored)?")},5:function(module,exports){eval("/* (ignored) */\n\n//# sourceURL=webpack://Fosscord/../sharding/ShardClientUtil_(ignored)?")},6:function(module,exports){eval("/* (ignored) */\n\n//# sourceURL=webpack://Fosscord/worker_threads_(ignored)?")},7:function(module,exports){eval("/* (ignored) */\n\n//# sourceURL=webpack://Fosscord/./sharding/Shard_(ignored)?")},8:function(module,exports){eval("/* (ignored) */\n\n//# sourceURL=webpack://Fosscord/./sharding/ShardClientUtil_(ignored)?")},9:function(module,exports){eval("/* (ignored) */\n\n//# sourceURL=webpack://Fosscord/./sharding/ShardingManager_(ignored)?")}})}));